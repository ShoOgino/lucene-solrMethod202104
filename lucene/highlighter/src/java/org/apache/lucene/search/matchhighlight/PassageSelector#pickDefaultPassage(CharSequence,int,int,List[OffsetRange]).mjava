  /**
   * Invoked when no passages could be selected (due to constraints or lack of highlight markers).
   */
  protected Passage[] pickDefaultPassage(
      CharSequence value,
      int maxCharacterWindow,
      int maxPassages,
      List<OffsetRange> permittedPassageRanges) {
    // Search for the first range that is not empty.
    ArrayList<Passage> defaultPassages = new ArrayList<>();
    for (OffsetRange o : permittedPassageRanges) {
      if (defaultPassages.size() >= maxPassages) {
        break;
      }

      int to = Math.min(value.length(), o.to);
      if (o.from < to) {
        defaultPassages.add(
            new Passage(
                o.from,
                o.from + Math.min(maxCharacterWindow, o.length()),
                Collections.emptyList()));
      }
    }

    return defaultPassages.toArray(Passage[]::new);
  }

