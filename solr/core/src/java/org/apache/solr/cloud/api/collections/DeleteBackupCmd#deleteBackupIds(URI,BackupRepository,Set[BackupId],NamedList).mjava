    void deleteBackupIds(URI backupPath, BackupRepository repository,
                         Set<BackupId> backupIdsDeletes,
                         @SuppressWarnings({"rawtypes"}) NamedList results) throws IOException {
        BackupFilePaths incBackupFiles = new BackupFilePaths(repository, backupPath);
        URI shardBackupMetadataDir = incBackupFiles.getShardBackupMetadataDir();

        Set<String> referencedIndexFiles = new HashSet<>();
        List<ShardBackupId> shardBackupIdFileDeletes = new ArrayList<>();


        List<ShardBackupId> shardBackupIds = Arrays.stream(repository.listAllOrEmpty(shardBackupMetadataDir))
                .map(sbi -> ShardBackupId.fromShardMetadataFilename(sbi))
                .collect(Collectors.toList());
        for (ShardBackupId shardBackupId : shardBackupIds) {
            final BackupId backupId = shardBackupId.getContainingBackupId();

            if (backupIdsDeletes.contains(backupId)) {
                shardBackupIdFileDeletes.add(shardBackupId);
            } else {
                ShardBackupMetadata shardBackupMetadata = ShardBackupMetadata.from(repository, shardBackupMetadataDir, shardBackupId);
                if (shardBackupMetadata != null)
                    referencedIndexFiles.addAll(shardBackupMetadata.listUniqueFileNames());
            }
        }


        Map<BackupId, AggregateBackupStats> backupIdToCollectionBackupPoint = new HashMap<>();
        List<String> unusedFiles = new ArrayList<>();
        for (ShardBackupId shardBackupIdToDelete : shardBackupIdFileDeletes) {
            BackupId backupId = shardBackupIdToDelete.getContainingBackupId();
            ShardBackupMetadata shardBackupMetadata = ShardBackupMetadata.from(repository, shardBackupMetadataDir, shardBackupIdToDelete);
            if (shardBackupMetadata == null)
                continue;

            backupIdToCollectionBackupPoint
                    .putIfAbsent(backupId, new AggregateBackupStats());
            backupIdToCollectionBackupPoint.get(backupId).add(shardBackupMetadata);

            for (String uniqueIndexFile : shardBackupMetadata.listUniqueFileNames()) {
                if (!referencedIndexFiles.contains(uniqueIndexFile)) {
                    unusedFiles.add(uniqueIndexFile);
                }
            }
        }

        repository.delete(incBackupFiles.getShardBackupMetadataDir(),
                shardBackupIdFileDeletes.stream().map(ShardBackupId::getIdAsString).collect(Collectors.toList()), true);
        repository.delete(incBackupFiles.getIndexDir(), unusedFiles, true);
        try {
            for (BackupId backupId : backupIdsDeletes) {
                repository.deleteDirectory(repository.resolve(backupPath, BackupFilePaths.getZkStateDir(backupId)));
            }
        } catch (FileNotFoundException e) {
            //ignore this
        }

        //add details to result before deleting backupPropFiles
        addResult(backupPath, repository, backupIdsDeletes, backupIdToCollectionBackupPoint, results);
        repository.delete(backupPath, backupIdsDeletes.stream().map(id -> BackupFilePaths.getBackupPropsName(id)).collect(Collectors.toList()), true);
    }

