  private void populateQueryCache(MonitorQuerySerializer serializer, QueryDecomposer decomposer) throws IOException {
    if (serializer == null) {
      // No query serialization happening here - check that the cache is empty
      IndexSearcher searcher = manager.acquire();
      try {
        if (searcher.count(new MatchAllDocsQuery()) != 0) {
          throw new IllegalStateException("Attempting to open a non-empty monitor query index with no MonitorQuerySerializer");
        }
      }
      finally {
        manager.release(searcher);
      }
      return;
    }
    Set<String> ids = new HashSet<>();
    List<Exception> errors = new ArrayList<>();
    purgeCache(newCache -> scan((id, cacheEntry, dataValues) -> {
      if (ids.contains(id)) {
        // this is a branch of a query that has already been reconstructed, but
        // then split by decomposition - we don't need to parse it again
        return;
      }
      ids.add(id);
      try {
        MonitorQuery mq = serializer.deserialize(dataValues.mq.binaryValue());
        for (QueryCacheEntry entry : QueryCacheEntry.decompose(mq, decomposer)) {
          newCache.put(entry.cacheId, entry);
        }
      }
      catch (Exception e) {
        errors.add(e);
      }
    }));
    if (errors.size() > 0) {
      IllegalStateException e = new IllegalStateException("Couldn't parse some queries from the index");
      for (Exception parseError : errors) {
        e.addSuppressed(parseError);
      }
      throw e;
    }
  }

