  @Override
  public final void readLEFloats(float[] floats, int offset, int len) throws IOException {
    // See notes about readELongs above
    if (curFloatBufferViews == null) {
      curFloatBufferViews = new FloatBuffer[Float.BYTES];
      for (int i = 0; i < Float.BYTES; ++i) {
        // Compute a view for each possible alignment.
        if (i < curBuf.limit()) {
          ByteBuffer dup = curBuf.duplicate().order(ByteOrder.LITTLE_ENDIAN);
          dup.position(i);
          curFloatBufferViews[i] = dup.asFloatBuffer();
        } else {
          curFloatBufferViews[i] = EMPTY_FLOATBUFFER;
        }
      }
    }
    try {
      final int position = curBuf.position();
      FloatBuffer floatBuffer = curFloatBufferViews[position & 0x03];
      floatBuffer.position(position >>> 2);
      guard.getFloats(floatBuffer, floats, offset, len);
      // if the above call succeeded, then we know the below sum cannot overflow
      curBuf.position(position + (len << 2));
    } catch (BufferUnderflowException e) {
      super.readLEFloats(floats, offset, len);
    } catch (NullPointerException npe) {
      throw new AlreadyClosedException("Already closed: " + this);
    }
  }

