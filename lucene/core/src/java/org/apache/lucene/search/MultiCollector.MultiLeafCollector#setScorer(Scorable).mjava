    @Override
    public void setScorer(Scorable scorer) throws IOException {
      if (cacheScores) {
        scorer = new ScoreCachingWrappingScorer(scorer);
      }
      if (skipNonCompetitiveScores) {
        for (int i = 0; i < collectors.length; ++i) {
          final LeafCollector c = collectors[i];
          if (c != null) {
            c.setScorer(new MinCompetitiveScoreAwareScorable(scorer,  i,  minScores));
          }
        }
      } else {
        scorer = new FilterScorable(scorer) {
          @Override
          public void setMinCompetitiveScore(float minScore) throws IOException {
            // Ignore calls to setMinCompetitiveScore so that if we wrap two
            // collectors and one of them wants to skip low-scoring hits, then
            // the other collector still sees all hits.
          }

        };
        for (int i = 0; i < collectors.length; ++i) {
          final LeafCollector c = collectors[i];
          if (c != null) {
            c.setScorer(scorer);
          }
        }
      }
    }

