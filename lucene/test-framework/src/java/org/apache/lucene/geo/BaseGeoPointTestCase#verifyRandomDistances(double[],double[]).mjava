  protected void verifyRandomDistances(double[] lats, double[] lons) throws Exception {
    IndexWriterConfig iwc = newIndexWriterConfig();
    // Else seeds may not reproduce:
    iwc.setMergeScheduler(new SerialMergeScheduler());
    // Else we can get O(N^2) merging:
    int mbd = iwc.getMaxBufferedDocs();
    if (mbd != -1 && mbd < lats.length / 100) {
      iwc.setMaxBufferedDocs(lats.length / 100);
    }
    Directory dir;
    if (lats.length > 100000) {
      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));
    } else {
      dir = newDirectory();
    }

    Set<Integer> deleted = new HashSet<>();
    // RandomIndexWriter is too slow here:
    IndexWriter w = new IndexWriter(dir, iwc);
    indexPoints(lats, lons, deleted, w);

    final IndexReader r = DirectoryReader.open(w);
    w.close();

    IndexSearcher s = newSearcher(r);

    int iters = atLeast(25);

    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());
    int maxDoc = s.getIndexReader().maxDoc();

    for (int iter = 0; iter < iters; iter++) {

      if (VERBOSE) {
        System.out.println("\nTEST: iter=" + iter + " s=" + s);
      }

      // Distance
      final double centerLat = nextLatitude();
      final double centerLon = nextLongitude();

      // So the query can cover at most 50% of the earth's surface:
      final double radiusMeters =
          random().nextDouble() * GeoUtils.EARTH_MEAN_RADIUS_METERS * Math.PI / 2.0 + 1.0;

      if (VERBOSE) {
        final DecimalFormat df =
            new DecimalFormat("#,###.00", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        System.out.println("  radiusMeters = " + df.format(radiusMeters));
      }

      Query query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);

      if (VERBOSE) {
        System.out.println("  query=" + query);
      }

      final FixedBitSet hits = searchIndex(s, query, maxDoc);

      boolean fail = false;
      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, "id");
      for (int docID = 0; docID < maxDoc; docID++) {
        assertEquals(docID, docIDToID.nextDoc());
        int id = (int) docIDToID.longValue();
        boolean expected;
        if (liveDocs != null && liveDocs.get(docID) == false) {
          // document is deleted
          expected = false;
        } else if (Double.isNaN(lats[id])) {
          expected = false;
        } else {
          expected =
              SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]) <= radiusMeters;
        }

        if (hits.get(docID) != expected) {
          Consumer<StringBuilder> explain =
              (b) -> {
                if (Double.isNaN(lats[id]) == false) {
                  double distanceMeters =
                      SloppyMath.haversinMeters(centerLat, centerLon, lats[id], lons[id]);
                  b.append("  centerLat=")
                      .append(centerLat)
                      .append(" centerLon=")
                      .append(centerLon)
                      .append(" distanceMeters=")
                      .append(distanceMeters)
                      .append(" vs radiusMeters=")
                      .append(radiusMeters);
                }
              };
          buildError(docID, expected, id, lats, lons, query, liveDocs, explain);
          fail = true;
        }
      }
      if (fail) {
        fail("some hits were wrong");
      }
    }

    IOUtils.close(r, dir);
  }

