  /**
   * For every number of bits per value, there is a minimum number of blocks (b) / values (v) you
   * need to write in order to reach the next block boundary:
   *
   * <pre>
   *  - 16 bits per value -&gt; b=2, v=1
   *  - 24 bits per value -&gt; b=3, v=1
   *  - 50 bits per value -&gt; b=25, v=4
   *  - 63 bits per value -&gt; b=63, v=8
   *  - ...
   * </pre>
   *
   * A bulk read consists in copying <code>iterations*v</code> values that are contained in <code>
   * iterations*b</code> blocks into a <code>long[]</code> (higher values of <code>iterations</code>
   * are likely to yield a better throughput): this requires n * (b + 8v) bytes of memory.
   *
   * <p>This method computes <code>iterations</code> as <code>ramBudget / (b + 8v)</code> (since a
   * long is 8 bytes).
   */
  public final int computeIterations(int valueCount, int ramBudget) {
    final int iterations = ramBudget / (byteBlockCount() + 8 * byteValueCount());
    if (iterations == 0) {
      // at least 1
      return 1;
    } else if ((iterations - 1) * byteValueCount() >= valueCount) {
      // don't allocate for more than the size of the reader
      return (int) Math.ceil((double) valueCount / byteValueCount());
    } else {
      return iterations;
    }
  }

