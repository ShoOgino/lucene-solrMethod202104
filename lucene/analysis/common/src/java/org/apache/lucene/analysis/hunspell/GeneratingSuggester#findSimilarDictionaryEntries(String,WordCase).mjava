  private List<Weighted<Root<String>>> findSimilarDictionaryEntries(
      String word, WordCase originalCase) {
    Comparator<Weighted<Root<String>>> natural = Comparator.naturalOrder();
    PriorityQueue<Weighted<Root<String>>> roots = new PriorityQueue<>(natural.reversed());
    List<Root<String>> entries = new ArrayList<>();
    boolean ignoreTitleCaseRoots = originalCase == WordCase.LOWER && !dictionary.hasLanguage("de");
    EnumSet<NGramOptions> options = EnumSet.of(NGramOptions.LONGER_WORSE);

    IntsRefFSTEnum<IntsRef> fstEnum = new IntsRefFSTEnum<>(dictionary.words);
    InputOutput<IntsRef> mapping;
    while ((mapping = nextKey(fstEnum, word.length() + 4)) != null) {
      speller.checkCanceled.run();

      IntsRef key = mapping.input;
      if (Math.abs(key.length - word.length()) > MAX_ROOT_LENGTH_DIFF) {
        assert key.length < word.length(); // nextKey takes care of longer keys
        continue;
      }

      String root = toString(key);
      filterSuitableEntries(root, mapping.output, entries);
      if (entries.isEmpty()) continue;

      if (ignoreTitleCaseRoots && WordCase.caseOf(root) == WordCase.TITLE) {
        continue;
      }

      String lower = dictionary.toLowerCase(root);
      int sc = ngram(3, word, lower, options) + commonPrefix(word, root);

      if (roots.size() == MAX_ROOTS && sc < roots.peek().score) {
        continue;
      }

      entries.forEach(e -> roots.add(new Weighted<>(e, sc)));
      while (roots.size() > MAX_ROOTS) {
        roots.poll();
      }
    }
    return roots.stream().sorted().collect(Collectors.toList());
  }

