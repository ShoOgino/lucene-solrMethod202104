  /**
   * First schema change creates a new "number" DV field off the stored field; subsequent changes
   * just change the value of that number field for all docs.
   */
  public void testRandomMultipleSchemaGensSameField() throws Exception {

    AtomicLong currentSchemaGen = new AtomicLong();
    AtomicLong mergingSchemaGen = new AtomicLong();

    ReindexingReader reindexer = null;

    // TODO: separate refresh thread, search threads, indexing threads
    int numDocs = atLeast(TEST_NIGHTLY ? 20000 : 200);
    int maxID = 0;
    Path root = createTempDir();
    int refreshEveryNumDocs = 100;
    int commitCloseNumDocs = 1000;

    for (int i = 0; i < numDocs; i++) {
      if (reindexer == null) {
        if (DEBUG)
          System.out.println(
              Thread.currentThread().getName() + ": TEST TOP: open new reader/writer");
        reindexer = getReindexerSameDVField(root, currentSchemaGen, mergingSchemaGen);
      }

      Document doc = new Document();
      String id;
      String updateID;
      if (maxID > 0 && random().nextInt(10) == 7) {
        // Replace a doc
        id = "" + random().nextInt(maxID);
        updateID = id;
      } else {
        id = "" + (maxID++);
        updateID = null;
      }

      doc.add(newStringField("id", id, Field.Store.NO));
      doc.add(
          newTextField(
              "text", "number " + TestUtil.nextInt(random(), -10000, 10000), Field.Store.YES));
      if (updateID == null) {
        reindexer.w.addDocument(doc);
      } else {
        reindexer.w.updateDocument(new Term("id", updateID), doc);
      }
      if (random().nextInt(refreshEveryNumDocs) == 17) {
        if (DEBUG)
          System.out.println(
              Thread.currentThread().getName() + ": TEST TOP: refresh @ " + (i + 1) + " docs");
        reindexer.mgr.maybeRefresh();
        DirectoryReader r = reindexer.mgr.acquire();
        if (DEBUG)
          System.out.println(Thread.currentThread().getName() + ": TEST TOP: got reader=" + r);
        try {
          checkAllNumberDVs(r, "number", true, (int) currentSchemaGen.get());
        } finally {
          reindexer.mgr.release(r);
        }
        if (DEBUG) reindexer.printRefCounts();
        refreshEveryNumDocs = (int) (1.25 * refreshEveryNumDocs);
      }

      if (random().nextInt(500) == 17) {
        currentSchemaGen.incrementAndGet();
        if (DEBUG)
          System.out.println(
              Thread.currentThread().getName()
                  + ": TEST TOP: advance schemaGen to "
                  + currentSchemaGen);
        if (random().nextBoolean()) {
          mergingSchemaGen.incrementAndGet();
          if (DEBUG)
            System.out.println(
                Thread.currentThread().getName()
                    + ": TEST TOP: advance mergingSchemaGen to "
                    + mergingSchemaGen);
        }
      }

      if (i > 0 && random().nextInt(10) == 7) {
        // Random delete:
        reindexer.w.deleteDocuments(new Term("id", "" + random().nextInt(i)));
      }

      if (random().nextInt(commitCloseNumDocs) == 17) {
        if (DEBUG)
          System.out.println(
              Thread.currentThread().getName() + ": TEST TOP: commit @ " + (i + 1) + " docs");
        reindexer.commit();
        // reindexer.printRefCounts();
        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);
      }

      // Sometimes close & reopen writer/manager, to confirm the parallel segments persist:
      if (random().nextInt(commitCloseNumDocs) == 17) {
        if (DEBUG)
          System.out.println(
              Thread.currentThread().getName() + ": TEST TOP: close writer @ " + (i + 1) + " docs");
        reindexer.close();
        reindexer = null;
        commitCloseNumDocs = (int) (1.25 * commitCloseNumDocs);
      }
    }

    if (reindexer != null) {
      reindexer.close();
    }

    // Verify main index never reflects schema changes beyond mergingSchemaGen:
    try (Directory dir = newFSDirectory(root.resolve("index"));
        IndexReader r = DirectoryReader.open(dir)) {
      for (LeafReaderContext ctx : r.leaves()) {
        LeafReader leaf = ctx.reader();
        NumericDocValues numbers = leaf.getNumericDocValues("number");
        if (numbers != null) {
          int maxDoc = leaf.maxDoc();
          for (int i = 0; i < maxDoc; i++) {
            Document doc = leaf.document(i);
            long value = Long.parseLong(doc.get("text").split(" ")[1]);
            assertEquals(i, numbers.nextDoc());
            long dvValue = numbers.longValue();
            if (value == 0) {
              assertEquals(0, dvValue);
            } else {
              assertTrue(dvValue % value == 0);
              assertTrue(dvValue / value <= mergingSchemaGen.get());
            }
          }
        }
      }
    }
  }

