  // TODO: does not really belong here, but we test it like this for now
  // we can make a fake IndexReader to send boxes directly to Point visitors instead?
  public void testCircleOpto() throws Exception {
    Random random = random();
    int iters = atLeast(random, 3);
    for (int i = 0; i < iters; i++) {
      // circle
      final double centerLat = -90 + 180.0 * random.nextDouble();
      final double centerLon = -180 + 360.0 * random.nextDouble();
      final double radius = 50_000_000D * random.nextDouble();
      final Rectangle box = Rectangle.fromPointDistance(centerLat, centerLon, radius);
      // TODO: remove this leniency!
      if (box.crossesDateline()) {
        --i; // try again...
        continue;
      }
      final double axisLat = Rectangle.axisLat(centerLat, radius);

      int innerIters = atLeast(100);
      for (int k = 0; k < innerIters; ++k) {
        double[] latBounds = {-90, box.minLat, axisLat, box.maxLat, 90};
        double[] lonBounds = {-180, box.minLon, centerLon, box.maxLon, 180};
        // first choose an upper left corner
        int maxLatRow = random.nextInt(4);
        double latMax = randomInRange(random, latBounds[maxLatRow], latBounds[maxLatRow + 1]);
        int minLonCol = random.nextInt(4);
        double lonMin = randomInRange(random, lonBounds[minLonCol], lonBounds[minLonCol + 1]);
        // now choose a lower right corner
        int minLatMaxRow =
            maxLatRow == 3 ? 3 : maxLatRow + 1; // make sure it will at least cross into the bbox
        int minLatRow = random.nextInt(minLatMaxRow);
        double latMin =
            randomInRange(random, latBounds[minLatRow], Math.min(latBounds[minLatRow + 1], latMax));
        int maxLonMinCol = Math.max(minLonCol, 1); // make sure it will at least cross into the bbox
        int maxLonCol = maxLonMinCol + random.nextInt(4 - maxLonMinCol);
        double lonMax =
            randomInRange(random, Math.max(lonBounds[maxLonCol], lonMin), lonBounds[maxLonCol + 1]);

        assert latMax >= latMin;
        assert lonMax >= lonMin;

        if (isDisjoint(centerLat, centerLon, radius, axisLat, latMin, latMax, lonMin, lonMax)) {
          // intersects says false: test a ton of points
          for (int j = 0; j < 200; j++) {
            double lat = latMin + (latMax - latMin) * random.nextDouble();
            double lon = lonMin + (lonMax - lonMin) * random.nextDouble();

            if (random.nextBoolean()) {
              // explicitly test an edge
              int edge = random.nextInt(4);
              if (edge == 0) {
                lat = latMin;
              } else if (edge == 1) {
                lat = latMax;
              } else if (edge == 2) {
                lon = lonMin;
              } else if (edge == 3) {
                lon = lonMax;
              }
            }
            double distance = SloppyMath.haversinMeters(centerLat, centerLon, lat, lon);
            try {
              assertTrue(
                  String.format(
                      Locale.ROOT,
                      "\nisDisjoint(\n"
                          + "centerLat=%s\n"
                          + "centerLon=%s\n"
                          + "radius=%s\n"
                          + "latMin=%s\n"
                          + "latMax=%s\n"
                          + "lonMin=%s\n"
                          + "lonMax=%s) == false BUT\n"
                          + "haversin(%s, %s, %s, %s) = %s\nbbox=%s",
                      centerLat,
                      centerLon,
                      radius,
                      latMin,
                      latMax,
                      lonMin,
                      lonMax,
                      centerLat,
                      centerLon,
                      lat,
                      lon,
                      distance,
                      Rectangle.fromPointDistance(centerLat, centerLon, radius)),
                  distance > radius);
            } catch (AssertionError e) {
              EarthDebugger ed = new EarthDebugger();
              ed.addRect(latMin, latMax, lonMin, lonMax);
              ed.addCircle(centerLat, centerLon, radius, true);
              System.out.println(ed.finish());
              throw e;
            }
          }
        }
      }
    }
  }

