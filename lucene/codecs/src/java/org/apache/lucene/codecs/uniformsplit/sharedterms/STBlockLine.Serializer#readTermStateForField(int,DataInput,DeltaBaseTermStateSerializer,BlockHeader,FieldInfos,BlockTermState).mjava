    /**
     * Reads a single {@link BlockTermState} for the provided field in the current block line of the
     * provided input.
     *
     * @param termStatesInput Data input to read the {@link BlockTermState} from.
     * @param blockHeader Current block header.
     * @param reuse A previous {@link BlockTermState} to reuse; or null to create a new one.
     * @return The {@link BlockTermState} corresponding to the provided field id; or null if the
     *     field does not occur in the line.
     */
    public BlockTermState readTermStateForField(
        int fieldId,
        DataInput termStatesInput,
        DeltaBaseTermStateSerializer termStateSerializer,
        BlockHeader blockHeader,
        FieldInfos fieldInfos,
        BlockTermState reuse)
        throws IOException {
      assert fieldId >= 0;
      int numFields = termStatesInput.readZInt();
      if (numFields <= 0) {
        int readFieldId = -numFields;
        if (fieldId == readFieldId) {
          return termStateSerializer.readTermState(
              blockHeader.getBaseDocsFP(),
              blockHeader.getBasePositionsFP(),
              blockHeader.getBasePayloadsFP(),
              termStatesInput,
              fieldInfos.fieldInfo(readFieldId),
              reuse);
        }
        return null;
      }

      // There are multiple fields for the term.
      // We have to read all the field ids (aka field numbers) sequentially.
      // Then if the required field is in the list, we have to read all the TermState
      // sequentially. This could be optimized with a jump-to-middle offset
      // for example, but we don't need that currently.

      boolean isFieldInList = false;
      int[] readFieldIds = new int[numFields];
      for (int i = 0; i < numFields; i++) {
        int readFieldId = termStatesInput.readVInt();
        if (!isFieldInList && readFieldId > fieldId) {
          // As the list of fieldIds is sorted we can return early if we find fieldId greater than
          // the seeked one.
          // But if we found the seeked one, we have to read all the list to get to the term state
          // part afterward (there is no jump offset).
          return null;
        }
        isFieldInList |= readFieldId == fieldId;
        readFieldIds[i] = readFieldId;
      }
      if (isFieldInList) {
        for (int readFieldId : readFieldIds) {
          BlockTermState termState =
              termStateSerializer.readTermState(
                  blockHeader.getBaseDocsFP(),
                  blockHeader.getBasePositionsFP(),
                  blockHeader.getBasePayloadsFP(),
                  termStatesInput,
                  fieldInfos.fieldInfo(readFieldId),
                  reuse);
          if (fieldId == readFieldId) {
            return termState;
          }
        }
      }
      return null;
    }

