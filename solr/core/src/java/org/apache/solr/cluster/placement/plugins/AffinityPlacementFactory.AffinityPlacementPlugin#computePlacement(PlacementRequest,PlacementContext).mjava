    @Override
    @SuppressForbidden(reason = "Ordering.arbitrary() has no equivalent in Comparator class. Rather reuse than copy.")
    public PlacementPlan computePlacement(PlacementRequest request, PlacementContext placementContext) throws PlacementException {
      Set<Node> nodes = request.getTargetNodes();
      SolrCollection solrCollection = request.getCollection();

      // Request all needed attributes
      AttributeFetcher attributeFetcher = placementContext.getAttributeFetcher();
      attributeFetcher
              .requestNodeSystemProperty(AffinityPlacementConfig.AVAILABILITY_ZONE_SYSPROP)
              .requestNodeSystemProperty(AffinityPlacementConfig.NODE_TYPE_SYSPROP)
              .requestNodeSystemProperty(AffinityPlacementConfig.REPLICA_TYPE_SYSPROP);
      attributeFetcher
              .requestNodeMetric(NodeMetricImpl.NUM_CORES)
              .requestNodeMetric(NodeMetricImpl.FREE_DISK_GB);
      attributeFetcher.fetchFrom(nodes);
      final AttributeValues attrValues = attributeFetcher.fetchAttributes();
      // filter out nodes that don't meet the `withCollection` constraint
      nodes = filterNodesWithCollection(placementContext.getCluster(), request, attrValues, nodes);
      // filter out nodes that don't match the "node types" specified in the collection props
      nodes = filterNodesByNodeType(placementContext.getCluster(), request, attrValues, nodes);


      // Split the set of nodes into 3 sets of nodes accepting each replica type (sets can overlap if nodes accept multiple replica types)
      // These subsets sets are actually maps, because we capture the number of cores (of any replica type) present on each node.
      // Also get the number of currently existing cores per node, so we can keep update as we place new cores to not end up
      // always selecting the same node(s).
      Pair<EnumMap<Replica.ReplicaType, Set<Node>>, Map<Node, Integer>> p = getNodesPerReplicaType(nodes, attrValues);

      EnumMap<Replica.ReplicaType, Set<Node>> replicaTypeToNodes = p.first();
      Map<Node, Integer> coresOnNodes = p.second();

      // All available zones of live nodes. Due to some nodes not being candidates for placement, and some existing replicas
      // being one availability zones that might be offline (i.e. their nodes are not live), this set might contain zones
      // on which it is impossible to place replicas. That's ok.
      Set<String> availabilityZones = getZonesFromNodes(nodes, attrValues);

      // Build the replica placement decisions here
      Set<ReplicaPlacement> replicaPlacements = new HashSet<>();

      // Let's now iterate on all shards to create replicas for and start finding home sweet homes for the replicas
      for (String shardName : request.getShardNames()) {
        // Inventory nodes (if any) that already have a replica of any type for the shard, because we can't be placing
        // additional replicas on these. This data structure is updated after each replica to node assign and is used to
        // make sure different replica types are not allocated to the same nodes (protecting same node assignments within
        // a given replica type is done "by construction" in makePlacementDecisions()).
        Set<Node> nodesWithReplicas = new HashSet<>();
        Shard shard = solrCollection.getShard(shardName);
        if (shard != null) {
          for (Replica r : shard.replicas()) {
            nodesWithReplicas.add(r.getNode());
          }
        }

        // Iterate on the replica types in the enum order. We place more strategic replicas first
        // (NRT is more strategic than TLOG more strategic than PULL). This is in case we eventually decide that less
        // strategic replica placement impossibility is not a problem that should lead to replica placement computation
        // failure. Current code does fail if placement is impossible (constraint is at most one replica of a shard on any node).
        for (Replica.ReplicaType replicaType : Replica.ReplicaType.values()) {
          makePlacementDecisions(solrCollection, shardName, availabilityZones, replicaType, request.getCountReplicasToCreate(replicaType),
              attrValues, replicaTypeToNodes, nodesWithReplicas, coresOnNodes, placementContext.getPlacementPlanFactory(), replicaPlacements);
        }
      }

      return placementContext.getPlacementPlanFactory().createPlacementPlan(request, replicaPlacements);
    }

