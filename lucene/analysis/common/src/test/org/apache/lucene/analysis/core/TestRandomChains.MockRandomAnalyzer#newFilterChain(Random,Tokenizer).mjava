    private TokenFilterSpec newFilterChain(Random random, Tokenizer tokenizer) {
      TokenFilterSpec spec = new TokenFilterSpec();
      spec.stream = tokenizer;
      StringBuilder descr = new StringBuilder();
      int numFilters = random.nextInt(5);
      for (int i = 0; i < numFilters; i++) {

        // Insert ValidatingTF after each stage so we can
        // catch problems right after the TF that "caused"
        // them:
        spec.stream = new ValidatingTokenFilter(spec.stream, "stage " + i);

        while (true) {
          final Constructor<? extends TokenFilter> ctor = tokenfilters.get(random.nextInt(tokenfilters.size()));
          if (random.nextBoolean() && avoidConditionals.contains(ctor.getDeclaringClass()) == false) {
            long seed = random.nextLong();
            spec.stream = new ConditionalTokenFilter(spec.stream, in -> {
              final Object args[] = newFilterArgs(random, in, ctor.getParameterTypes());
              if (broken(ctor, args)) {
                return in;
              }
              TokenStream ts = createComponent(ctor, args, descr, true);
              if (ts == null) {
                return in;
              }
              return ts;
            }) {
              Random random = new Random(seed);

              @Override
              public void reset() throws IOException {
                super.reset();
                random = new Random(seed);
              }

              @Override
              protected boolean shouldFilter() throws IOException {
                return random.nextBoolean();
              }
            };
            break;
          }
          else {
            final Object args[] = newFilterArgs(random, spec.stream, ctor.getParameterTypes());
            if (broken(ctor, args)) {
              continue;
            }
            final TokenFilter flt = createComponent(ctor, args, descr, false);
            if (flt != null) {
              spec.stream = flt;
              break;
            }
          }
        }
      }

      // Insert ValidatingTF after each stage so we can
      // catch problems right after the TF that "caused"
      // them:
      spec.stream = new ValidatingTokenFilter(spec.stream, "last stage");

      spec.toString = descr.toString();
      return spec;
    }

