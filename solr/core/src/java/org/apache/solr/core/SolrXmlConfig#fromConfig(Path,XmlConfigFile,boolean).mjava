  public static NodeConfig fromConfig(Path solrHome, XmlConfigFile config, boolean fromZookeeper) {

    checkForIllegalConfig(config);

    // sanity check: if our config came from zookeeper, then there *MUST* be Node Properties that tell us
    // what zkHost was used to read it (either via webapp context attribute, or that SolrDispatchFilter
    // filled in for us from system properties)
    assert ( (! fromZookeeper) || (null != config.getSubstituteProperties()
                                   && null != config.getSubstituteProperties().getProperty(ZK_HOST)));
    
    // Regardless of where/how we this XmlConfigFile was loaded from, if it contains a zkHost property,
    // we're going to use that as our "default" and only *directly* check the system property if it's not specified.
    //
    // (checking the sys prop here is really just for tests that by-pass SolrDispatchFilter. In non-test situations,
    // SolrDispatchFilter will check the system property if needed in order to try and load solr.xml from ZK, and
    // should have put the sys prop value in the node properties for us)
    final String defaultZkHost
      = wrapAndSetZkHostFromSysPropIfNeeded(config.getSubstituteProperties()).getProperty(ZK_HOST);
    
    CloudConfig cloudConfig = null;
    UpdateShardHandlerConfig deprecatedUpdateConfig = null;

    if (config.getNodeList("solr/solrcloud", false).getLength() > 0) {
      NamedList<Object> cloudSection = readNodeListAsNamedList(config, "solr/solrcloud/*[@name]", "<solrcloud>");
      deprecatedUpdateConfig = loadUpdateConfig(cloudSection, false);
      cloudConfig = fillSolrCloudSection(cloudSection, config, defaultZkHost);
    }

    NamedList<Object> entries = readNodeListAsNamedList(config, "solr/*[@name]", "<solr>");
    String nodeName = (String) entries.remove("nodeName");
    if (Strings.isNullOrEmpty(nodeName) && cloudConfig != null)
      nodeName = cloudConfig.getHost();

    UpdateShardHandlerConfig updateConfig;
    if (deprecatedUpdateConfig == null) {
      updateConfig = loadUpdateConfig(readNodeListAsNamedList(config, "solr/updateshardhandler/*[@name]", "<updateshardhandler>"), true);
    }
    else {
      updateConfig = loadUpdateConfig(readNodeListAsNamedList(config, "solr/updateshardhandler/*[@name]", "<updateshardhandler>"), false);
      if (updateConfig != null) {
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "UpdateShardHandler configuration defined twice in solr.xml");
      }
      updateConfig = deprecatedUpdateConfig;
    }

    NodeConfig.NodeConfigBuilder configBuilder = new NodeConfig.NodeConfigBuilder(nodeName, solrHome);
    configBuilder.setSolrResourceLoader(config.getResourceLoader());
    configBuilder.setUpdateShardHandlerConfig(updateConfig);
    configBuilder.setShardHandlerFactoryConfig(getShardHandlerFactoryPluginInfo(config));
    configBuilder.setSolrCoreCacheFactoryConfig(getTransientCoreCacheFactoryPluginInfo(config));
    configBuilder.setTracerConfig(getTracerPluginInfo(config));
    configBuilder.setLogWatcherConfig(loadLogWatcherConfig(config, "solr/logging/*[@name]", "solr/logging/watcher/*[@name]"));
    configBuilder.setSolrProperties(loadProperties(config));
    if (cloudConfig != null)
      configBuilder.setCloudConfig(cloudConfig);
    configBuilder.setBackupRepositoryPlugins(getBackupRepositoryPluginInfos(config));
    configBuilder.setMetricsConfig(getMetricsConfig(config));
    configBuilder.setFromZookeeper(fromZookeeper);
    configBuilder.setDefaultZkHost(defaultZkHost);
    return fillSolrSection(configBuilder, entries);
  }

