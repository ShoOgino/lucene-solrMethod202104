    // Make sure we actually approximately find the closest k elements. Mostly this is about
    // ensuring that we have all the distance functions, comparators, priority queues and so on
    // oriented in the right directions
    public void testAknn() throws IOException {
        int nDoc = 100;
        RandomAccessVectorValuesProducer vectors = new CircularVectorValues(nDoc);
        HnswGraph hnsw = HnswGraphBuilder.build(vectors);
        // run some searches
        Neighbors nn = HnswGraph.search(new float[]{1, 0}, 10, 5, vectors.randomAccess(), hnsw.getGraphValues(), random());
        int sum = 0;
        for (Neighbor n : nn) {
            sum += n.node();
        }
        // We expect to get approximately 100% recall; the lowest docIds are closest to zero; sum(0,9) = 45
        assertTrue("sum(result docs)=" + sum, sum < 75);
    }

