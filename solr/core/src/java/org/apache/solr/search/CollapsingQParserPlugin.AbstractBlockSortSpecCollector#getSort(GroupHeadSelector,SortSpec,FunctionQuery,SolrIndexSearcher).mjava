    /**
     * Helper method for extracting a {@link Sort} out of a {@link SortSpec} <em>or</em> creating one synthetically for
     * "min/max" {@link GroupHeadSelector} against a {@link FunctionQuery} <em>or</em> simple field name.
     *
     * @return appropriate (already re-written) Sort to use with a AbstractBlockSortSpecCollector
     */
    public static Sort getSort(final GroupHeadSelector groupHeadSelector,
                               final SortSpec sortSpec,
                               final FunctionQuery funcQuery,
                               final SolrIndexSearcher searcher) throws IOException {
      if (null != sortSpec) {
        assert GroupHeadSelectorType.SORT.equals(groupHeadSelector.type);

        // a "feature" of SortSpec is that getSort() is null if we're just using 'score desc'
        if (null == sortSpec.getSort()) {
          return Sort.RELEVANCE.rewrite(searcher);
        }
        return sortSpec.getSort().rewrite(searcher);
        
      } // else: min/max on field or value source...

      assert GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type);
      assert ! CollapseScore.wantsCScore(groupHeadSelector.selectorText);
        
      final boolean reverse = GroupHeadSelectorType.MAX.equals(groupHeadSelector.type);
      final SortField sf = (null != funcQuery)
        ? funcQuery.getValueSource().getSortField(reverse)
        : searcher.getSchema().getField(groupHeadSelector.selectorText).getSortField(reverse);
      
      return (new Sort(sf)).rewrite(searcher);
    }

