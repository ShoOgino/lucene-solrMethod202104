    /**
     * <p>Picks nodes from {@code targetNodes} for placing {@code numReplicas} replicas.
     *
     * <p>The criteria used in this method are, in this order:
     * <ol>
     *     <li>No more than one replica of a given shard on a given node (strictly enforced)</li>
     *     <li>Balance as much as possible replicas of a given {@link org.apache.solr.cluster.Replica.ReplicaType} over available AZ's.
     *     This balancing takes into account existing replicas <b>of the corresponding replica type</b>, if any.</li>
     *     <li>Place replicas if possible on nodes having more than a certain amount of free disk space (note that nodes with a too small
     *     amount of free disk space were eliminated as placement targets earlier, in {@link #getNodesPerReplicaType}). There's
     *     a threshold here rather than sorting on the amount of free disk space, because sorting on that value would in
     *     practice lead to never considering the number of cores on a node.</li>
     *     <li>Place replicas on nodes having a smaller number of cores (the number of cores considered
     *     for this decision includes previous placement decisions made during the processing of the placement request)</li>
     * </ol>
     */
    @SuppressForbidden(reason = "Ordering.arbitrary() has no equivalent in Comparator class. Rather reuse than copy.")
    private void makePlacementDecisions(SolrCollection solrCollection, String shardName, Set<String> availabilityZones,
                                        Replica.ReplicaType replicaType, int numReplicas, final AttributeValues attrValues,
                                        EnumMap<Replica.ReplicaType, Set<Node>> replicaTypeToNodes, Set<Node> nodesWithReplicas,
                                        Map<Node, Integer> coresOnNodes, PlacementPlanFactory placementPlanFactory,
                                        Set<ReplicaPlacement> replicaPlacements) throws PlacementException {
      // Count existing replicas per AZ. We count only instances of the type of replica for which we need to do placement.
      // If we ever want to balance replicas of any type across AZ's (and not each replica type balanced independently),
      // we'd have to move this data structure to the caller of this method so it can be reused across different replica
      // type placements for a given shard. Note then that this change would be risky. For example all NRT's and PULL
      // replicas for a shard my be correctly balanced over three AZ's, but then all NRT can end up in the same AZ...
      Map<String, Integer> azToNumReplicas = new HashMap<>();
      for (String az : availabilityZones) {
        azToNumReplicas.put(az, 0);
      }

      // Build the set of candidate nodes for the placement, i.e. nodes that can accept the replica type
      Set<Node> candidateNodes = new HashSet<>(replicaTypeToNodes.get(replicaType));
      // Remove nodes that already have a replica for the shard (no two replicas of same shard can be put on same node)
      candidateNodes.removeAll(nodesWithReplicas);

      Shard shard = solrCollection.getShard(shardName);
      if (shard != null) {
        // shard is non null if we're adding replicas to an already existing collection.
        // If we're creating the collection, the shards do not exist yet.
        for (Replica replica : shard.replicas()) {
          // The node's AZ is counted as having a replica if it has a replica of the same type as the one we need
          // to place here.
          if (replica.getType() == replicaType) {
            final String az = getNodeAZ(replica.getNode(), attrValues);
            if (azToNumReplicas.containsKey(az)) {
              // We do not count replicas on AZ's for which we don't have any node to place on because it would not help
              // the placement decision. If we did want to do that, note the dereferencing below can't be assumed as the
              // entry will not exist in the map.
              azToNumReplicas.put(az, azToNumReplicas.get(az) + 1);
            }
          }
        }
      }

      // We now have the set of real candidate nodes, we've enforced "No more than one replica of a given shard on a given node".
      // We also counted for the shard and replica type under consideration how many replicas were per AZ, so we can place
      // (or try to place) replicas on AZ's that have fewer replicas

      // Get the candidate nodes per AZ in order to build (further down) a mapping of AZ to placement candidates.
      Map<String, List<Node>> nodesPerAz = new HashMap<>();
      for (Node node : candidateNodes) {
        String nodeAz = getNodeAZ(node, attrValues);
        List<Node> nodesForAz = nodesPerAz.computeIfAbsent(nodeAz, k -> new ArrayList<>());
        nodesForAz.add(node);
      }

      // Build a treeMap sorted by the number of replicas per AZ and including candidates nodes suitable for placement on the
      // AZ, so we can easily select the next AZ to get a replica assignment and quickly (constant time) decide if placement
      // on this AZ is possible or not.
      TreeMultimap<Integer, AzWithNodes> azByExistingReplicas = TreeMultimap.create(Comparator.naturalOrder(), Ordering.arbitrary());
      for (Map.Entry<String, List<Node>> e : nodesPerAz.entrySet()) {
        azByExistingReplicas.put(azToNumReplicas.get(e.getKey()), new AzWithNodes(e.getKey(), e.getValue()));
      }

      CoresAndDiskComparator coresAndDiskComparator = new CoresAndDiskComparator(attrValues, coresOnNodes, prioritizedFreeDiskGB);

      for (int i = 0; i < numReplicas; i++) {
        // We have for each AZ on which we might have a chance of placing a replica, the list of candidate nodes for replicas
        // (candidate: does not already have a replica of this shard and is in the corresponding AZ).
        // Among the AZ's with the minimal number of replicas of the given replica type for the shard, we must pick the AZ that
        // offers the best placement (based on number of cores and free disk space). In order to do so, for these "minimal" AZ's
        // we sort the nodes from best to worst placement candidate (based on the number of cores and free disk space) then pick
        // the AZ that has the best best node. We don't sort all AZ's because that will not necessarily be needed.
        int minNumberOfReplicasPerAz = 0; // This value never observed but compiler can't tell
        Set<Map.Entry<Integer, AzWithNodes>> candidateAzEntries = null;
        // Iterate over AZ's (in the order of increasing number of replicas on that AZ) and do two things: 1. remove those AZ's that
        // have no nodes, no use iterating over these again and again (as we compute placement for more replicas), and 2. collect
        // all those AZ with a minimal number of replicas.
        for (Iterator<Map.Entry<Integer, AzWithNodes>> it = azByExistingReplicas.entries().iterator(); it.hasNext(); ) {
          Map.Entry<Integer, AzWithNodes> entry = it.next();
          int numberOfNodes = entry.getValue().availableNodesForPlacement.size();
          if (numberOfNodes == 0) {
            it.remove();
          } else { // AZ does have node(s) for placement
            if (candidateAzEntries == null) {
              // First AZ with nodes that can take the replica. Initialize tracking structures
              minNumberOfReplicasPerAz = numberOfNodes;
              candidateAzEntries = new HashSet<>();
            }
            if (minNumberOfReplicasPerAz != numberOfNodes) {
              // AZ's with more replicas than the minimum number seen are not placement candidates
              break;
            }
            candidateAzEntries.add(entry);
            // We remove all entries that are candidates: the "winner" will be modified, all entries might also be sorted,
            // so we'll insert back the updated versions later.
            it.remove();
          }
        }

        if (candidateAzEntries == null) {
          // This can happen because not enough nodes for the placement request or already too many nodes with replicas of
          // the shard that can't accept new replicas or not enough nodes with enough free disk space.
          throw new PlacementException("Not enough eligible nodes to place " + numReplicas + " replica(s) of type " + replicaType +
              " for shard " + shardName + " of collection " + solrCollection.getName());
        }

        // Iterate over all candidate AZ's, sort them if needed and find the best one to use for this placement
        Map.Entry<Integer, AzWithNodes> selectedAz = null;
        Node selectedAzBestNode = null;
        for (Map.Entry<Integer, AzWithNodes> candidateAzEntry : candidateAzEntries) {
          AzWithNodes azWithNodes = candidateAzEntry.getValue();
          List<Node> nodes = azWithNodes.availableNodesForPlacement;

          if (!azWithNodes.hasBeenSorted) {
            // Make sure we do not tend to use always the same nodes (within an AZ) if all conditions are identical (well, this
            // likely is not the case since after having added a replica to a node its number of cores increases for the next
            // placement decision, but let's be defensive here, given that multiple concurrent placement decisions might see
            // the same initial cluster state, and we want placement to be reasonable even in that case without creating an
            // unnecessary imbalance).
            // For example, if all nodes have 0 cores and same amount of free disk space, ideally we want to pick a random node
            // for placement, not always the same one due to some internal ordering.
            Collections.shuffle(nodes, replicaPlacementRandom);

            // Sort by increasing number of cores but pushing nodes with low free disk space to the end of the list
            nodes.sort(coresAndDiskComparator);

            azWithNodes.hasBeenSorted = true;
          }

          // Which one is better, the new one or the previous best?
          if (selectedAz == null || coresAndDiskComparator.compare(nodes.get(0), selectedAzBestNode) < 0) {
            selectedAz = candidateAzEntry;
            selectedAzBestNode = nodes.get(0);
          }
        }

        // Now actually remove the selected node from the winning AZ
        AzWithNodes azWithNodes = selectedAz.getValue();
        List<Node> nodes = selectedAz.getValue().availableNodesForPlacement;
        Node assignTarget = nodes.remove(0);

        // Insert back all the qualifying but non winning AZ's removed while searching for the one
        for (Map.Entry<Integer, AzWithNodes> removedAzs : candidateAzEntries) {
          if (removedAzs != selectedAz) {
            azByExistingReplicas.put(removedAzs.getKey(), removedAzs.getValue());
          }
        }

        // Insert back a corrected entry for the winning AZ: one more replica living there and one less node that can accept new replicas
        // (the remaining candidate node list might be empty, in which case it will be cleaned up on the next iteration).
        azByExistingReplicas.put(selectedAz.getKey() + 1, azWithNodes);

        // Do not assign that node again for replicas of other replica type for this shard
        // (this update of the set is not useful in the current execution of this method but for following ones only)
        nodesWithReplicas.add(assignTarget);

        // Track that the node has one more core. These values are only used during the current run of the plugin.
        coresOnNodes.merge(assignTarget, 1, Integer::sum);

        // Register the replica assignment just decided
        replicaPlacements.add(placementPlanFactory.createReplicaPlacement(solrCollection, shardName, assignTarget, replicaType));
      }
    }

