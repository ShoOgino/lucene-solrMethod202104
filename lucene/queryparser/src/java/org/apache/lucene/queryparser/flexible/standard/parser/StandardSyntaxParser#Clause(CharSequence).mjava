  final public QueryNode Clause(CharSequence field) throws ParseException {QueryNode q;
  Token fieldToken=null, boost=null, operator=null, term=null;
  FieldQueryNode qLower, qUpper;
  boolean lowerInclusive, upperInclusive;

  boolean group = false;
    if (jj_2_2(3)) {
      fieldToken = jj_consume_token(TERM);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OP_COLON:
      case OP_EQUAL:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OP_COLON:{
          jj_consume_token(OP_COLON);
          break;
          }
        case OP_EQUAL:{
          jj_consume_token(OP_EQUAL);
          break;
          }
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
        q = Term(field);
        break;
        }
      case OP_LESSTHAN:
      case OP_LESSTHANEQ:
      case OP_MORETHAN:
      case OP_MORETHANEQ:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OP_LESSTHAN:{
          operator = jj_consume_token(OP_LESSTHAN);
          break;
          }
        case OP_LESSTHANEQ:{
          operator = jj_consume_token(OP_LESSTHANEQ);
          break;
          }
        case OP_MORETHAN:{
          operator = jj_consume_token(OP_MORETHAN);
          break;
          }
        case OP_MORETHANEQ:{
          operator = jj_consume_token(OP_MORETHANEQ);
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case TERM:{
          term = jj_consume_token(TERM);
          break;
          }
        case QUOTED:{
          term = jj_consume_token(QUOTED);
          break;
          }
        case NUMBER:{
          term = jj_consume_token(NUMBER);
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
if (term.kind == QUOTED) {
            term.image = term.image.substring(1, term.image.length()-1);
        }
        switch (operator.kind) {
            case OP_LESSTHAN:
              lowerInclusive = true;
              upperInclusive = false;

               qLower = new FieldQueryNode(field,
                                         "*", term.beginColumn, term.endColumn);
            qUpper = new FieldQueryNode(field,
                                 EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);

                break;
            case OP_LESSTHANEQ:
              lowerInclusive = true;
              upperInclusive = true;

                qLower = new FieldQueryNode(field,
                                         "*", term.beginColumn, term.endColumn);
                qUpper = new FieldQueryNode(field,
                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
                break;
            case OP_MORETHAN:
              lowerInclusive = false;
              upperInclusive = true;

                qLower = new FieldQueryNode(field,
                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
                qUpper = new FieldQueryNode(field,
                                         "*", term.beginColumn, term.endColumn);
                break;
            case OP_MORETHANEQ:
              lowerInclusive = true;
              upperInclusive = true;

                qLower = new FieldQueryNode(field,
                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
                qUpper = new FieldQueryNode(field,
                                         "*", term.beginColumn, term.endColumn);
                break;
            default:
                {if (true) throw new Error("Unhandled case: operator="+operator.toString());}
        }
        q = new TermRangeQueryNode(qLower, qUpper, lowerInclusive, upperInclusive);
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else if (jj_2_3(3)) {
      if (jj_2_1(3)) {
        fieldToken = jj_consume_token(TERM);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case OP_COLON:{
          jj_consume_token(OP_COLON);
          break;
          }
        case OP_EQUAL:{
          jj_consume_token(OP_EQUAL);
          break;
          }
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
      } else {
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case QUOTED:
      case TERM:
      case REGEXPTERM:
      case RANGEIN_START:
      case RANGEEX_START:
      case NUMBER:{
        q = Term(field);
        break;
        }
      case LPAREN:{
        jj_consume_token(LPAREN);
        q = Query(field);
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CARAT:{
          jj_consume_token(CARAT);
          boost = jj_consume_token(NUMBER);
          break;
          }
        default:
          jj_la1[10] = jj_gen;
          ;
        }
group=true;
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
if (boost != null) {
      float f = (float)1.0;
      try {
        f = Float.parseFloat(boost.image);
        // avoid boosting null queries, such as those caused by stop words
          if (q != null) {
            q = new BoostQueryNode(q, f);
          }
      } catch (Exception ignored) {
        /* Should this be handled somehow? (defaults to "no boost", if
             * boost number is invalid)
             */
      }
      }
      if (group) { q = new GroupQueryNode(q);}
      {if ("" != null) return q;}
    throw new Error("Missing return statement in function");
}

