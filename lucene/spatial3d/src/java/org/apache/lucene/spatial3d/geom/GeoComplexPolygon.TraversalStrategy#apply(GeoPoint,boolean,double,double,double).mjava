    public boolean apply(final GeoPoint testPoint, final boolean testPointInSet,
      final double x, final double y, final double z) {
      // First, try with two individual legs.  If that doesn't work, try the DualCrossingIterator.
      try {
        // First, we'll determine if the intersection point is in set or not
        //System.out.println(" Finding whether "+intersectionPoint+" is in-set, based on travel from "+testPoint+" along "+firstLegPlane+" (value="+firstLegValue+")");
        final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,
          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,
          intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);
        // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
        firstLegTree.traverse(testPointEdgeIterator, firstLegValue);
        final boolean intersectionPointOnEdge = testPointEdgeIterator.isOnEdge();
        // If the intersection point is on the edge, we cannot use this combination of legs, since it's not logically possible to compute in-set or out-of-set
        // with such a starting point.
        if (intersectionPointOnEdge) {
          throw new IllegalArgumentException("Intersection point landed on an edge -- illegal path");
        }
        final boolean intersectionPointInSet = intersectionPointOnEdge || (((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);
        
        //System.out.println("  Intersection point in-set? "+intersectionPointInSet+" On edge? "+intersectionPointOnEdge);

        // Now do the final leg
        //System.out.println(" Finding whether ["+x+","+y+","+z+"] is in-set, based on travel from "+intersectionPoint+" along "+secondLegPlane+" (value="+secondLegValue+")");
        final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,
          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,
          x, y, z);
        // Traverse our way from the test point to the check point.
        secondLegTree.traverse(travelEdgeIterator, secondLegValue);
        final boolean rval = travelEdgeIterator.isOnEdge() || (((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet);
        
        //System.out.println(" Check point in set? "+rval);
        return rval;
      } catch (IllegalArgumentException e) {
        // Intersection point apparently was on edge, so try another strategy
        //System.out.println(" Trying dual crossing edge iterator");
        final CountingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPoint,
          firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,
          secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,
          x, y, z, intersectionPoint);
        firstLegTree.traverse(edgeIterator, firstLegValue);
        if (edgeIterator.isOnEdge()) {
          return true;
        }
        secondLegTree.traverse(edgeIterator, secondLegValue);
        return edgeIterator.isOnEdge() || (((edgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet);
      }
    }

