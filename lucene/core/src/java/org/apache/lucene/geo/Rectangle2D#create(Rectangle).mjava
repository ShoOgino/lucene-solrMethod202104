  /** create a component2D from the provided LatLon rectangle */
  static Component2D create(Rectangle rectangle) {
    // behavior of LatLonPoint.newBoxQuery()
    double minLongitude = rectangle.minLon;
    boolean crossesDateline = rectangle.minLon > rectangle.maxLon;
    if (minLongitude == 180.0 && crossesDateline) {
      minLongitude = -180;
      crossesDateline = false;
    }
    // need to quantize!
    double qMinLat = decodeLatitude(encodeLatitudeCeil(rectangle.minLat));
    double qMaxLat = decodeLatitude(encodeLatitude(rectangle.maxLat));
    double qMinLon = decodeLongitude(encodeLongitudeCeil(minLongitude));
    double qMaxLon = decodeLongitude(encodeLongitude(rectangle.maxLon));
    if (crossesDateline) {
      // for rectangles that cross the dateline we need to create two components
      Component2D[] components = new Component2D[2];
      components[0] = new Rectangle2D(MIN_LON_INCL_QUANTIZE, qMaxLon, qMinLat, qMaxLat);
      components[1] = new Rectangle2D(qMinLon, MAX_LON_INCL_QUANTIZE, qMinLat, qMaxLat);
      return ComponentTree.create(components);
    } else {
      return new Rectangle2D(qMinLon, qMaxLon, qMinLat, qMaxLat);
    }
  }

