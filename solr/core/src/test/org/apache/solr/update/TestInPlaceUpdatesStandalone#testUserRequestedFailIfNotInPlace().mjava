  public void testUserRequestedFailIfNotInPlace() throws Exception {
    final SolrParams require_inplace = params(UpdateParams.REQUIRE_PARTIAL_DOC_UPDATES_INPLACE, "true");
    long v;
    
    // regular updates should be ok even if require_inplace params are used,
    // that way true "adds" wil work even if require_inplace params are in in "/update" defaults or invariants...
    long version1 = addAndGetVersion(sdoc("id", "1", "title_s", "first", "regular_l", 1, "inplace_updatable_float", 41), require_inplace);
    long version2 = addAndGetVersion(sdoc("id", "2", "title_s", "second", "regular_l", 2, "inplace_updatable_float", 42), require_inplace);
    long version3 = addAndGetVersion(sdoc("id", "3", "title_s", "third", "regular_l", 3, "inplace_updatable_float", 43), require_inplace);
    assertU(commit("softCommit", "false"));
    assertQ(req("q", "*:*"), "//*[@numFound='3']");

    // the reason we're fetching these docids is to validate that the subsequent updates 
    // are done in place and don't cause the docids to change
    final int docid1 = getDocId("1");
    final int docid2 = getDocId("2");
    final int docid3 = getDocId("3");

    // this atomic update should be done in place...
    v = addAndGetVersion(sdoc("id", "2", "inplace_updatable_float", map("inc", 2)), require_inplace);
    assertTrue(v > version2);
    version2 = v;

    // this atomic update should also be done in place, even though the user didn't insist on it...
    v = addAndGetVersion(sdoc("id", "3", "inplace_updatable_float", map("inc", 3)), params());
    assertTrue(v > version3);
    version3 = v;

    assertU(commit("softCommit", "false"));
    assertQ(req("q", "*:*", "sort", "id asc", "fl", "*,[docid]")
            , "//*[@numFound='3']"
            , "//result/doc[1]/long[@name='regular_l'][.='1']"
            , "//result/doc[2]/long[@name='regular_l'][.='2']"
            , "//result/doc[3]/long[@name='regular_l'][.='3']"
            , "//result/doc[1]/float[@name='inplace_updatable_float'][.='41.0']"
            , "//result/doc[2]/float[@name='inplace_updatable_float'][.='44.0']"
            , "//result/doc[3]/float[@name='inplace_updatable_float'][.='46.0']"
            , "//result/doc[1]/long[@name='_version_'][.='"+version1+"']"
            , "//result/doc[2]/long[@name='_version_'][.='"+version2+"']"
            , "//result/doc[3]/long[@name='_version_'][.='"+version3+"']"
            , "//result/doc[1]/int[@name='[docid]'][.='"+docid1+"']"
            , "//result/doc[2]/int[@name='[docid]'][.='"+docid2+"']"
            , "//result/doc[3]/int[@name='[docid]'][.='"+docid3+"']"
            );

    // this is an atomic update, but it can't be done in-place, so it should fail w/o affecting index...
    SolrException e = expectThrows(SolrException.class,
                                   () -> addAndGetVersion(sdoc("id", "1", "regular_l", map("inc", 1)),
                                                          require_inplace));
    assertEquals(SolrException.ErrorCode.BAD_REQUEST.code, e.code());
    MatcherAssert.assertThat(e.getMessage(), containsString("Unable to update doc in-place: 1"));

    // data in solr should be unchanged after failed attempt at non-inplace atomic update...
    assertU(commit("softCommit", "false"));
    assertQ(req("q", "*:*", "sort", "id asc", "fl", "*,[docid]")
            , "//*[@numFound='3']"
            , "//result/doc[1]/long[@name='regular_l'][.='1']"
            , "//result/doc[2]/long[@name='regular_l'][.='2']"
            , "//result/doc[3]/long[@name='regular_l'][.='3']"
            , "//result/doc[1]/float[@name='inplace_updatable_float'][.='41.0']"
            , "//result/doc[2]/float[@name='inplace_updatable_float'][.='44.0']"
            , "//result/doc[3]/float[@name='inplace_updatable_float'][.='46.0']"
            , "//result/doc[1]/long[@name='_version_'][.='"+version1+"']"
            , "//result/doc[2]/long[@name='_version_'][.='"+version2+"']"
            , "//result/doc[3]/long[@name='_version_'][.='"+version3+"']"
            , "//result/doc[1]/int[@name='[docid]'][.='"+docid1+"']"
            , "//result/doc[2]/int[@name='[docid]'][.='"+docid2+"']"
            , "//result/doc[3]/int[@name='[docid]'][.='"+docid3+"']"
            );

    
    // the same atomic update w/o require_inplace params should proceed, and can modify the docid(s)
    // (but we don't assert that, since it the merge policy might kick in
    v = addAndGetVersion(sdoc("id", "1", "regular_l", map("inc", 100)), params());
    assertTrue(v > version1);
    version1 = v;

    assertU(commit("softCommit", "false"));
    assertQ(req("q", "*:*", "sort", "id asc", "fl", "*")
            , "//*[@numFound='3']"
            , "//result/doc[1]/long[@name='regular_l'][.='101']"
            , "//result/doc[2]/long[@name='regular_l'][.='2']"
            , "//result/doc[3]/long[@name='regular_l'][.='3']"
            , "//result/doc[1]/float[@name='inplace_updatable_float'][.='41.0']"
            , "//result/doc[2]/float[@name='inplace_updatable_float'][.='44.0']"
            , "//result/doc[3]/float[@name='inplace_updatable_float'][.='46.0']"
            , "//result/doc[1]/long[@name='_version_'][.='"+version1+"']"
            , "//result/doc[2]/long[@name='_version_'][.='"+version2+"']"
            , "//result/doc[3]/long[@name='_version_'][.='"+version3+"']"
            );

    // a regular old re-indexing of a document should also succeed, even w/require_inplace, since it's not ant atomic update
    v = addAndGetVersion(sdoc("id", "1", "regular_l", "999"), require_inplace);
    assertTrue(v > version1);
    version1 = v;
    
    assertU(commit("softCommit", "false"));
    assertQ(req("q", "*:*", "sort", "id asc", "fl", "*")
            , "//*[@numFound='3']"
            , "//result/doc[1]/long[@name='regular_l'][.='999']"
            , "//result/doc[2]/long[@name='regular_l'][.='2']"
            , "//result/doc[3]/long[@name='regular_l'][.='3']"
            , "0=count(//result/doc[1]/float[@name='inplace_updatable_float'])" // not in new doc
            , "//result/doc[2]/float[@name='inplace_updatable_float'][.='44.0']"
            , "//result/doc[3]/float[@name='inplace_updatable_float'][.='46.0']"
            , "//result/doc[1]/long[@name='_version_'][.='"+version1+"']"
            , "//result/doc[2]/long[@name='_version_'][.='"+version2+"']"
            , "//result/doc[3]/long[@name='_version_'][.='"+version3+"']"
            );

  }

