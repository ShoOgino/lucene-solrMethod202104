  /**
   * Reads all the vectors from a VectorValues, builds a graph connecting them by their dense
   * ordinals, using the given hyperparameter settings, and returns the resulting graph.
   *
   * @param vectors the vectors whose relations are represented by the graph - must provide a
   *     different view over those vectors than the one used to add via addGraphNode.
   * @param maxConn the number of connections to make when adding a new graph node; roughly speaking
   *     the graph fanout.
   * @param beamWidth the size of the beam search to use when finding nearest neighbors.
   * @param seed the seed for a random number generator used during graph construction. Provide this
   *     to ensure repeatable construction.
   */
  public HnswGraphBuilder(
      RandomAccessVectorValuesProducer vectors, int maxConn, int beamWidth, long seed) {
    vectorValues = vectors.randomAccess();
    buildVectors = vectors.randomAccess();
    searchStrategy = vectorValues.searchStrategy();
    if (searchStrategy == VectorValues.SearchStrategy.NONE) {
      throw new IllegalStateException("No distance function");
    }
    if (maxConn <= 0) {
      throw new IllegalArgumentException("maxConn must be positive");
    }
    if (beamWidth <= 0) {
      throw new IllegalArgumentException("beamWidth must be positive");
    }
    this.maxConn = maxConn;
    this.beamWidth = beamWidth;
    this.hnsw = new HnswGraph(maxConn, searchStrategy);
    bound = BoundsChecker.create(searchStrategy.reversed);
    random = new Random(seed);
    scratch = new NeighborArray(Math.max(beamWidth, maxConn + 1));
  }

