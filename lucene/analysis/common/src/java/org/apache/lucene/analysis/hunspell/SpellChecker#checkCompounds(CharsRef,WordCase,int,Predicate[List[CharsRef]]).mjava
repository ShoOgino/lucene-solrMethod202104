  private boolean checkCompounds(
      CharsRef word, WordCase originalCase, int depth, Predicate<List<CharsRef>> checkPatterns) {
    if (depth > dictionary.compoundMax - 2) return false;

    int limit = word.length - dictionary.compoundMin + 1;
    for (int breakPos = dictionary.compoundMin; breakPos < limit; breakPos++) {
      WordContext context = depth == 0 ? COMPOUND_BEGIN : COMPOUND_MIDDLE;
      int breakOffset = word.offset + breakPos;
      if (mayBreakIntoCompounds(word.chars, word.offset, word.length, breakOffset)) {
        List<CharsRef> stems =
            stemmer.doStem(word.chars, word.offset, breakPos, originalCase, context);
        if (stems.isEmpty()
            && dictionary.simplifiedTriple
            && word.chars[breakOffset - 1] == word.chars[breakOffset]) {
          stems = stemmer.doStem(word.chars, word.offset, breakPos + 1, originalCase, context);
        }
        if (!stems.isEmpty() && checkPatterns.test(stems)) {
          Predicate<List<CharsRef>> nextCheck = checkNextPatterns(word, breakPos, stems);
          if (checkCompoundsAfter(word, breakPos, originalCase, depth, stems, nextCheck)) {
            return true;
          }
        }
      }

      if (checkCompoundPatternReplacements(word, breakPos, originalCase, depth)) {
        return true;
      }
    }

    return false;
  }

