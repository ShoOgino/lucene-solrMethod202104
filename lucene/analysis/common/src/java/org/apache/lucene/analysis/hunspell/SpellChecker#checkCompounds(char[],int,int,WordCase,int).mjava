  private boolean checkCompounds(
      char[] chars, int offset, int length, WordCase originalCase, int depth) {
    if (depth > dictionary.compoundMax - 2) return false;

    int limit = length - dictionary.compoundMin + 1;
    for (int breakPos = dictionary.compoundMin; breakPos < limit; breakPos++) {
      WordContext context = depth == 0 ? COMPOUND_BEGIN : COMPOUND_MIDDLE;
      int breakOffset = offset + breakPos;
      if (mayBreakIntoCompounds(chars, offset, length, breakOffset)) {
        List<CharsRef> stems = stemmer.doStem(chars, offset, breakPos, originalCase, context);
        if (stems.isEmpty()
            && dictionary.simplifiedTriple
            && chars[breakOffset - 1] == chars[breakOffset]) {
          stems = stemmer.doStem(chars, offset, breakPos + 1, originalCase, context);
        }
        if (stems.isEmpty()) continue;

        int remainingLength = length - breakPos;
        List<CharsRef> lastStems =
            stemmer.doStem(chars, breakOffset, remainingLength, originalCase, COMPOUND_END);
        if (!lastStems.isEmpty()
            && !(dictionary.checkCompoundDup && intersectIgnoreCase(stems, lastStems))
            && !hasForceUCaseProblem(chars, breakOffset, remainingLength, originalCase)) {
          return true;
        }

        if (checkCompounds(chars, breakOffset, remainingLength, originalCase, depth + 1)) {
          return true;
        }
      }
    }

    return false;
  }

