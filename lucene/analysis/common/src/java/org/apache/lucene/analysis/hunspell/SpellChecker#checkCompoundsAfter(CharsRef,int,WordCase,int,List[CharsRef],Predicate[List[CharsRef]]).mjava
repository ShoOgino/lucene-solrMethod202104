  private boolean checkCompoundsAfter(
      CharsRef word,
      int breakPos,
      WordCase originalCase,
      int depth,
      List<CharsRef> prevStems,
      Predicate<List<CharsRef>> checkPatterns) {
    int remainingLength = word.length - breakPos;
    int breakOffset = word.offset + breakPos;
    List<CharsRef> tailStems =
        stemmer.doStem(word.chars, breakOffset, remainingLength, originalCase, COMPOUND_END);
    if (!tailStems.isEmpty()
        && !(dictionary.checkCompoundDup && intersectIgnoreCase(prevStems, tailStems))
        && !hasForceUCaseProblem(word.chars, breakOffset, remainingLength, originalCase)
        && checkPatterns.test(tailStems)) {
      return true;
    }

    CharsRef tail = new CharsRef(word.chars, breakOffset, remainingLength);
    return checkCompounds(tail, originalCase, depth + 1, checkPatterns);
  }

