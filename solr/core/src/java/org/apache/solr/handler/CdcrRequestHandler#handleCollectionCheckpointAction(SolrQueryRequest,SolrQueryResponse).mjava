  /**
   * This action is generally executed on the target cluster in order to retrieve the latest update checkpoint.
   * This checkpoint is used on the source cluster to setup the
   * {@link org.apache.solr.update.CdcrUpdateLog.CdcrLogReader} of a shard leader. <br/>
   * This method will execute in parallel one
   * {@link org.apache.solr.handler.CdcrParams.CdcrAction#SHARDCHECKPOINT} request per shard leader. It will
   * then pick the lowest version number as checkpoint. Picking the lowest amongst all shards will ensure that we do not
   * pick a checkpoint that is ahead of the source cluster. This can occur when other shard leaders are sending new
   * updates to the target cluster while we are currently instantiating the
   * {@link org.apache.solr.update.CdcrUpdateLog.CdcrLogReader}.
   * This solution only works in scenarios where the topology of the source and target clusters are identical.
   */
  private void handleCollectionCheckpointAction(SolrQueryRequest req, SolrQueryResponse rsp)
      throws IOException, SolrServerException {
    ZkController zkController = core.getCoreContainer().getZkController();
    try {
      zkController.getZkStateReader().forceUpdateCollection(collection);
    } catch (Exception e) {
      log.warn("Error when updating cluster state", e);
    }
    ClusterState cstate = zkController.getClusterState();
    DocCollection docCollection = cstate.getCollectionOrNull(collection);
    Collection<Slice> shards = docCollection == null? null : docCollection.getActiveSlices();

    ExecutorService parallelExecutor = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory("parallelCdcrExecutor"));

    long checkpoint = Long.MAX_VALUE;
    try {
      List<Callable<Long>> callables = new ArrayList<>();
      for (Slice shard : shards) {
        ZkNodeProps leaderProps = zkController.getZkStateReader().getLeaderRetry(collection, shard.getName());
        ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(leaderProps);
        callables.add(new SliceCheckpointCallable(nodeProps.getCoreUrl(), path));
      }

      for (final Future<Long> future : parallelExecutor.invokeAll(callables)) {
        long version = future.get();
        if (version < checkpoint) { // we must take the lowest checkpoint from all the shards
          checkpoint = version;
        }
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
          "Error while requesting shard's checkpoints", e);
    } catch (ExecutionException e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
          "Error while requesting shard's checkpoints", e);
    } finally {
      parallelExecutor.shutdown();
    }

    rsp.add(CdcrParams.CHECKPOINT, checkpoint);
  }

