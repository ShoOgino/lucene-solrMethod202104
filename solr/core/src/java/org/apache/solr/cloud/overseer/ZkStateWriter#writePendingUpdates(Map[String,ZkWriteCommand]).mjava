  /**
   * Writes all pending updates to ZooKeeper and returns the modified cluster state
   *
   * @return the modified cluster state
   * @throws IllegalStateException if the current instance is no longer usable and must be discarded
   * @throws KeeperException       if any ZooKeeper operation results in an error
   * @throws InterruptedException  if the current thread is interrupted
   */
  public ClusterState writePendingUpdates(Map<String, ZkWriteCommand> updates) throws IllegalStateException, KeeperException, InterruptedException {
    if (invalidState) {
      throw new IllegalStateException("ZkStateWriter has seen a tragic error, this instance can no longer be used");
    }
    if ((updates == this.updates)
        && !hasPendingUpdates()) {
      return clusterState;
    }
    Timer.Context timerContext = stats.time("update_state");
    boolean success = false;
    try {
      if (!updates.isEmpty()) {
        for (Map.Entry<String, ZkWriteCommand> entry : updates.entrySet()) {
          String name = entry.getKey();
          String path = ZkStateReader.getCollectionPath(name);
          ZkWriteCommand cmd = entry.getValue();
          DocCollection c = cmd.collection;

          // Update the Per Replica State znodes if needed
          if (cmd.ops != null) {
            cmd.ops.persist(path, reader.getZkClient());
            clusterState = clusterState.copyWith(name,
                  cmd.collection.copyWith(PerReplicaStates.fetch(cmd.collection.getZNode(), reader.getZkClient(), null)));
          }

          // Update the state.json file if needed
          if (!cmd.persistJsonState) continue;
          if (c == null) {
            // let's clean up the state.json of this collection only, the rest should be cleaned by delete collection cmd
            log.debug("going to delete state.json {}", path);
            reader.getZkClient().clean(path);
          } else {
            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));
            if (reader.getZkClient().exists(path, true)) {
              if (log.isDebugEnabled()) {
                log.debug("going to update_collection {} version: {}", path, c.getZNodeVersion());
              }
              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);
              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion());
              clusterState = clusterState.copyWith(name, newCollection);
            } else {
              log.debug("going to create_collection {}", path);
              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);
              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0);
              clusterState = clusterState.copyWith(name, newCollection);
            }
          }

          // When dealing with a per replica collection that did not do any update to the per replica states znodes but did
          // update state.json, we add then remove a dummy node to change the cversion of the parent znode.
          // This is not needed by Solr, there's no code watching the children and not watching the state.json node itself.
          // It would be useful for external code watching the collection's Zookeeper state.json node children but not the node itself.
          if (cmd.ops == null && cmd.isPerReplicaStateCollection) {
            PerReplicaStatesOps.touchChildren().persist(path, reader.getZkClient());
            DocCollection currentCollState = clusterState.getCollection(cmd.name);
            if (currentCollState != null) {
              clusterState = clusterState.copyWith(name,
                      currentCollState.copyWith(PerReplicaStates.fetch(currentCollState.getZNode(), reader.getZkClient(), null)));
            }
          }
        }

        updates.clear();
        numUpdates = 0;
      }

      lastUpdatedTime = System.nanoTime();
      success = true;
    } catch (KeeperException.BadVersionException bve) {
      // this is a tragic error, we must disallow usage of this instance
      invalidState = true;
      throw bve;
    } finally {
      timerContext.stop();
      if (success) {
        stats.success("update_state");
      } else {
        stats.error("update_state");
      }
    }

    log.trace("New Cluster State is: {}", clusterState);
    return clusterState;
  }

