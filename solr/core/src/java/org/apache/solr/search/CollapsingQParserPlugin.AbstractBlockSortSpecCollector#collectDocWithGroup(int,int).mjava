    /**
     * This method should be called by subclasses for each doc + group encountered
     * @param contextDoc a valid doc id relative to the current reader context
     * @param docGroup some uique identifier for the group - the base class makes no assumptions about it's meaning
     * @see #collectDocWithNullGroup
     */
    protected void collectDocWithGroup(int contextDoc, int docGroup) throws IOException {
      assert 0 <= contextDoc;
      
      final boolean isBoosted = isBoostedAdvanceExact(contextDoc);
      
      if (-1 < currentGroupState.docID() && docGroup == currentGroupState.getCurrentGroup()) {
        // we have an existing group, and contextDoc is in that group.

        if (isBoosted) {
          // this doc is the best and should be immediately collected regardless of sort values
          setCurrentGroupBestMatch(contextDoc, isBoosted);
          delegateCollect();

        } else if (currentGroupState.hasBoostedDocs()) {
          // No-Op: nothing about this doc matters since we've already collected boosted docs in this group

          // No-Op
        } else {
          // check if it's the new 'best' doc in this group...
          if (sortsCompare.testAndSetGroupValues(contextDoc)) {
            setCurrentGroupBestMatch(contextDoc, isBoosted);
          }
        }
        
      } else {
        // We have a document that starts a new group (or may be the first doc+group we've collected this segmen)
        
        // first collect the prior group if needed...
        maybeDelegateCollect();
        
        // then setup the new group and current best match
        currentGroupState.resetForNewGroup();
        currentGroupState.setCurrentGroup(docGroup);
        sortsCompare.setGroupValues(contextDoc);
        setCurrentGroupBestMatch(contextDoc, isBoosted);

        if (isBoosted) { // collect immediately
          delegateCollect();
        }
      }
    }

