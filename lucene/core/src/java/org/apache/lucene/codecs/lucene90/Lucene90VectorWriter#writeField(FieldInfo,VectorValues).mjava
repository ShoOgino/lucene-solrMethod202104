  @Override
  public void writeField(FieldInfo fieldInfo, VectorValues vectors) throws IOException {
    long pos = vectorData.getFilePointer();
    // write floats aligned at 4 bytes. This will not survive CFS, but it shows a small benefit when
    // CFS is not used, eg for larger indexes
    long padding = (4 - (pos & 0x3)) & 0x3;
    long vectorDataOffset = pos + padding;
    for (int i = 0; i < padding; i++) {
      vectorData.writeByte((byte) 0);
    }
    // TODO - use a better data structure; a bitset? DocsWithFieldSet is p.p. in o.a.l.index
    int[] docIds = new int[vectors.size()];
    int count = 0;
    for (int docV = vectors.nextDoc(); docV != NO_MORE_DOCS; docV = vectors.nextDoc(), count++) {
      // write vector
      writeVectorValue(vectors);
      docIds[count] = docV;
    }
    // count may be < vectors.size() e,g, if some documents were deleted
    long[] offsets = new long[count];
    long vectorDataLength = vectorData.getFilePointer() - vectorDataOffset;
    long vectorIndexOffset = vectorIndex.getFilePointer();
    if (vectors.searchStrategy().isHnsw()) {
      if (vectors instanceof RandomAccessVectorValuesProducer) {
        writeGraph(
            vectorIndex,
            (RandomAccessVectorValuesProducer) vectors,
            vectorIndexOffset,
            offsets,
            count);
      } else {
        throw new IllegalArgumentException(
            "Indexing an HNSW graph requires a random access vector values, got " + vectors);
      }
    }
    long vectorIndexLength = vectorIndex.getFilePointer() - vectorIndexOffset;
    if (vectorDataLength > 0) {
      writeMeta(
          fieldInfo,
          vectorDataOffset,
          vectorDataLength,
          vectorIndexOffset,
          vectorIndexLength,
          count,
          docIds);
      if (vectors.searchStrategy().isHnsw()) {
        writeGraphOffsets(meta, offsets);
      }
    }
  }

