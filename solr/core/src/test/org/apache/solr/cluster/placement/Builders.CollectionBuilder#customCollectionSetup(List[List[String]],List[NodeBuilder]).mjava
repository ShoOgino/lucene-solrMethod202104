    /**
     * Initializes the collection to a specific shard and replica distribution passed in {@code shardsReplicas}.
     * @param shardsReplicas A list of shard descriptions, describing the replicas of that shard.
     *                       Replica description include the replica type and the node on which the replica should be placed.
     *                       Everything is text to make it easy to design specific collections. For example the following value:
     *  <pre>{@code
     *  List.of(
     *    List.of("NRT 0", "TLOG 0", "NRT 3"), // shard 1
     *    List.of("NRT 1", "NRT 3", "TLOG 2")); // shard 2
     *  }</pre>
     *                       Creates a placement that would distribute replicas to nodes (there must be at least 4 nodes)
     *                       in the following way:
     *  <pre>{@code
     *  +--------------+----+----+----+----+
     *  |         Node |  0 |  1 |  2 |  3 |
     *  +----------------------------------+
     *  |   Shard 1:   |    |    |    |    |
     *  |         NRT  |  X |    |    |  X |
     *  |         TLOG |  X |    |    |    |
     *  +----------------------------------+
     *  |   Shard 2:   |    |    |    |    |
     *  |         NRT  |    |  X |    |  X |
     *  |         TLOG |    |    |  X |    |
     *  +--------------+----+----+----+----+
     *  }</pre>
     */
    public CollectionBuilder customCollectionSetup(List<List<String>> shardsReplicas, List<NodeBuilder> liveNodes) {
      shardBuilders = new LinkedList<>();
      int shardNumber = 1; // Shard numbering starts at 1
      for (List<String> replicasOnNodes : shardsReplicas) {
        String shardName = buildShardName(shardNumber++);
        LinkedList<ReplicaBuilder> replicas = new LinkedList<>();
        ReplicaBuilder leader = null;

        for (String replicaNode : replicasOnNodes) {
          // replicaNode is like "TLOG 2" meaning a TLOG replica should be placed on node 2
          String[] splited = replicaNode.split("\\s+");
          Assert.assertEquals(2, splited.length);
          Replica.ReplicaType type = Replica.ReplicaType.valueOf(splited[0]);
          final NodeBuilder node;
          int nodeIndex = Integer.parseInt(splited[1]);
          if (nodeIndex < liveNodes.size()) {
            node = liveNodes.get(nodeIndex);
          } else {
            // The collection can have replicas on non live nodes. Let's create such a node here (that is not known to the
            // cluster). There could be many non live nodes in the collection configuration, they will all reference new
            // instances such as below of a node unknown to cluster, but all will have the same name (so will be equal if
            // tested).
            node = new NodeBuilder().setNodeName("NonLiveNode");
          }
          String replicaName = buildReplicaName(shardName, type);

          ReplicaBuilder replicaBuilder = new ReplicaBuilder();
          replicaBuilder.setReplicaName(replicaName).setCoreName(buildCoreName(replicaName)).setReplicaType(type)
              .setReplicaState(Replica.ReplicaState.ACTIVE).setReplicaNode(node);
          replicas.add(replicaBuilder);

          // No way to specify which replica is the leader. Could be done by adding a "*" to the replica definition for example
          // in the passed shardsReplicas but not implementing this until it is needed :)
          if (leader == null && type != Replica.ReplicaType.PULL) {
            leader = replicaBuilder;
          }
        }

        ShardBuilder shardBuilder = new ShardBuilder();
        shardBuilder.setShardName(shardName).setReplicaBuilders(replicas).setLeader(leader);
        shardBuilders.add(shardBuilder);
      }

      return this;
    }

