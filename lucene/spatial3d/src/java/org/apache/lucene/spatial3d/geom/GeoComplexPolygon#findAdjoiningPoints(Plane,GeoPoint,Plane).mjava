  /**
   * Given a point on the plane and the ellipsoid, this method looks for a pair of adjoining points
   * on either side of the plane, which are about MINIMUM_RESOLUTION away from the given point. This
   * only works for planes which go through the center of the world. Returns null if the planes are
   * effectively parallel and reasonable adjoining points cannot be determined.
   */
  private GeoPoint[] findAdjoiningPoints(
      final Plane plane, final GeoPoint pointOnPlane, final Plane envelopePlane) {
    // Compute a normalized perpendicular vector
    final Vector perpendicular = new Vector(plane, pointOnPlane);
    double distanceFactor = 0.0;
    for (int i = 0; i < MAX_ITERATIONS; i++) {
      distanceFactor += DELTA_DISTANCE;
      // Compute two new points along this vector from the original
      final GeoPoint pointA =
          planetModel.createSurfacePoint(
              pointOnPlane.x + perpendicular.x * distanceFactor,
              pointOnPlane.y + perpendicular.y * distanceFactor,
              pointOnPlane.z + perpendicular.z * distanceFactor);
      final GeoPoint pointB =
          planetModel.createSurfacePoint(
              pointOnPlane.x - perpendicular.x * distanceFactor,
              pointOnPlane.y - perpendicular.y * distanceFactor,
              pointOnPlane.z - perpendicular.z * distanceFactor);
      if (Math.abs(envelopePlane.evaluate(pointA)) > OFF_PLANE_AMOUNT
          && Math.abs(envelopePlane.evaluate(pointB)) > OFF_PLANE_AMOUNT) {
        // System.out.println("Distance: "
        // + computeSquaredDistance(rval[0], pointOnPlane)
        // + " and " + computeSquaredDistance(rval[1], pointOnPlane));
        return new GeoPoint[] {pointA, pointB};
      }
      // Loop back around and use a bigger delta
    }
    // Had to abort, so return null.
    // System.out.println("     Adjoining points not found.  Are planes parallel?"
    // + " edge = " + plane + " envelope = " + envelopePlane
    // + "; perpendicular = " + perpendicular);
    return null;
  }

