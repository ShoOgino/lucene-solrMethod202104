  public void softUpdatesConcurrently(boolean mixDeletes) throws IOException, InterruptedException {
    Directory dir = newDirectory();
    IndexWriterConfig indexWriterConfig = newIndexWriterConfig();
    indexWriterConfig.setSoftDeletesField("soft_delete");
    AtomicBoolean mergeAwaySoftDeletes = new AtomicBoolean(random().nextBoolean());
    if (mixDeletes == false) {
      indexWriterConfig.setMergePolicy(new OneMergeWrappingMergePolicy(indexWriterConfig.getMergePolicy(), towrap ->
          new MergePolicy.OneMerge(towrap.segments) {
            @Override
            public CodecReader wrapForMerge(CodecReader reader) throws IOException {
              if (mergeAwaySoftDeletes.get()) {
                return towrap.wrapForMerge(reader);
              } else {
                CodecReader wrapped = towrap.wrapForMerge(reader);
                return new FilterCodecReader(wrapped) {
                  @Override
                  public CacheHelper getCoreCacheHelper() {
                    return in.getCoreCacheHelper();
                  }

                  @Override
                  public CacheHelper getReaderCacheHelper() {
                    return in.getReaderCacheHelper();
                  }

                  @Override
                  public Bits getLiveDocs() {
                    return null; // everything is live
                  }

                  @Override
                  public int numDocs() {
                    return maxDoc();
                  }
                };
              }
            }
          }
      ) {
        @Override
        public int numDeletesToMerge(SegmentCommitInfo info, int delCount, IOSupplier<CodecReader> readerSupplier) throws IOException {
          if (mergeAwaySoftDeletes.get()) {
            return super.numDeletesToMerge(info, delCount, readerSupplier);
          } else {
            return 0;
          }
        }
      });
    }
    IndexWriter writer = new IndexWriter(dir, indexWriterConfig);
    Thread[] threads = new Thread[2 + random().nextInt(3)];
    CountDownLatch startLatch = new CountDownLatch(1);
    CountDownLatch started = new CountDownLatch(threads.length);
    boolean updateSeveralDocs = random().nextBoolean();
    Set<String> ids = Collections.synchronizedSet(new HashSet<>());
    for (int i = 0; i < threads.length; i++) {
      threads[i] = new Thread(() -> {
        try {
          started.countDown();
          startLatch.await();
          for (int d = 0;  d < 100; d++) {
            String id = String.valueOf(random().nextInt(10));
            if (updateSeveralDocs) {
              Document doc = new Document();
              doc.add(new StringField("id", id, Field.Store.YES));
              if (mixDeletes && random().nextBoolean()) {
                writer.updateDocuments(new Term("id", id), Arrays.asList(doc, doc));
              } else {
                writer.softUpdateDocuments(new Term("id", id), Arrays.asList(doc, doc),
                    new NumericDocValuesField("soft_delete", 1));
              }
            } else {
              Document doc = new Document();
              doc.add(new StringField("id", id, Field.Store.YES));
              if (mixDeletes && random().nextBoolean()) {
                writer.updateDocument(new Term("id", id), doc);
              } else {
                writer.softUpdateDocument(new Term("id", id), doc,
                    new NumericDocValuesField("soft_delete", 1));
              }
            }
            ids.add(id);
          }
        } catch (IOException | InterruptedException e) {
          throw new AssertionError(e);
        }
      });
      threads[i].start();
    }
    started.await();
    startLatch.countDown();

    for (int i = 0; i < threads.length; i++) {
      threads[i].join();
    }
    DirectoryReader reader = DirectoryReader.open(writer);
    IndexSearcher searcher = new IndexSearcher(reader);
    for (String id : ids) {
      TopDocs topDocs = searcher.search(new TermQuery(new Term("id", id)), 10);
      if (updateSeveralDocs) {
        assertEquals(2, topDocs.totalHits.value);
        assertEquals(Math.abs(topDocs.scoreDocs[0].doc - topDocs.scoreDocs[1].doc), 1);
      } else {
        assertEquals(1, topDocs.totalHits.value);
      }
    }
    if (mixDeletes == false) {
      for (LeafReaderContext context : reader.leaves()) {
        LeafReader leaf = context.reader();
        assertNull(((SegmentReader) leaf).getHardLiveDocs());
      }
    }
    mergeAwaySoftDeletes.set(true);
    writer.addDocument(new Document()); // add a dummy doc to trigger a segment here
    writer.flush();
    writer.forceMerge(1);
    DirectoryReader oldReader = reader;
    reader = DirectoryReader.openIfChanged(reader, writer);
    if (reader != null) {
      oldReader.close();
      assertNotSame(oldReader, reader);
    } else {
      reader = oldReader;
    }
    for (String id : ids) {
      if (updateSeveralDocs) {
        assertEquals(2, reader.docFreq(new Term("id", id)));
      } else {
        assertEquals(1, reader.docFreq(new Term("id", id)));
      }
    }
    int numSoftDeleted = 0;
    for (SegmentCommitInfo info : writer.cloneSegmentInfos()) {
      numSoftDeleted += info.getSoftDelCount() + info.getDelCount();
    }
    assertEquals(writer.maxDoc() - writer.numDocs(), numSoftDeleted);
    writer.commit();
    try (DirectoryReader dirReader = DirectoryReader.open(dir)) {
      int delCount = 0;
      for (LeafReaderContext ctx : dirReader.leaves()) {
        SegmentCommitInfo segmentInfo = ((SegmentReader) ctx.reader()).getSegmentInfo();
        delCount += segmentInfo.getSoftDelCount() + segmentInfo.getDelCount();
      }
      assertEquals(numSoftDeleted, delCount);
    }
    IOUtils.close(reader, writer, dir);
  }

