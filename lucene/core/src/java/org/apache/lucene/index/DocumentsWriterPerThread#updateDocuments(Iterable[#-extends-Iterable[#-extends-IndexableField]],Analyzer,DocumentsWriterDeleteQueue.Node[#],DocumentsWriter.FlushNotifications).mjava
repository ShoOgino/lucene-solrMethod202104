  public long updateDocuments(Iterable<? extends Iterable<? extends IndexableField>> docs, Analyzer analyzer, DocumentsWriterDeleteQueue.Node<?> deleteNode, DocumentsWriter.FlushNotifications flushNotifications) throws IOException {
    try {
      testPoint("DocumentsWriterPerThread addDocuments start");
      assert hasHitAbortingException() == false: "DWPT has hit aborting exception but is still indexing";
      assert deleteQueue != null;
      docState.analyzer = analyzer;
      if (INFO_VERBOSE && infoStream.isEnabled("DWPT")) {
        infoStream.message("DWPT", Thread.currentThread().getName() + " update delTerm=" + deleteNode + " docID=" + docState.docID + " seg=" + segmentInfo.name);
      }
      int docCount = 0;
      boolean allDocsIndexed = false;
      try {

        for (Iterable<? extends IndexableField> doc : docs) {
          // Even on exception, the document is still added (but marked
          // deleted), so we don't need to un-reserve at that point.
          // Aborting exceptions will actually "lose" more than one
          // document, so the counter will be "wrong" in that case, but
          // it's very hard to fix (we can't easily distinguish aborting
          // vs non-aborting exceptions):
          reserveOneDoc();
          docState.doc = doc;
          docState.docID = numDocsInRAM;
          docCount++;

          boolean success = false;
          try {
            consumer.processDocument();
            success = true;
          } finally {
            if (!success) {
              // Incr here because finishDocument will not
              // be called (because an exc is being thrown):
              numDocsInRAM++;
            }
          }

          numDocsInRAM++;
        }
        allDocsIndexed = true;
        return finishDocuments(deleteNode, docCount);
      } finally {
        if (!allDocsIndexed && !aborted) {
          // the iterator threw an exception that is not aborting
          // go and mark all docs from this block as deleted
          int docID = numDocsInRAM - 1;
          final int endDocID = docID - docCount;
          while (docID > endDocID) {
            deleteDocID(docID);
            docID--;
          }
        }
        docState.clear();
      }
    } finally {
      maybeAbort("updateDocuments", flushNotifications);
    }
  }

