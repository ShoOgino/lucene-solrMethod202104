    public GroupExpandCollector(int limit, Sort sort, Query query, boolean expandNulls,
                                FieldType fieldType, IntObjectHashMap<BytesRef> ordBytes,
                                SortedDocValues docValues, FixedBitSet groupBits, IntHashSet collapsedSet) throws IOException {
      super(limit, sort, query, expandNulls, fieldType, ordBytes);

      // groupBits.cardinality() is more expensive then collapsedSet.size() which is adequate for an upper bound
      this.groups = new LongObjectHashMap<>(collapsedSet.size());
      DocIdSetIterator iterator = new BitSetIterator(groupBits, 0); // cost is not useful here
      int group;
      while ((group = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
        groups.put(group, getCollector());
      }

      this.collapsedSet = collapsedSet;
      this.groupBits = groupBits;
      this.docValues = docValues;
      if(docValues instanceof MultiDocValues.MultiSortedDocValues) {
        this.multiSortedDocValues = (MultiDocValues.MultiSortedDocValues)docValues;
        this.ordinalMap = multiSortedDocValues.mapping;
      } else {
        this.multiSortedDocValues = null;
        this.ordinalMap = null;
      }
    }

