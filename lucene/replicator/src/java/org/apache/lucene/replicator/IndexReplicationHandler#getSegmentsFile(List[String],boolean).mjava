  /**
   * Verifies that the last file is segments_N and fails otherwise. It also
   * removes and returns the file from the list, because it needs to be handled
   * last, after all files. This is important in order to guarantee that if a
   * reader sees the new segments_N, all other segment files are already on
   * stable storage.
   * <p>
   * The reason why the code fails instead of putting segments_N file last is
   * that this indicates an error in the Revision implementation.
   */
  public static String getSegmentsFile(List<String> files, boolean allowEmpty) {
    if (files.isEmpty()) {
      if (allowEmpty) {
        return null;
      } else {
        throw new IllegalStateException("empty list of files not allowed");
      }
    }
    
    String segmentsFile = files.remove(files.size() - 1);
    if (!segmentsFile.startsWith(IndexFileNames.SEGMENTS)) {
      throw new IllegalStateException("last file to copy+sync must be segments_N but got " + segmentsFile
          + "; check your Revision implementation!");
    }
    return segmentsFile;
  }

