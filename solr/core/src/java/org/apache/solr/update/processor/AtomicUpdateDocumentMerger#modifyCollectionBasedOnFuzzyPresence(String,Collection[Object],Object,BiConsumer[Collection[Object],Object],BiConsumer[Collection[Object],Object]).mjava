  /**
   * Modifies a collection based on the (loosely-judged) presence or absence of a specific value
   *
   * Several classes of atomic update (notably 'remove' and 'add-distinct') rely on being able to identify whether an
   * item is already present in a given list of values.  Unfortunately the 'item' being checked for may be of different
   * types based on the format of the user request and on where the existing document was pulled from (tlog vs index).
   * As a result atomic updates needs a "fuzzy" way of checking presence and equality that is more flexible than
   * traditional equality checks allow.  This method does light type-checking to catch some of these more common cases
   * (Long compared against Integers, String compared against Date, etc.), and calls the provided lambda to modify the
   * field values as necessary.
   *
   * @param fieldName the field name involved in this atomic update operation
   * @param original the list of values currently present in the existing document
   * @param rawValue a value to be checked for in 'original'
   * @param ifPresent a function to execute if rawValue was found in 'original'
   * @param ifAbsent a function to execute if rawValue was not found in 'original'
   */
  private void modifyCollectionBasedOnFuzzyPresence(String fieldName, Collection<Object> original, Object rawValue,
                                                    BiConsumer<Collection<Object>, Object> ifPresent,
                                                    BiConsumer<Collection<Object>, Object> ifAbsent) {
    Object nativeValue = getNativeFieldValue(fieldName, rawValue);
    Optional<Object> matchingValue = findObjectWithTypeFuzziness(original, rawValue, nativeValue);
    if (matchingValue.isPresent() && ifPresent != null) {
      ifPresent.accept(original, matchingValue.get());
    } else if(matchingValue.isEmpty() && ifAbsent != null) {
      ifAbsent.accept(original, rawValue);
    }
  }

