  static void compile(Path srcDir, Path destDir) throws Exception {
    List<Path> files;
    try (var stream = Files.list(srcDir)) {
      files =
          stream
              .filter(name -> name.getFileName().toString().endsWith("rbbi"))
              .collect(Collectors.toList());
    }

    if (files.isEmpty()) throw new IOException("No input files matching *.rbbi at: " + srcDir);
    for (Path file : files) {
      Path outputFile = destDir.resolve(file.getFileName().toString().replaceAll("rbbi$", "brk"));
      String rules = getRules(file);
      System.err.print(
          "Compiling " + file.getFileName() + " to " + outputFile.getFileName() + ": ");
      /*
       * if there is a syntax error, compileRules() may succeed. the way to
       * check is to try to instantiate from the string. additionally if the
       * rules are invalid, you can get a useful syntax error.
       */
      try {
        new RuleBasedBreakIterator(rules);
      } catch (IllegalArgumentException e) {
        /*
         * do this intentionally, so you don't get a massive stack trace
         * instead, get a useful syntax error!
         */
        System.err.println(e.getMessage());
        System.exit(1);
      }
      try (OutputStream os = Files.newOutputStream(outputFile)) {
        RuleBasedBreakIterator.compileRules(rules, os);
      }
      System.err.println(Files.size(outputFile) + " bytes.");
    }
  }

