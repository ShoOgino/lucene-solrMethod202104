  private long applyDocValuesUpdates(BufferedUpdatesStream.SegmentState[] segStates)
      throws IOException {

    if (fieldUpdates.isEmpty()) {
      return 0;
    }

    long startNS = System.nanoTime();

    long updateCount = 0;

    for (BufferedUpdatesStream.SegmentState segState : segStates) {

      if (delGen < segState.delGen) {
        // segment is newer than this deletes packet
        continue;
      }

      if (segState.rld.refCount() == 1) {
        // This means we are the only remaining reference to this segment, meaning
        // it was merged away while we were running, so we can safely skip running
        // because we will run on the newly merged segment next:
        continue;
      }
      final boolean isSegmentPrivateDeletes = privateSegment != null;
      if (fieldUpdates.isEmpty() == false) {
        updateCount +=
            applyDocValuesUpdates(segState, fieldUpdates, delGen, isSegmentPrivateDeletes);
      }
    }

    if (infoStream.isEnabled("BD")) {
      infoStream.message(
          "BD",
          String.format(
              Locale.ROOT,
              "applyDocValuesUpdates %.1f msec for %d segments, %d field updates; %d new updates",
              (System.nanoTime() - startNS) / 1000000.,
              segStates.length,
              fieldUpdatesCount,
              updateCount));
    }

    return updateCount;
  }

