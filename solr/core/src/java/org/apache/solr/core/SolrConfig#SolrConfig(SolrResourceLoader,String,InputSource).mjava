   /** Creates a configuration instance from a resource loader, a configuration name and a stream.
   * If the stream is null, the resource loader will open the configuration stream.
   * If the stream is not null, no attempt to load the resource will occur (the name is not used).
   *@param loader the resource loader
   *@param name the configuration name
   *@param is the configuration stream
   */
  public SolrConfig(SolrResourceLoader loader, String name, InputSource is)
  throws ParserConfigurationException, IOException, SAXException {
    super(loader, name, is, "/config/");
    initLibs();
    luceneMatchVersion = getLuceneVersion("luceneMatchVersion");
    String indexConfigPrefix;

    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.
    // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>
    boolean hasDeprecatedIndexConfig = (getNode("indexDefaults", false) != null) || (getNode("mainIndex", false) != null);
    boolean hasNewIndexConfig = getNode("indexConfig", false) != null;
    if(hasDeprecatedIndexConfig){
      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {
        throw new SolrException(ErrorCode.FORBIDDEN, "<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.");
      } else {
        // Still allow the old sections for older LuceneMatchVersion's
        if(hasNewIndexConfig) {
          throw new SolrException(ErrorCode.FORBIDDEN, "Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.");
        }
        log.warn("<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.");
        defaultIndexConfig = new SolrIndexConfig(this, "indexDefaults", null);
        mainIndexConfig = new SolrIndexConfig(this, "mainIndex", defaultIndexConfig);
        indexConfigPrefix = "mainIndex";
      }
    } else {
      defaultIndexConfig = mainIndexConfig = null;
      indexConfigPrefix = "indexConfig";
    }
    nrtMode = getBool(indexConfigPrefix+"/nrtMode", true);
    // Parse indexConfig section, using mainIndex as backup in case old config is used
    indexConfig = new SolrIndexConfig(this, "indexConfig", mainIndexConfig);

    booleanQueryMaxClauseCount = getInt("query/maxBooleanClauses", BooleanQuery.getMaxClauseCount());
    log.info("Using Lucene MatchVersion: " + luceneMatchVersion);

    // Warn about deprecated / discontinued parameters
    // boolToFilterOptimizer has had no effect since 3.1
    if(get("query/boolTofilterOptimizer", null) != null)
      log.warn("solrconfig.xml: <boolTofilterOptimizer> is currently not implemented and has no effect.");
    if(get("query/HashDocSet", null) != null)
      log.warn("solrconfig.xml: <HashDocSet> is deprecated and no longer recommended used.");

// TODO: Old code - in case somebody wants to re-enable. Also see SolrIndexSearcher#search()
//    filtOptEnabled = getBool("query/boolTofilterOptimizer/@enabled", false);
//    filtOptCacheSize = getInt("query/boolTofilterOptimizer/@cacheSize",32);
//    filtOptThreshold = getFloat("query/boolTofilterOptimizer/@threshold",.05f);

    useFilterForSortedQuery = getBool("query/useFilterForSortedQuery", false);
    queryResultWindowSize = Math.max(1, getInt("query/queryResultWindowSize", 1));
    queryResultMaxDocsCached = getInt("query/queryResultMaxDocsCached", Integer.MAX_VALUE);
    enableLazyFieldLoading = getBool("query/enableLazyFieldLoading", false);


    filterCacheConfig = CacheConfig.getConfig(this, "query/filterCache");
    queryResultCacheConfig = CacheConfig.getConfig(this, "query/queryResultCache");
    documentCacheConfig = CacheConfig.getConfig(this, "query/documentCache");
    CacheConfig conf = CacheConfig.getConfig(this, "query/fieldValueCache");
    if (conf == null) {
      Map<String,String> args = new HashMap<>();
      args.put("name","fieldValueCache");
      args.put("size","10000");
      args.put("initialSize","10");
      args.put("showItems","-1");
      conf = new CacheConfig(FastLRUCache.class, args, null);
    }
    fieldValueCacheConfig = conf;
    unlockOnStartup = getBool(indexConfigPrefix+"/unlockOnStartup", false);
    useColdSearcher = getBool("query/useColdSearcher",false);
    dataDir = get("dataDir", null);
    if (dataDir != null && dataDir.length()==0) dataDir=null;

    userCacheConfigs = CacheConfig.getMultipleConfigs(this, "query/cache");

    org.apache.solr.search.SolrIndexSearcher.initRegenerators(this);

    hashSetInverseLoadFactor = 1.0f / getFloat("//HashDocSet/@loadFactor",0.75f);
    hashDocSetMaxSize= getInt("//HashDocSet/@maxSize",3000);

    httpCachingConfig = new HttpCachingConfig(this);

    Node jmx = getNode("jmx", false);
    if (jmx != null) {
      jmxConfig = new JmxConfiguration(true,
                                       get("jmx/@agentId", null),
                                       get("jmx/@serviceUrl", null),
                                       get("jmx/@rootName", null));

    } else {
      jmxConfig = new JmxConfiguration(false, null, null, null);
    }
     maxWarmingSearchers = getInt("query/maxWarmingSearchers",Integer.MAX_VALUE);

     loadPluginInfo(SolrRequestHandler.class,"requestHandler",
                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);
     loadPluginInfo(QParserPlugin.class,"queryParser",
                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);
     loadPluginInfo(QueryResponseWriter.class,"queryResponseWriter",
                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);
     loadPluginInfo(ValueSourceParser.class,"valueSourceParser",
                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);
     loadPluginInfo(TransformerFactory.class,"transformer",
                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);
     loadPluginInfo(SearchComponent.class,"searchComponent",
                    REQUIRE_NAME, REQUIRE_CLASS, MULTI_OK);

     // TODO: WTF is up with queryConverter???
     // it aparently *only* works as a singleton? - SOLR-4304
     // and even then -- only if there is a single SpellCheckComponent
     // because of queryConverter.setIndexAnalyzer
     loadPluginInfo(QueryConverter.class,"queryConverter",
                    REQUIRE_NAME, REQUIRE_CLASS);

     // this is hackish, since it picks up all SolrEventListeners,
     // regardless of when/how/why they are used (or even if they are
     // declared outside of the appropriate context) but there's no nice
     // way around that in the PluginInfo framework
     loadPluginInfo(SolrEventListener.class, "//listener",
                    REQUIRE_CLASS, MULTI_OK);

     loadPluginInfo(DirectoryFactory.class,"directoryFactory",
                    REQUIRE_CLASS);
     loadPluginInfo(IndexDeletionPolicy.class,indexConfigPrefix+"/deletionPolicy",
                    REQUIRE_CLASS);
     loadPluginInfo(CodecFactory.class,"codecFactory",
                    REQUIRE_CLASS);
     loadPluginInfo(IndexReaderFactory.class,"indexReaderFactory",
                    REQUIRE_CLASS);
     loadPluginInfo(UpdateRequestProcessorChain.class,"updateRequestProcessorChain",
                    MULTI_OK);
     loadPluginInfo(UpdateLog.class,"updateHandler/updateLog");
     loadPluginInfo(IndexSchemaFactory.class,"schemaFactory",
                    REQUIRE_CLASS);
     loadPluginInfo(RestManager.class, "restManager");
     updateHandlerInfo = loadUpdatehandlerInfo();
     
     multipartUploadLimitKB = getInt( 
         "requestDispatcher/requestParsers/@multipartUploadLimitInKB", 2048 );
     
     formUploadLimitKB = getInt( 
         "requestDispatcher/requestParsers/@formdataUploadLimitInKB", 2048 );
     
     enableRemoteStreams = getBool( 
         "requestDispatcher/requestParsers/@enableRemoteStreaming", false ); 
 
     // Let this filter take care of /select?xxx format
     handleSelect = getBool( 
         "requestDispatcher/@handleSelect", true ); 
     
     addHttpRequestToContext = getBool( 
         "requestDispatcher/requestParsers/@addHttpRequestToContext", false );

    loadPluginInfo(ParamSet.class,ParamSet.TYPE);
    List<PluginInfo> paramSetInfos =  pluginStore.get(ParamSet.class.getName()) ;
    if(paramSetInfos!=null){
      Map<String,ParamSet> paramSets = new HashMap<>();
      for (PluginInfo p : paramSetInfos) {
        ParamSet paramSet = new ParamSet(p);
        paramSets.put(paramSet.name == null ? String.valueOf(paramSet.hashCode()) : paramSet.name , paramSet );
      }
      this.paramSets = Collections.unmodifiableMap(paramSets);

    }

    solrRequestParsers = new SolrRequestParsers(this);
    Config.log.info("Loaded SolrConfig: " + name);
  }

