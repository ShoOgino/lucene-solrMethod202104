  @Override
  public SegmentInfo read(Directory directory, String segmentName, byte[] segmentID, IOContext context) throws IOException {
    BytesRefBuilder scratch = new BytesRefBuilder();
    String segFileName = IndexFileNames.segmentFileName(segmentName, "", SimpleTextSegmentInfoFormat.SI_EXTENSION);
    try (ChecksumIndexInput input = directory.openChecksumInput(segFileName, context)) {
      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_VERSION);
      final Version version;
      try {
        version = Version.parse(readString(SI_VERSION.length, scratch));
      } catch (ParseException pe) {
        throw new CorruptIndexException("unable to parse version string: " + pe.getMessage(), input, pe);
      }

      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_MIN_VERSION);
      Version minVersion;
      try {
        String versionString = readString(SI_MIN_VERSION.length, scratch);
        if (versionString.equals("null")) {
          minVersion = null;
        } else {
          minVersion = Version.parse(versionString);
        }
      } catch (ParseException pe) {
        throw new CorruptIndexException("unable to parse version string: " + pe.getMessage(), input, pe);
      }

      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_DOCCOUNT);
      final int docCount = Integer.parseInt(readString(SI_DOCCOUNT.length, scratch));
    
      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_USECOMPOUND);
      final boolean isCompoundFile = Boolean.parseBoolean(readString(SI_USECOMPOUND.length, scratch));
    
      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_NUM_DIAG);
      int numDiag = Integer.parseInt(readString(SI_NUM_DIAG.length, scratch));
      Map<String,String> diagnostics = new HashMap<>();

      for (int i = 0; i < numDiag; i++) {
        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_DIAG_KEY);
        String key = readString(SI_DIAG_KEY.length, scratch);
      
        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_DIAG_VALUE);
        String value = readString(SI_DIAG_VALUE.length, scratch);
        diagnostics.put(key, value);
      }
      
      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_NUM_ATT);
      int numAtt = Integer.parseInt(readString(SI_NUM_ATT.length, scratch));
      Map<String,String> attributes = new HashMap<>(numAtt);

      for (int i = 0; i < numAtt; i++) {
        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_ATT_KEY);
        String key = readString(SI_ATT_KEY.length, scratch);
      
        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_ATT_VALUE);
        String value = readString(SI_ATT_VALUE.length, scratch);
        attributes.put(key, value);
      }
      
      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_NUM_FILES);
      int numFiles = Integer.parseInt(readString(SI_NUM_FILES.length, scratch));
      Set<String> files = new HashSet<>();

      for (int i = 0; i < numFiles; i++) {
        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_FILE);
        String fileName = readString(SI_FILE.length, scratch);
        files.add(fileName);
      }
      
      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_ID);
      final byte[] id = ArrayUtil.copyOfSubArray(scratch.bytes(), SI_ID.length, scratch.length());
      
      if (!Arrays.equals(segmentID, id)) {
        throw new CorruptIndexException("file mismatch, expected: " + StringHelper.idToString(segmentID)
                                                        + ", got: " + StringHelper.idToString(id), input);
      }

      SimpleTextUtil.readLine(input, scratch);
      assert StringHelper.startsWith(scratch.get(), SI_SORT);
      final int numSortFields = Integer.parseInt(readString(SI_SORT.length, scratch));
      SortField[] sortField = new SortField[numSortFields];
      for (int i = 0; i < numSortFields; ++i) {
        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_SORT_FIELD);
        final String field = readString(SI_SORT_FIELD.length, scratch);

        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_SORT_TYPE);
        final String typeAsString = readString(SI_SORT_TYPE.length, scratch);

        final SortField.Type type;
        SortedSetSelector.Type selectorSet = null;
        SortedNumericSelector.Type selectorNumeric = null;
        switch (typeAsString) {
          case "string":
            type = SortField.Type.STRING;
            break;
          case "long":
            type = SortField.Type.LONG;
            break;
          case "int":
            type = SortField.Type.INT;
            break;
          case "double":
            type = SortField.Type.DOUBLE;
            break;
          case "float":
            type = SortField.Type.FLOAT;
            break;
          case "multi_valued_string":
            type = SortField.Type.STRING;
            selectorSet = readSetSelector(input, scratch);
            break;
          case "multi_valued_long":
            type = SortField.Type.LONG;
            selectorNumeric = readNumericSelector(input, scratch);
            break;
          case "multi_valued_int":
            type = SortField.Type.INT;
            selectorNumeric = readNumericSelector(input, scratch);
            break;
          case "multi_valued_double":
            type = SortField.Type.DOUBLE;
            selectorNumeric = readNumericSelector(input, scratch);
            break;
          case "multi_valued_float":
            type = SortField.Type.FLOAT;
            selectorNumeric = readNumericSelector(input, scratch);
            break;
          default:
            throw new CorruptIndexException("unable to parse sort type string: " + typeAsString, input);
        }

        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_SORT_REVERSE);
        final boolean reverse = Boolean.parseBoolean(readString(SI_SORT_REVERSE.length, scratch));

        SimpleTextUtil.readLine(input, scratch);
        assert StringHelper.startsWith(scratch.get(), SI_SORT_MISSING);
        final String missingLastAsString = readString(SI_SORT_MISSING.length, scratch);
        final Object missingValue;
        switch (type) {
          case STRING:
            switch (missingLastAsString) {
              case "null":
                missingValue = null;
                break;
              case "first":
                missingValue = SortField.STRING_FIRST;
                break;
              case "last":
                missingValue = SortField.STRING_LAST;
                break;
              default:
                throw new CorruptIndexException("unable to parse missing string: " + typeAsString, input);
            }
            break;
          case LONG:
            switch (missingLastAsString) {
              case "null":
                missingValue = null;
                break;
              default:
                missingValue = Long.parseLong(missingLastAsString);
                break;
            }
            break;
          case INT:
            switch (missingLastAsString) {
              case "null":
                missingValue = null;
                break;
              default:
                missingValue = Integer.parseInt(missingLastAsString);
                break;
            }
            break;
          case DOUBLE:
            switch (missingLastAsString) {
              case "null":
                missingValue = null;
                break;
              default:
                missingValue = Double.parseDouble(missingLastAsString);
                break;
            }
            break;
          case FLOAT:
            switch (missingLastAsString) {
              case "null":
                missingValue = null;
                break;
              default:
                missingValue = Float.parseFloat(missingLastAsString);
                break;
            }
            break;
          default:
            throw new AssertionError();
        }
        if (selectorSet != null) {
          sortField[i] = new SortedSetSortField(field, reverse);
        } else if (selectorNumeric != null) {
          sortField[i] = new SortedNumericSortField(field, type, reverse);
        } else {
          sortField[i] = new SortField(field, type, reverse);
        }
        if (missingValue != null) {
          sortField[i].setMissingValue(missingValue);
        }
      }
      Sort indexSort = sortField.length == 0 ? null : new Sort(sortField);

      SimpleTextUtil.checkFooter(input);

      SegmentInfo info = new SegmentInfo(directory, version, minVersion, segmentName, docCount,
                                         isCompoundFile, null, diagnostics, id, attributes, indexSort);
      info.setFiles(files);
      return info;
    }
  }

