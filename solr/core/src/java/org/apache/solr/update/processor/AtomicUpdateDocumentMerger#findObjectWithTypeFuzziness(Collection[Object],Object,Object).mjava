  private Optional<Object> findObjectWithTypeFuzziness(Collection<Object> original, Object rawValue, Object nativeValue) {
    if (nativeValue instanceof Double || nativeValue instanceof Float) {
      final Number nativeAsNumber = (Number) nativeValue;
      return original.stream().filter(val ->
              val.equals(rawValue) ||
                      val.equals(nativeValue) ||
                      (val instanceof Number && ((Number) val).doubleValue() == nativeAsNumber.doubleValue()) ||
                      (val instanceof String && val.equals(nativeAsNumber.toString())))
              .findFirst();
    } else if (nativeValue instanceof Long || nativeValue instanceof Integer) {
      final Number nativeAsNumber = (Number) nativeValue;
      return original.stream().filter(val ->
              val.equals(rawValue) ||
                      val.equals(nativeValue) ||
                      (val instanceof Number && ((Number) val).longValue() == nativeAsNumber.longValue()) ||
                      (val instanceof String && val.equals(nativeAsNumber.toString())))
              .findFirst();
    } else if (nativeValue instanceof Date) {
      return original.stream().filter(val ->
              val.equals(rawValue) ||
                      val.equals(nativeValue) ||
                      (val instanceof String && DateMathParser.parseMath(null, (String)val).equals(nativeValue)))
              .findFirst();
    } else if (original.contains(nativeValue)) {
      return Optional.of(nativeValue);
    } else if (original.contains(rawValue)) {
      return Optional.of(rawValue);
    } else {
      return Optional.empty();
    }
  }

