  /** Resolves the buffered deleted Term/Query/docIDs, into
   *  actual deleted docIDs in the liveDocs MutableBits for
   *  each SegmentReader. */
  public synchronized ApplyDeletesResult applyDeletesAndUpdates(IndexWriter.ReaderPool pool, List<SegmentCommitInfo> infos) throws IOException {
    final long t0 = System.currentTimeMillis();

    final long gen = nextGen++;

    if (infos.size() == 0) {
      return new ApplyDeletesResult(false, gen, null);
    }

    // We only init these on demand, when we find our first deletes that need to be applied:
    SegmentState[] segStates = null;

    long totDelCount = 0;
    long totTermVisitedCount = 0;

    boolean success = false;

    ApplyDeletesResult result = null;

    try {
      if (infoStream.isEnabled("BD")) {
        infoStream.message("BD", String.format(Locale.ROOT, "applyDeletes: open segment readers took %d msec", System.currentTimeMillis()-t0));
      }

      assert checkDeleteStats();

      if (!any()) {
        if (infoStream.isEnabled("BD")) {
          infoStream.message("BD", "applyDeletes: no segments; skipping");
        }
        return new ApplyDeletesResult(false, gen, null);
      }

      if (infoStream.isEnabled("BD")) {
        infoStream.message("BD", "applyDeletes: infos=" + infos + " packetCount=" + updates.size());
      }

      infos = sortByDelGen(infos);

      CoalescedUpdates coalescedUpdates = null;
      int infosIDX = infos.size()-1;
      int delIDX = updates.size()-1;

      // Backwards merge sort the segment delGens with the packet delGens in the buffered stream:
      while (infosIDX >= 0) {
        final FrozenBufferedUpdates packet = delIDX >= 0 ? updates.get(delIDX) : null;
        final SegmentCommitInfo info = infos.get(infosIDX);
        final long segGen = info.getBufferedDeletesGen();

        if (packet != null && segGen < packet.delGen()) {
          if (!packet.isSegmentPrivate && packet.any()) {
            /*
             * Only coalesce if we are NOT on a segment private del packet: the segment private del packet
             * must only apply to segments with the same delGen.  Yet, if a segment is already deleted
             * from the SI since it had no more documents remaining after some del packets younger than
             * its segPrivate packet (higher delGen) have been applied, the segPrivate packet has not been
             * removed.
             */
            if (coalescedUpdates == null) {
              coalescedUpdates = new CoalescedUpdates();
            }
            coalescedUpdates.update(packet);
          }

          delIDX--;
        } else if (packet != null && segGen == packet.delGen()) {
          assert packet.isSegmentPrivate : "Packet and Segments deletegen can only match on a segment private del packet gen=" + segGen;

          if (segStates == null) {
            segStates = openSegmentStates(pool, infos);
          }

          SegmentState segState = segStates[infosIDX];

          // Lock order: IW -> BD -> RP
          assert pool.infoIsLive(info);
          int delCount = 0;
          final DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();
          if (coalescedUpdates != null) {
            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);
            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);
            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);
          }
          delCount += applyQueryDeletes(packet.queriesIterable(), segState);
          applyDocValuesUpdates(Arrays.asList(packet.numericDVUpdates), segState, dvUpdates);
          applyDocValuesUpdates(Arrays.asList(packet.binaryDVUpdates), segState, dvUpdates);
          if (dvUpdates.any()) {
            segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);
          }

          totDelCount += delCount;

          /*
           * Since we are on a segment private del packet we must not
           * update the coalescedUpdates here! We can simply advance to the 
           * next packet and seginfo.
           */
          delIDX--;
          infosIDX--;

        } else {
          if (coalescedUpdates != null) {
            if (segStates == null) {
              segStates = openSegmentStates(pool, infos);
            }
            SegmentState segState = segStates[infosIDX];
            // Lock order: IW -> BD -> RP
            assert pool.infoIsLive(info);
            int delCount = 0;
            delCount += applyQueryDeletes(coalescedUpdates.queriesIterable(), segState);
            DocValuesFieldUpdates.Container dvUpdates = new DocValuesFieldUpdates.Container();
            applyDocValuesUpdates(coalescedUpdates.numericDVUpdates, segState, dvUpdates);
            applyDocValuesUpdates(coalescedUpdates.binaryDVUpdates, segState, dvUpdates);
            if (dvUpdates.any()) {
              segState.rld.writeFieldUpdates(info.info.dir, dvUpdates);
            }

            totDelCount += delCount;
          }

          infosIDX--;
        }
      }

      // Now apply all term deletes:
      if (coalescedUpdates != null && coalescedUpdates.totalTermCount != 0) {
        if (segStates == null) {
          segStates = openSegmentStates(pool, infos);
        }
        totTermVisitedCount += applyTermDeletes(coalescedUpdates, segStates);
      }

      assert checkDeleteStats();

      success = true;

    } finally {
      if (segStates != null) {
        result = closeSegmentStates(pool, segStates, success, gen);
      }
    }

    if (result == null) {
      result = new ApplyDeletesResult(false, gen, null);      
    }

    if (infoStream.isEnabled("BD")) {
      infoStream.message("BD",
                         String.format(Locale.ROOT,
                                       "applyDeletes took %d msec for %d segments, %d newly deleted docs (query deletes), %d visited terms, allDeleted=%s",
                                       System.currentTimeMillis()-t0, infos.size(), totDelCount, totTermVisitedCount, result.allDeleted));
    }

    return result;
  }

