  private LongValues getNumericValues(NumericEntry entry) throws IOException {
    if (entry.bitsPerValue == 0) {
      return new LongValues() {
        @Override
        public long get(long index) {
          return entry.minValue;
        }
      };
    } else {
      final RandomAccessInput slice =
          data.randomAccessSlice(entry.valuesOffset, entry.valuesLength);
      if (entry.blockShift >= 0) {
        final int shift = entry.blockShift;
        final long mul = entry.gcd;
        final long mask = (1L << shift) - 1;
        return new LongValues() {
          long block = -1;
          long delta;
          long offset;
          long blockEndOffset;
          LongValues values;

          public long get(long index) {
            final long block = index >>> shift;
            if (this.block != block) {
              assert block > this.block
                  : "Reading backwards is illegal: " + this.block + " < " + block;
              int bitsPerValue;
              do {
                offset = blockEndOffset;
                try {
                  bitsPerValue = slice.readByte(offset++);
                  delta = slice.readLong(offset);
                  offset += Long.BYTES;
                  if (bitsPerValue == 0) {
                    blockEndOffset = offset;
                  } else {
                    final int length = slice.readInt(offset);
                    offset += Integer.BYTES;
                    blockEndOffset = offset + length;
                  }
                } catch (IOException e) {
                  throw new RuntimeException(e);
                }
                this.block++;
              } while (this.block != block);
              values =
                  bitsPerValue == 0
                      ? LongValues.ZEROES
                      : DirectReader.getInstance(slice, bitsPerValue, offset);
            }
            return mul * values.get(index & mask) + delta;
          }
        };
      } else {
        final LongValues values = DirectReader.getInstance(slice, entry.bitsPerValue);
        if (entry.table != null) {
          final long[] table = entry.table;
          return new LongValues() {
            @Override
            public long get(long index) {
              return table[(int) values.get(index)];
            }
          };
        } else if (entry.gcd != 1) {
          final long gcd = entry.gcd;
          final long minValue = entry.minValue;
          return new LongValues() {
            @Override
            public long get(long index) {
              return values.get(index) * gcd + minValue;
            }
          };
        } else if (entry.minValue != 0) {
          final long minValue = entry.minValue;
          return new LongValues() {
            @Override
            public long get(long index) {
              return values.get(index) + minValue;
            }
          };
        } else {
          return values;
        }
      }
    }
  }

