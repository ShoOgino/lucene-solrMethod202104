    /**
     * Initializes shard and replica builders for the collection based on passed parameters. Replicas are assigned round
     * robin to the nodes. The shard leader is the first NRT replica of each shard (or first TLOG is no NRT).
     * Shard and replica configuration can be modified afterwards, the returned builder hierarchy is a convenient starting point.
     * @param countShards number of shards to create
     * @param countNrtReplicas number of NRT replicas per shard
     * @param countTlogReplicas number of TLOG replicas per shard
     * @param countPullReplicas number of PULL replicas per shard
     * @param nodes list of nodes to place replicas on.
     * @param initialSizeGBPerShard initial replica size (in GB) per shard
     */
    public CollectionBuilder initializeShardsReplicas(int countShards, int countNrtReplicas, int countTlogReplicas,
                                               int countPullReplicas, List<NodeBuilder> nodes,
                                                      List<Integer> initialSizeGBPerShard) {
      Iterator<NodeBuilder> nodeIterator = nodes.iterator();

      shardBuilders = new LinkedList<>();
      if (initialSizeGBPerShard != null && initialSizeGBPerShard.size() != countShards) {
        throw new RuntimeException("list of shard sizes must be the same length as the countShards!");
      }

      for (int shardNumber = 1; shardNumber <= countShards; shardNumber++) {
        String shardName = buildShardName(shardNumber);

        CollectionMetricsBuilder.ShardMetricsBuilder shardMetricsBuilder = new CollectionMetricsBuilder.ShardMetricsBuilder(shardName);

        LinkedList<ReplicaBuilder> replicas = new LinkedList<>();
        ReplicaBuilder leader = null;
        CollectionMetricsBuilder.ReplicaMetricsBuilder leaderMetrics = null;

        // Iterate on requested counts, NRT then TLOG then PULL. Leader chosen as first NRT (or first TLOG if no NRT)
        List<Pair<Replica.ReplicaType, Integer>> replicaTypes = List.of(
            new Pair<>(Replica.ReplicaType.NRT, countNrtReplicas),
            new Pair<>(Replica.ReplicaType.TLOG, countTlogReplicas),
            new Pair<>(Replica.ReplicaType.PULL, countPullReplicas));

        for (Pair<Replica.ReplicaType, Integer> tc : replicaTypes) {
          Replica.ReplicaType type = tc.first();
          int count = tc.second();
          for (int r = 0; r < count; r++) {
            if (!nodeIterator.hasNext()) {
              nodeIterator = nodes.iterator();
            }
            // If the nodes set is empty, this call will fail
            final NodeBuilder node = nodeIterator.next();

            String replicaName = buildReplicaName(shardName, type);

            ReplicaBuilder replicaBuilder = new ReplicaBuilder();
            replicaBuilder.setReplicaName(replicaName).setCoreName(buildCoreName(replicaName)).setReplicaType(type)
                .setReplicaState(Replica.ReplicaState.ACTIVE).setReplicaNode(node);
            replicas.add(replicaBuilder);

            CollectionMetricsBuilder.ReplicaMetricsBuilder replicaMetricsBuilder = new CollectionMetricsBuilder.ReplicaMetricsBuilder(replicaName);
            shardMetricsBuilder.getReplicaMetricsBuilders().put(replicaName, replicaMetricsBuilder);
            if (initialSizeGBPerShard != null) {
              replicaMetricsBuilder.addMetric(ReplicaMetricImpl.INDEX_SIZE_GB, initialSizeGBPerShard.get(shardNumber - 1) * ReplicaMetricImpl.GB);
            }
            if (leader == null && type != Replica.ReplicaType.PULL) {
              leader = replicaBuilder;
              leaderMetrics = replicaMetricsBuilder;
            }
          }
        }

        ShardBuilder shardBuilder = new ShardBuilder();
        shardBuilder.setShardName(shardName).setReplicaBuilders(replicas).setLeader(leader);
        shardMetricsBuilder.setLeaderMetrics(leaderMetrics);
        shardBuilders.add(shardBuilder);
        collectionMetricsBuilder.getShardMetricsBuilders().put(shardName, shardMetricsBuilder);
      }

      return this;
    }

