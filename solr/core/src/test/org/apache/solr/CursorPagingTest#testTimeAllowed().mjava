  /**
   * test that timeAllowed parameter can be used with cursors
   * uses DelayingSearchComponent in solrconfig-deeppaging.xml
   */
  @LogLevel("org.apache.solr.search.SolrIndexSearcher=ERROR;org.apache.solr.handler.component.SearchHandler=ERROR")
  public void testTimeAllowed() throws Exception {
    String wontExceedTimeout = "10000";
    int numDocs = 1000;
    List<String> ids = IntStream.range(0, 1000).mapToObj(String::valueOf).collect(Collectors.toList());
    // Shuffle to test ordering
    Collections.shuffle(ids, random());
    for (String id : ids) {
      assertU(adoc("id", id, "name", "a" + id));
      if (random().nextInt(numDocs) == 0) {
        assertU(commit());  // sometimes make multiple segments
      }
    }
    assertU(commit());

    Collections.sort(ids);

    String cursorMark, nextCursorMark = CURSOR_MARK_START;

    SolrParams params = params("q", "name:a*",
        "fl", "id",
        "sort", "id asc",
        "rows", "50",
        "qt", "/delayed",
        "sleep", "10");

    List<String> foundDocIds = new ArrayList<>();
    String[] timeAllowedVariants = {"1", "50", wontExceedTimeout};
    int partialCount = 0;
    do {
      cursorMark = nextCursorMark;
      for (String timeAllowed : timeAllowedVariants) {

        // execute the query
        String json = assertJQ(req(params, CURSOR_MARK_PARAM, cursorMark, TIME_ALLOWED, timeAllowed));

        Map<?, ?> response = (Map<?, ?>) fromJSONString(json);
        Map<?, ?> responseHeader = (Map<?, ?>) response.get("responseHeader");
        Map<?, ?> responseBody = (Map<?, ?>) response.get("response");
        nextCursorMark = (String) response.get(CURSOR_MARK_NEXT);

        // count occurrence of partialResults (confirm at the end at least one)
        if (responseHeader.containsKey("partialResults")) {
          partialCount++;
        }

        // add the ids found (confirm we found all at the end in correct order)
        @SuppressWarnings({"unchecked"})
        List<Map<Object, Object>> docs = (List<Map<Object, Object>>) (responseBody.get("docs"));
        for (Map<Object, Object> doc : docs) {
          foundDocIds.add(doc.get("id").toString());
        }

        // break out of the timeAllowed variants as soon as we progress
        if (!cursorMark.equals(nextCursorMark)) {
          break;
        }
      }
    } while (!cursorMark.equals(nextCursorMark));

    ArrayList<String> sortedFoundDocIds = new ArrayList<>(foundDocIds);
    sortedFoundDocIds.sort(null);
    // Note: it is not guaranteed that all docs will be found, because a query may time out
    // before reaching all segments, this causes documents in the skipped segments to be skipped
    // in the overall result set as the cursor pages through.
    assertEquals("Should have found last doc id eventually", ids.get(ids.size() -1), foundDocIds.get(foundDocIds.size() -1));
    assertEquals("Documents arrived in sorted order within and between pages", sortedFoundDocIds, foundDocIds);
    assertTrue("Should have experienced at least one partialResult", partialCount > 0);
  }

