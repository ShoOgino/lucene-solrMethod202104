  private void verifySort(BKDConfig config, HeapPointWriter points,int start, int end) throws IOException{
    Directory dir = newDirectory();
    BKDRadixSelector radixSelector = new BKDRadixSelector(config, 1000, dir, "test");
    // we check for each dimension
    for (int splitDim = 0; splitDim < config.numDims; splitDim++) {
      radixSelector.heapRadixSort(points, start, end, splitDim, getRandomCommonPrefix(config, points, start, end, splitDim));
      byte[] previous = new byte[config.packedBytesLength];
      int previousDocId = -1;
      Arrays.fill(previous, (byte) 0);
      int dimOffset = splitDim * config.bytesPerDim;
      for (int j = start; j < end; j++) {
        PointValue pointValue = points.getPackedValueSlice(j);
        BytesRef value = pointValue.packedValue();
        int cmp = Arrays.compareUnsigned(value.bytes, value.offset + dimOffset, value.offset + dimOffset + config.bytesPerDim, previous, dimOffset, dimOffset + config.bytesPerDim);
        assertTrue(cmp >= 0);
        if (cmp == 0) {
          int dataOffset = config.numIndexDims * config.bytesPerDim;
          cmp = Arrays.compareUnsigned(value.bytes, value.offset + dataOffset, value.offset + config.packedBytesLength, previous, dataOffset, config.packedBytesLength);
          assertTrue(cmp >= 0);
        }
        if (cmp == 0) {
          assertTrue(pointValue.docID() >= previousDocId);
        }
        System.arraycopy(value.bytes, value.offset, previous, 0, config.packedBytesLength);
        previousDocId = pointValue.docID();
      }
    }
    dir.close();
  }

