  @Override
  public synchronized IndexInput openInput(String name, IOContext context) throws IOException {
    maybeThrowDeterministicException();
    maybeThrowIOExceptionOnOpen(name);
    maybeYield();
    if (failOnOpenInput) {
      maybeThrowDeterministicException();
    }
    if (!LuceneTestCase.slowFileExists(in, name)) {
      throw randomState.nextBoolean()
          ? new FileNotFoundException(name + " in dir=" + in)
          : new NoSuchFileException(name + " in dir=" + in);
    }

    // cannot open a file for input if it's still open for output.
    if (!allowReadingFilesStillOpenForWrite && openFilesForWrite.contains(name)) {
      throw fillOpenTrace(
          new AccessDeniedException(
              "MockDirectoryWrapper: file \"" + name + "\" is still open for writing"),
          name,
          false);
    }

    IndexInput delegateInput =
        in.openInput(name, LuceneTestCase.newIOContext(randomState, context));

    final IndexInput ii;
    int randomInt = randomState.nextInt(500);
    if (useSlowOpenClosers && randomInt == 0) {
      if (LuceneTestCase.VERBOSE) {
        System.out.println(
            "MockDirectoryWrapper: using SlowClosingMockIndexInputWrapper for file " + name);
      }
      ii = new SlowClosingMockIndexInputWrapper(this, name, delegateInput);
    } else if (useSlowOpenClosers && randomInt == 1) {
      if (LuceneTestCase.VERBOSE) {
        System.out.println(
            "MockDirectoryWrapper: using SlowOpeningMockIndexInputWrapper for file " + name);
      }
      ii = new SlowOpeningMockIndexInputWrapper(this, name, delegateInput);
    } else {
      ii = new MockIndexInputWrapper(this, name, delegateInput, null);
    }
    addFileHandle(ii, name, Handle.Input);
    return ii;
  }

