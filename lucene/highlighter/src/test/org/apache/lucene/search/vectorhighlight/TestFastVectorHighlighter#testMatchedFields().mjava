  public void testMatchedFields() throws IOException {
    // Searching just on the stored field doesn't highlight a stopword
    matchedFieldsTestCase(
        false, true, "a match", "a <b>match</b>", clause("field", "a"), clause("field", "match"));

    // Even if you add an unqueried matched field that would match it
    matchedFieldsTestCase(
        "a match", "a <b>match</b>", clause("field", "a"), clause("field", "match"));

    // Nor if you query the field but don't add it as a matched field to the highlighter
    matchedFieldsTestCase(
        false,
        false,
        "a match",
        "a <b>match</b>",
        clause("field_exact", "a"),
        clause("field", "match"));

    // But if you query the field and add it as a matched field to the highlighter then it is
    // highlighted
    matchedFieldsTestCase(
        "a match", "<b>a</b> <b>match</b>", clause("field_exact", "a"), clause("field", "match"));

    // It is also ok to match just the matched field but get highlighting from the stored field
    matchedFieldsTestCase(
        "a match",
        "<b>a</b> <b>match</b>",
        clause("field_exact", "a"),
        clause("field_exact", "match"));

    // Boosted matched fields work too
    matchedFieldsTestCase(
        "a match",
        "<b>a</b> <b>match</b>",
        clause("field_exact", 5, "a"),
        clause("field", "match"));

    // It is also ok if both the stored and the matched field match the term
    matchedFieldsTestCase(
        "a match", "a <b>match</b>", clause("field_exact", "match"), clause("field", "match"));

    // And the highlighter respects the boosts on matched fields when sorting fragments
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field", "cat"),
        clause("field_exact", 5, "a", "cat"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> <b>cat</b> junk junk junk junk",
        clause("field", "cat"),
        clause("field_exact", "a", "cat"));

    // The same thing works across three fields as well
    matchedFieldsTestCase(
        "cat cat CAT junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field", "cat"),
        clause("field_exact", 200, "a", "cat"),
        clause("field_super_exact", 5, "CAT"));
    matchedFieldsTestCase(
        "a cat cat junk junk junk junk junk junk junk a CAT junk junk",
        "junk junk <b>a CAT</b> junk junk",
        clause("field", "cat"),
        clause("field_exact", 5, "a", "cat"),
        clause("field_super_exact", 200, "a", "CAT"));

    // And across fields with different tokenizers!
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field_exact", 5, "a", "cat"),
        clause("field_characters", "c"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>c</b>at <b>c</b>at junk junk junk junk",
        clause("field_exact", "a", "cat"),
        clause("field_characters", "c"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "ca<b>t</b> ca<b>t</b> junk junk junk junk",
        clause("field_exact", "a", "cat"),
        clause("field_characters", "t"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> <b>cat</b> junk junk junk junk", // See how the phrases are joined?
        clause("field", "cat"),
        clause("field_characters", 5, "c"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field", "cat"),
        clause("field_characters", 5, "a", " ", "c", "a", "t"));

    // Phrases and tokens inside one another are joined
    matchedFieldsTestCase(
        "cats wow", "<b>cats w</b>ow", clause("field", "cats"), clause("field_tripples", "s w"));

    // Everything works pretty well even if you don't require a field match
    matchedFieldsTestCase(
        true,
        false,
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field", "cat"),
        clause("field_characters", 10, "a", " ", "c", "a", "t"));

    // Even boosts keep themselves pretty much intact
    matchedFieldsTestCase(
        true,
        false,
        "a cat cat junk junk junk junk junk junk junk a CAT junk junk",
        "junk junk <b>a CAT</b> junk junk",
        clause("field", "cat"),
        clause("field_exact", 5, "a", "cat"),
        clause("field_super_exact", 200, "a", "CAT"));
    matchedFieldsTestCase(
        true,
        false,
        "cat cat CAT junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field", "cat"),
        clause("field_exact", 200, "a", "cat"),
        clause("field_super_exact", 5, "CAT"));

    // Except that all the matched field matches apply even if they aren't mentioned in the query
    // which can make for some confusing scoring.  This isn't too big a deal, just something you
    // need to think about when you don't force a field match.
    matchedFieldsTestCase(
        true,
        false,
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> <b>cat</b> junk junk junk junk",
        clause("field", "cat"),
        clause("field_characters", 4, "a", " ", "c", "a", "t"));

    // It is also cool to match fields that don't have _exactly_ the same text so long as you are
    // careful.
    // In this case field_sliced is a prefix of field.
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> <b>cat</b> junk junk junk junk",
        clause("field_sliced", "cat"));

    // Multiple matches add to the score of the segment
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> <b>cat</b> junk junk junk junk",
        clause("field", "cat"),
        clause("field_sliced", "cat"),
        clause("field_exact", 2, "a", "cat"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "junk junk <b>a cat</b> junk junk",
        clause("field", "cat"),
        clause("field_sliced", "cat"),
        clause("field_exact", 4, "a", "cat"));

    // Even fields with tokens on top of one another are ok
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> cat junk junk junk junk",
        clause("field_der_red", 2, "der"),
        clause("field_exact", "a", "cat"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> cat junk junk junk junk",
        clause("field_der_red", 2, "red"),
        clause("field_exact", "a", "cat"));
    matchedFieldsTestCase(
        "cat cat junk junk junk junk junk junk junk a cat junk junk",
        "<b>cat</b> cat junk junk junk junk",
        clause("field_der_red", "red"),
        clause("field_der_red", "der"),
        clause("field_exact", "a", "cat"));
  }

