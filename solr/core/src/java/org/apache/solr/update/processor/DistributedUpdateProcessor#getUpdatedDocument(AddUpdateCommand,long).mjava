  // TODO: may want to switch to using optimistic locking in the future for better concurrency
  // that's why this code is here... need to retry in a loop closely around/in versionAdd
  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {
    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;

    if (idField == null) {
      throw new SolrException(ErrorCode.BAD_REQUEST, "Can't do atomic updates without a schema uniqueKeyField");
    }

    BytesRef rootIdBytes = cmd.getIndexedId(); // root doc; falls back to doc ID if no _route_
    String rootDocIdString = cmd.getIndexedIdStr();

    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);
    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates
      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {
        return true;
      } // in-place update failed, so fall through and re-try the same with a full atomic update
    }

    // if this is an atomic update, and hasn't already been done "in-place",
    // but the user indicated it must be done in palce, then fail with an error...
    if (cmd.getReq().getParams().getBool(UpdateParams.REQUIRE_PARTIAL_DOC_UPDATES_INPLACE, false)) {
      throw new SolrException
        (ErrorCode.BAD_REQUEST,
         "Can not satisfy '" + UpdateParams.REQUIRE_PARTIAL_DOC_UPDATES_INPLACE +
         "'; Unable to update doc in-place: " + cmd.getPrintableId());
    }
    
    // full (non-inplace) atomic update

    final SolrInputDocument oldRootDocWithChildren =
        RealTimeGetComponent.getInputDocument(
            req.getCore(),
            rootIdBytes,
            rootIdBytes,
            null,
            null,
            RealTimeGetComponent.Resolution.ROOT_WITH_CHILDREN); // when no children, just fetches the doc

    SolrInputDocument sdoc = cmd.getSolrInputDocument();
    SolrInputDocument mergedDoc;
    if (oldRootDocWithChildren == null) {
      if (versionOnUpdate > 0
          || !rootDocIdString.equals(cmd.getChildDocIdStr())) {
        // could just let the optimistic locking throw the error
        throw new SolrException(ErrorCode.CONFLICT, "Document not found for update.  id=" + rootDocIdString);
      }
      // create a new doc by default if an old one wasn't found
      mergedDoc = docMerger.merge(sdoc, new SolrInputDocument(idField.getName(), rootDocIdString));
    } else {
      oldRootDocWithChildren.remove(CommonParams.VERSION_FIELD);

      mergedDoc = docMerger.merge(sdoc, oldRootDocWithChildren);
    }

    cmd.solrDoc = mergedDoc;
    return true;
  }

