  // Test what happens when the cache contains only filters and doc id sets
  // that require very little memory. In that case most of the memory is taken
  // by the cache itself, not cache entries, and we want to make sure that
  // memory usage is not grossly underestimated.
  public void testRamBytesUsedConstantEntryOverhead() throws IOException {
    assumeFalse(
        "LUCENE-7595: RamUsageTester does not work exact in Java 9 (estimations for maps and lists)",
        Constants.JRE_IS_MINIMUM_JAVA9);

    final LRUQueryCache queryCache =
        new LRUQueryCache(1000000, 10000000, context -> true, Float.POSITIVE_INFINITY);

    final RamUsageTester.Accumulator acc =
        new RamUsageTester.Accumulator() {
          @Override
          public long accumulateObject(
              Object o,
              long shallowSize,
              Map<Field, Object> fieldValues,
              Collection<Object> queue) {
            if (o instanceof DocIdSet) {
              return ((DocIdSet) o).ramBytesUsed();
            }
            if (o instanceof Query) {
              return QUERY_DEFAULT_RAM_BYTES_USED;
            }
            if (o.getClass().getSimpleName().equals("SegmentCoreReaders")) {
              // do not follow references to core cache keys
              return 0;
            }
            return super.accumulateObject(o, shallowSize, fieldValues, queue);
          }
        };

    Directory dir = newDirectory();
    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
    Document doc = new Document();
    final int numDocs = atLeast(100);
    for (int i = 0; i < numDocs; ++i) {
      w.addDocument(doc);
    }
    final DirectoryReader reader = w.getReader();
    final IndexSearcher searcher = new IndexSearcher(reader);
    searcher.setQueryCache(queryCache);
    searcher.setQueryCachingPolicy(ALWAYS_CACHE);

    final int numQueries = atLeast(1000);
    for (int i = 0; i < numQueries; ++i) {
      final Query query = new DummyQuery();
      searcher.search(new ConstantScoreQuery(query), 1);
    }
    assertTrue(queryCache.getCacheCount() > 0);

    final long actualRamBytesUsed = RamUsageTester.sizeOf(queryCache, acc);
    final long expectedRamBytesUsed = queryCache.ramBytesUsed();
    // error < 30%
    assertEquals(actualRamBytesUsed, expectedRamBytesUsed, 30 * actualRamBytesUsed / 100);

    reader.close();
    w.close();
    dir.close();
  }

