  public boolean write(SortDoc sortDoc, LeafReaderContext readerContext, MapWriter.EntryWriter ew, int fieldIndex) throws IOException {
    StringValue stringValue = (StringValue) sortDoc.getSortValue(this.field);
    BytesRef ref = null;

    if (stringValue != null) {
      /*
        We already have the top level ordinal used for sorting.
        Now let's use it for caching the BytesRef so we don't have to look it up.
        When we have long runs of repeated values do to the sort order of the docs this is a huge win.
       */

      if(stringValue.currentOrd == -1) {
        //Null sort value
        return false;
      }

      if (this.lastOrd == stringValue.currentOrd) {
        ref = lastRef;
      }

      this.lastOrd = stringValue.currentOrd;
    }

    if (ref == null) {
      //Reuse the last DocValues object if possible
      int readerOrd = readerContext.ord;
      SortedDocValues vals = null;
      if(docValuesCache.containsKey(readerOrd)) {
        SortedDocValues sortedDocValues = docValuesCache.get(readerOrd);
        if(sortedDocValues.docID() < sortDoc.docId) {
          //We have not advanced beyond the current docId so we can use this docValues.
          vals = sortedDocValues;
        }
      }

      if(vals == null) {
        vals = DocValues.getSorted(readerContext.reader(), this.field);
        docValuesCache.put(readerOrd, vals);
      }

      if (vals.advance(sortDoc.docId) != sortDoc.docId) {
        return false;
      }

      int ord = vals.ordValue();
      ref = vals.lookupOrd(ord);

      if(stringValue != null) {
        //Don't need to set the lastRef if it's not a sort value.
        lastRef = ref.clone();
      }
    }

    writeBytes(ew, ref, fieldType);
    return true;
  }

