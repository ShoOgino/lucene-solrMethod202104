  /**
   * Expert: Construct a direct {@link Reader} from a stream without reading
   * metadata at the beginning of the stream. This method is useful to restore
   * data from streams which have been created using
   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.
   * </p><p>
   * The returned reader will have very little memory overhead, but every call
   * to {@link Reader#get(int)} is likely to perform a disk seek.
   *
   * @param in           the stream to read data from
   * @param format       the format used to serialize
   * @param version      the version used to serialize the data
   * @param valueCount   how many values the stream holds
   * @param bitsPerValue the number of bits per value
   * @return a direct Reader
   * @lucene.internal
   */
  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,
      int version, int valueCount, int bitsPerValue) {
    checkVersion(version);
    switch (format) {
      case PACKED:
        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);
        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {
          assert version == VERSION_START;
          final long endPointer = in.getFilePointer() + byteCount;
          // Some consumers of direct readers assume that reading the last value
          // will make the underlying IndexInput go to the end of the packed
          // stream, but this is not true because packed ints storage used to be
          // long-aligned and is now byte-aligned, hence this additional
          // condition when reading the last value
          return new DirectPackedReader(bitsPerValue, valueCount, in) {
            @Override
            public long get(int index) {
              final long result = super.get(index);
              if (index == valueCount - 1) {
                try {
                  in.seek(endPointer);
                } catch (IOException e) {
                  throw new IllegalStateException("failed", e);
                }
              }
              return result;
            }
          };
        } else {
          return new DirectPackedReader(bitsPerValue, valueCount, in);
        }
      case PACKED_SINGLE_BLOCK:
        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);
      default:
        throw new AssertionError("Unknwown format: " + format);
    }
  }

