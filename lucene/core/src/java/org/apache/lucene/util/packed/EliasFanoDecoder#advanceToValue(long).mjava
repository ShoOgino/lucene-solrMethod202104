  /** Given a target value, advance the decoding index to the first bigger or equal value
   * and return it if it is available. Otherwise return {@link #NO_MORE_VALUES}.
   * <br>The current implementation uses the index on the upper zero bit positions.
   */
  public long advanceToValue(long target) {
    efIndex += 1;
    if (efIndex >= numEncoded) {
      return NO_MORE_VALUES;
    }
    setBitForIndex += 1; // the high bit at setBitForIndex belongs to the unary code for efIndex

    int highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
    long upperLong = efEncoder.upperLongs[highIndex];
    curHighLong = upperLong >>> ((int) (setBitForIndex & (Long.SIZE-1))); // may contain the unary 1 bit for efIndex

    // determine index entry to advance to
    long highTarget = target >>> efEncoder.numLowBits;

    long indexEntryIndex = (highTarget / efEncoder.indexInterval) - 1;
    if (indexEntryIndex >= 0) { // not before first index entry
      if (indexEntryIndex >= numIndexEntries) {
        indexEntryIndex = numIndexEntries - 1; // no further than last index entry
      }
      long indexHighValue = (indexEntryIndex + 1) * efEncoder.indexInterval;
      assert indexHighValue <= highTarget;
      if (indexHighValue > (setBitForIndex - efIndex)) { // advance to just after zero bit position of index entry.
        setBitForIndex = unPackValue(efEncoder.upperZeroBitPositionIndex, efEncoder.nIndexEntryBits, indexEntryIndex, indexMask);
        efIndex = setBitForIndex - indexHighValue; // the high bit at setBitForIndex belongs to the unary code for efIndex
        highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
        upperLong = efEncoder.upperLongs[highIndex];
        curHighLong = upperLong >>> ((int) (setBitForIndex & (Long.SIZE-1))); // may contain the unary 1 bit for efIndex
      }
      assert efIndex < numEncoded; // there is a high value to be found.
    }

    int curSetBits = Long.bitCount(curHighLong); // shifted right.
    int curClearBits = Long.SIZE - curSetBits - ((int) (setBitForIndex & (Long.SIZE-1))); // subtract right shift, may be more than encoded

    while (((setBitForIndex - efIndex) + curClearBits) < highTarget) {
      // curHighLong has not enough clear bits to reach highTarget
      efIndex += curSetBits;
      if (efIndex >= numEncoded) {
        return NO_MORE_VALUES;
      }
      setBitForIndex += Long.SIZE - (setBitForIndex & (Long.SIZE-1));
      // highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
      assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
      highIndex += 1;
      upperLong = efEncoder.upperLongs[highIndex];
      curHighLong = upperLong;
      curSetBits = Long.bitCount(curHighLong);
      curClearBits = Long.SIZE - curSetBits;
    }
    // curHighLong has enough clear bits to reach highTarget, and may not have enough set bits.
    while (curHighLong == 0L) {
      setBitForIndex += Long.SIZE - (setBitForIndex & (Long.SIZE-1));
      assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
      highIndex += 1;
      upperLong = efEncoder.upperLongs[highIndex];
      curHighLong = upperLong;
    }

    // curHighLong has enough clear bits to reach highTarget, has at least 1 set bit, and may not have enough set bits.
    int rank = (int) (highTarget - (setBitForIndex - efIndex)); // the rank of the zero bit for highValue.
    assert (rank <= Long.SIZE) : ("rank " + rank);
    if (rank >= 1) {
      long invCurHighLong = ~curHighLong;
      int clearBitForValue = (rank <= 8)
                              ? BitUtil.selectNaive(invCurHighLong, rank)
                              : BitUtil.select(invCurHighLong, rank);
      assert clearBitForValue >= 0;
      assert clearBitForValue <= Long.SIZE-1;
      setBitForIndex += clearBitForValue + 1; // the high bit just before setBitForIndex is zero
      int oneBitsBeforeClearBit = clearBitForValue - rank + 1;
      efIndex += oneBitsBeforeClearBit; // the high bit at setBitForIndex and belongs to the unary code for efIndex
      if (efIndex >= numEncoded) {
        return NO_MORE_VALUES;
      }

      if ((setBitForIndex & (Long.SIZE - 1)) == 0L) { // exhausted curHighLong
        assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
        highIndex += 1;
        upperLong = efEncoder.upperLongs[highIndex];
        curHighLong = upperLong;
      }
      else {
        assert highIndex == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
        curHighLong = upperLong >>> ((int) (setBitForIndex & (Long.SIZE-1)));
      }
      // curHighLong has enough clear bits to reach highTarget, and may not have enough set bits.
 
      while (curHighLong == 0L) {
        setBitForIndex += Long.SIZE - (setBitForIndex & (Long.SIZE-1));
        assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
        highIndex += 1;
        upperLong = efEncoder.upperLongs[highIndex];
        curHighLong = upperLong;
      }
    }
    setBitForIndex += Long.numberOfTrailingZeros(curHighLong);
    assert (setBitForIndex - efIndex) >= highTarget; // highTarget reached

    // Linear search also with low values
    long currentValue = combineHighLowValues((setBitForIndex - efIndex), currentLowValue());
    while (currentValue < target) {
      currentValue = nextValue();
      if (currentValue == NO_MORE_VALUES) {
        return NO_MORE_VALUES;
      }
    }
    return currentValue;
  }

