  /**
   * {@inheritDoc}
   *
   * <p>This method inspects the stack trace and checks who is calling {@link System#exit(int)} and
   * similar methods
   *
   * @throws SecurityException if the caller of this method is not the test runner itself.
   */
  @Override
  public void checkExit(final int status) {
    if (StackWalker.getInstance()
        .walk(
            s ->
                // skip all internal stack frames
                s.dropWhile(Predicate.not(TestSecurityManager::isExitStackFrame))
                    // skip all exit()/halt() stack frames
                    .dropWhile(TestSecurityManager::isExitStackFrame)
                    .limit(1) // only look at one more frame (caller of exit)
                    .map(StackFrame::getClassName)
                    .noneMatch(
                        c ->
                            c.startsWith(JUNIT4_TEST_RUNNER_PACKAGE)
                                || c.startsWith(ECLIPSE_TEST_RUNNER_PACKAGE)
                                || c.startsWith(IDEA_TEST_RUNNER_PACKAGE)
                                || c.startsWith(GRADLE_TEST_RUNNER_PACKAGE)))) {
      throw new SecurityException(
          String.format(
              Locale.ENGLISH,
              "System/Runtime.exit(%1$d) or halt(%1$d) calls are not allowed because they terminate the test runner's JVM.",
              status));
    }
    // we passed the stack check, delegate to super, so default policy can still deny permission:
    super.checkExit(status);
  }

