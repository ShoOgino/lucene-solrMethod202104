  public void testGroupHeadsWithSort() throws IOException {

    Shard shard = new Shard();
    indexRandomDocs(shard.writer);
    IndexSearcher searcher = shard.getIndexSearcher();

    String[] query = new String[]{ "foo", "bar", "baz" };
    Query topLevel = new TermQuery(new Term("text", query[random().nextInt(query.length)]));

    Sort sort = new Sort(new SortField("sort1", SortField.Type.STRING), new SortField("sort2", SortField.Type.LONG));
    GroupSelector<T> groupSelector = getGroupSelector();
    GroupingSearch grouping = new GroupingSearch(groupSelector);
    grouping.setAllGroups(true);
    grouping.setAllGroupHeads(true);
    grouping.setSortWithinGroup(sort);

    grouping.search(searcher, topLevel, 0, 1);
    Collection<T> matchingGroups = grouping.getAllMatchingGroups();

    Bits groupHeads = grouping.getAllGroupHeads();
    int cardinality = 0;
    for (int i = 0; i < groupHeads.length(); i++) {
      if (groupHeads.get(i)) {
        cardinality++;
      }
    }
    assertEquals(matchingGroups.size(), cardinality);   // We should have one set bit per matching group

    // Each group head should correspond to the topdoc of a search filtered by
    // that group using the same within-group sort
    for (T groupValue : matchingGroups) {
      Query filtered = new BooleanQuery.Builder()
          .add(topLevel, BooleanClause.Occur.MUST)
          .add(filterQuery(groupValue), BooleanClause.Occur.FILTER)
          .build();
      TopDocs td = searcher.search(filtered, 1, sort);
      assertTrue(groupHeads.get(td.scoreDocs[0].doc));
    }

    shard.close();
  }

