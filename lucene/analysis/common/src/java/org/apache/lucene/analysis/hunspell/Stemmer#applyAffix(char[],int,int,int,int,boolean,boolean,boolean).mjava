  /**
   * Applies the affix rule to the given word, producing a list of stems if any are found
   *
   * @param strippedWord Word the affix has been removed and the strip added
   * @param length valid length of stripped word
   * @param affix HunspellAffix representing the affix rule itself
   * @param prefixId when we already stripped a prefix, we cant simply recurse and check the suffix,
   *     unless both are compatible so we must check dictionary form against both to add it as a
   *     stem!
   * @param recursionDepth current recursion depth
   * @param prefix true if we are removing a prefix (false if it's a suffix)
   * @return List of stems for the word, or an empty list if none are found
   */
  private List<CharsRef> applyAffix(
      char[] strippedWord,
      int length,
      int affix,
      int prefixId,
      int recursionDepth,
      boolean prefix,
      boolean circumfix,
      boolean caseVariant)
      throws IOException {
    char flag = dictionary.affixData(affix, Dictionary.AFFIX_FLAG);

    List<CharsRef> stems = new ArrayList<>();

    IntsRef forms = dictionary.lookupWord(strippedWord, 0, length);
    if (forms != null) {
      for (int i = 0; i < forms.length; i += formStep) {
        char[] wordFlags = dictionary.decodeFlags(forms.ints[forms.offset + i], scratch);
        if (Dictionary.hasFlag(wordFlags, flag) || isFlagAppendedByAffix(prefixId, flag)) {
          // confusing: in this one exception, we already chained the first prefix against the
          // second,
          // so it doesnt need to be checked against the word
          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;
          if (!chainedPrefix && prefixId >= 0) {
            char prefixFlag = dictionary.affixData(prefixId, Dictionary.AFFIX_FLAG);
            if (!Dictionary.hasFlag(wordFlags, prefixFlag)
                && !isFlagAppendedByAffix(affix, prefixFlag)) {
              continue;
            }
          }

          // if circumfix was previously set by a prefix, we must check this suffix,
          // to ensure it has it, and vice versa
          if (dictionary.circumfix != -1) {
            boolean suffixCircumfix = isFlagAppendedByAffix(affix, (char) dictionary.circumfix);
            if (circumfix != suffixCircumfix) {
              continue;
            }
          }

          // we are looking for a case variant, but this word does not allow it
          if (!acceptCase(caseVariant, wordFlags)) {
            continue;
          }
          // we aren't decompounding (yet)
          if (dictionary.onlyincompound != -1
              && Dictionary.hasFlag(wordFlags, (char) dictionary.onlyincompound)) {
            continue;
          }
          stems.add(newStem(strippedWord, length, forms, i));
        }
      }
    }

    // if a circumfix flag is defined in the dictionary, and we are a prefix, we need to check if we
    // have that flag
    if (dictionary.circumfix != -1 && !circumfix && prefix) {
      circumfix = isFlagAppendedByAffix(affix, (char) dictionary.circumfix);
    }

    if (isCrossProduct(affix) && recursionDepth <= 1) {
      boolean doPrefix;
      if (recursionDepth == 0) {
        if (prefix) {
          prefixId = affix;
          doPrefix = dictionary.complexPrefixes && dictionary.twoStageAffix;
          // we took away the first prefix.
          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix
          // COMPLEXPREFIXES = false: combine with a suffix
        } else if (!dictionary.complexPrefixes && dictionary.twoStageAffix) {
          doPrefix = false;
          // we took away a suffix.
          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed
          // COMPLEXPREFIXES = false: combine with another suffix
        } else {
          return stems;
        }
      } else {
        doPrefix = false;
        if (prefix && dictionary.complexPrefixes) {
          prefixId = affix;
          // we took away the second prefix: go look for another suffix
        } else if (prefix || dictionary.complexPrefixes || !dictionary.twoStageAffix) {
          return stems;
        }
        // we took away a prefix, then a suffix: go look for another suffix
      }

      stems.addAll(
          stem(
              strippedWord,
              length,
              affix,
              flag,
              prefixId,
              recursionDepth + 1,
              doPrefix,
              true,
              prefix,
              circumfix,
              caseVariant));
    }

    return stems;
  }

