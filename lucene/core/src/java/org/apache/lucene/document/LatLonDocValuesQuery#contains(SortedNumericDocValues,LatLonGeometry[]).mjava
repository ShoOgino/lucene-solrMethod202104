  private TwoPhaseIterator contains(SortedNumericDocValues values, LatLonGeometry[] geometries) {
    final List<Component2D> component2Ds = new ArrayList<>(geometries.length);
    for (int i = 0; i < geometries.length; i++) {
      component2Ds.add(LatLonGeometry.create(geometries[i]));
    }
    return new TwoPhaseIterator(values) {
      @Override
      public boolean matches() throws IOException {
        Component2D.WithinRelation answer = Component2D.WithinRelation.DISJOINT;
        for (int i = 0, count = values.docValueCount(); i < count; ++i) {
          final long value = values.nextValue();
          final double lat = GeoEncodingUtils.decodeLatitude((int) (value >>> 32));
          final double lon = GeoEncodingUtils.decodeLongitude((int) (value & 0xFFFFFFFF));
          for (Component2D component2D : component2Ds) {
            Component2D.WithinRelation relation = component2D.withinPoint(lon, lat);
            if (relation == Component2D.WithinRelation.NOTWITHIN) {
              return false;
            } else if (relation != Component2D.WithinRelation.DISJOINT) {
              answer = relation;
            }
          }
        }
        return answer == Component2D.WithinRelation.CANDIDATE;
      }

      @Override
      public float matchCost() {
        return 1000f; // TODO: what should it be?
      }
    };
  }

