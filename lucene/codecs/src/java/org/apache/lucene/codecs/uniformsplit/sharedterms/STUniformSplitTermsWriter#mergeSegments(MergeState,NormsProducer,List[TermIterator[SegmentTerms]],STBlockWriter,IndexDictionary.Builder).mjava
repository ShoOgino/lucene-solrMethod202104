  private Collection<FieldMetadata> mergeSegments(
      MergeState mergeState,
      NormsProducer normsProducer,
      List<TermIterator<SegmentTerms>> segmentTermsList,
      STBlockWriter blockWriter,
      IndexDictionary.Builder dictionaryBuilder)
      throws IOException {
    List<FieldMetadata> fieldMetadataList =
        createFieldMetadataList(
            mergeState.mergeFieldInfos.iterator(), mergeState.segmentInfo.maxDoc());
    Map<String, MergingFieldTerms> fieldTermsMap =
        createMergingFieldTermsMap(fieldMetadataList, mergeState.fieldsProducers.length);
    TermIteratorQueue<SegmentTerms> segmentTermsQueue = createSegmentTermsQueue(segmentTermsList);
    List<TermIterator<SegmentTerms>> groupedSegmentTerms = new ArrayList<>(segmentTermsList.size());
    Map<String, List<SegmentPostings>> fieldPostingsMap =
        new HashMap<>(mergeState.fieldInfos.length);
    List<MergingFieldTerms> groupedFieldTerms = new ArrayList<>(mergeState.fieldInfos.length);
    List<FieldMetadataTermState> termStates = new ArrayList<>(mergeState.fieldInfos.length);

    while (segmentTermsQueue.size() != 0) {
      TermIterator<SegmentTerms> topSegmentTerms = segmentTermsQueue.popTerms();
      BytesRef term = BytesRef.deepCopyOf(topSegmentTerms.term);
      groupByTerm(segmentTermsQueue, topSegmentTerms, groupedSegmentTerms);
      combineSegmentsFields(groupedSegmentTerms, fieldPostingsMap);
      combinePostingsPerField(term, fieldTermsMap, fieldPostingsMap, groupedFieldTerms);
      writePostingLines(term, groupedFieldTerms, normsProducer, termStates);
      blockWriter.addLine(term, termStates, dictionaryBuilder);
      nextTermForIterators(groupedSegmentTerms, segmentTermsQueue);
    }
    return fieldMetadataList;
  }

