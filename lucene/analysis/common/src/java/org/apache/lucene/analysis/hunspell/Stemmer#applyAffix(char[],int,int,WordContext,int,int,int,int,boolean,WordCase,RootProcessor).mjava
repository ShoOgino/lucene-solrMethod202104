  /**
   * Applies the affix rule to the given word, producing a list of stems if any are found
   *
   * @param strippedWord Char array containing the word with the affix removed and the strip added
   * @param offset where the word actually starts in the array
   * @param length the length of the stripped word
   * @param affix HunspellAffix representing the affix rule itself
   * @param prefixId when we already stripped a prefix, we can't simply recurse and check the
   *     suffix, unless both are compatible so we must check dictionary form against both to add it
   *     as a stem!
   * @param recursionDepth current recursion depth
   * @param prefix true if we are removing a prefix (false if it's a suffix)
   * @return whether the processing should be continued
   */
  private boolean applyAffix(
      char[] strippedWord,
      int offset,
      int length,
      WordContext context,
      int affix,
      int previousAffix,
      int prefixId,
      int recursionDepth,
      boolean prefix,
      WordCase originalCase,
      RootProcessor processor)
      throws IOException {
    char flag = dictionary.affixData(affix, Dictionary.AFFIX_FLAG);

    boolean skipLookup = needsAnotherAffix(affix, previousAffix, !prefix, prefixId);
    IntsRef forms = skipLookup ? null : dictionary.lookupWord(strippedWord, offset, length);
    if (forms != null) {
      for (int i = 0; i < forms.length; i += formStep) {
        int entryId = forms.ints[forms.offset + i];
        if (dictionary.hasFlag(entryId, flag) || isFlagAppendedByAffix(prefixId, flag)) {
          // confusing: in this one exception, we already chained the first prefix against the
          // second,
          // so it doesnt need to be checked against the word
          boolean chainedPrefix = dictionary.complexPrefixes && recursionDepth == 1 && prefix;
          if (!chainedPrefix && prefixId >= 0) {
            char prefixFlag = dictionary.affixData(prefixId, Dictionary.AFFIX_FLAG);
            if (!dictionary.hasFlag(entryId, prefixFlag)
                && !isFlagAppendedByAffix(affix, prefixFlag)) {
              continue;
            }
          }

          // we are looking for a case variant, but this word does not allow it
          if (!acceptCase(originalCase, entryId, strippedWord, offset, length)) {
            continue;
          }
          if (!context.isCompound() && dictionary.hasFlag(entryId, dictionary.onlyincompound)) {
            continue;
          }
          if (context.isCompound()) {
            char cFlag = context.requiredFlag(dictionary);
            if (!dictionary.hasFlag(entryId, cFlag)
                && !isFlagAppendedByAffix(affix, cFlag)
                && !dictionary.hasFlag(entryId, dictionary.compoundFlag)
                && !isFlagAppendedByAffix(affix, dictionary.compoundFlag)) {
              continue;
            }
          }
          if (!callProcessor(strippedWord, offset, length, processor, forms, i)) {
            return false;
          }
        }
      }
    }

    if (dictionary.isCrossProduct(affix) && recursionDepth <= 1) {
      boolean doPrefix;
      if (recursionDepth == 0) {
        if (prefix) {
          prefixId = affix;
          doPrefix = dictionary.complexPrefixes && dictionary.twoStageAffix;
          // we took away the first prefix.
          // COMPLEXPREFIXES = true:  combine with a second prefix and another suffix
          // COMPLEXPREFIXES = false: combine with a suffix
        } else if (!dictionary.complexPrefixes && dictionary.twoStageAffix) {
          doPrefix = false;
          // we took away a suffix.
          // COMPLEXPREFIXES = true: we don't recurse! only one suffix allowed
          // COMPLEXPREFIXES = false: combine with another suffix
        } else {
          return true;
        }
      } else {
        doPrefix = false;
        if (prefix && dictionary.complexPrefixes) {
          prefixId = affix;
          // we took away the second prefix: go look for another suffix
        } else if (prefix || dictionary.complexPrefixes || !dictionary.twoStageAffix) {
          return true;
        }
        // we took away a prefix, then a suffix: go look for another suffix
      }

      return stem(
          strippedWord,
          offset,
          length,
          context,
          affix,
          flag,
          prefixId,
          recursionDepth + 1,
          doPrefix,
          prefix,
          originalCase,
          processor);
    }

    return true;
  }

