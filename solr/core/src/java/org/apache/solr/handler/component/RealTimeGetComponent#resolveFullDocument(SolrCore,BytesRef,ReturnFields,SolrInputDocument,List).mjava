  /**
   * Given a partial document obtained from the transaction log (e.g. as a result of RTG), resolve to a full document
   * by populating all the partial updates that were applied on top of that last full document update.
   * Transformers are applied.
   * <p>TODO <em>Sometimes</em> there's copy-field target removal; it ought to be consistent.
   *
   * @param idBytes doc ID to find; never a child doc.
   * @param partialDoc partial doc (an in-place update).  Could be a child doc, thus not having idBytes.
   * @return Returns the merged document, i.e. the resolved full document, or null if the document was not found (deleted
   *          after the resolving began).  Never a child doc, since idBytes is never a child doc either.
   */
  private static SolrDocument resolveFullDocument(SolrCore core, BytesRef idBytes,
                                                  ReturnFields returnFields, SolrInputDocument partialDoc,
                                                  @SuppressWarnings({"rawtypes"}) List logEntry) throws IOException {
    Set<String> onlyTheseFields = returnFields.getExplicitlyRequestedFieldNames();
    if (idBytes == null || (logEntry.size() != 5 && logEntry.size() != 6)) {
      throw new SolrException(ErrorCode.INVALID_STATE, "Either Id field not present in partial document or log entry doesn't have previous version.");
    }
    long prevPointer = (long) logEntry.get(UpdateLog.PREV_POINTER_IDX);
    long prevVersion = (long) logEntry.get(UpdateLog.PREV_VERSION_IDX);
    final IndexSchema schema = core.getLatestSchema();

    // get the last full document from ulog
    long lastPrevPointer;
    // If partialDoc is NOT a child doc, then proceed and look into the ulog...
    if (schema.printableUniqueKey(idBytes).equals(schema.printableUniqueKey(partialDoc))) {
      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();
      lastPrevPointer = ulog.applyPartialUpdates(idBytes, prevPointer, prevVersion, onlyTheseFields, partialDoc);
    } else { // child doc.
      // TODO could make this smarter but it's complicated with nested docs
      lastPrevPointer = Long.MAX_VALUE; // results in reopenRealtimeSearcherAndGet
    }

    if (lastPrevPointer == -1) { // full document was not found in tlog, but exists in index
      return mergePartialDocWithFullDocFromIndex(core, idBytes, returnFields, partialDoc);
    } else if (lastPrevPointer > 0) {
      // We were supposed to have found the last full doc also in the tlogs, but the prevPointer links led to nowhere
      // We should reopen a new RT searcher and get the doc. This should be a rare occurrence
      Term idTerm = new Term(schema.getUniqueKeyField().getName(), idBytes);
      SolrDocument mergedDoc = reopenRealtimeSearcherAndGet(core, idTerm, returnFields);
      if (mergedDoc == null) {
        return null; // the document may have been deleted as the resolving was going on.
      }
      return mergedDoc;
    } else { // i.e. lastPrevPointer==0
      assert lastPrevPointer == 0;
      // We have successfully resolved the document based off the tlogs

      // determine whether we can use the in place document, if the caller specified onlyTheseFields
      // and those fields are all supported for in-place updates
      boolean forInPlaceUpdate = onlyTheseFields != null
          && onlyTheseFields.stream().map(schema::getField)
          .allMatch(f -> null!=f && AtomicUpdateDocumentMerger.isSupportedFieldForInPlaceUpdate(f));

      SolrDocument solrDoc = toSolrDoc(partialDoc, schema, forInPlaceUpdate); // filters copy-field targets TODO don't
      DocTransformer transformer = returnFields.getTransformer();
      if (transformer != null && !transformer.needsSolrIndexSearcher()) {
        transformer.transform(solrDoc, -1); // no docId when from the ulog
      } // if needs searcher, it must be [child]; tlog docs already have children
      return solrDoc;
    }
  }

