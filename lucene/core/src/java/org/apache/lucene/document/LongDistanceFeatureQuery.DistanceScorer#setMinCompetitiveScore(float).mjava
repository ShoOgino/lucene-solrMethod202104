    @Override
    public void setMinCompetitiveScore(float minScore) throws IOException {
      if (minScore > boost) {
        it = DocIdSetIterator.empty();
        return;
      }

      // Start sampling if we get called too much
      setMinCompetitiveScoreCounter++;
      if (setMinCompetitiveScoreCounter > 256 && (setMinCompetitiveScoreCounter & 0x1f) != 0x1f) {
        return;
      }

      long previousMaxDistance = maxDistance;
      maxDistance = computeMaxDistance(minScore, maxDistance);
      if (maxDistance == previousMaxDistance) {
        // nothing to update
        return;
      }
      long minValue = origin - maxDistance;
      if (minValue > origin) {
        // underflow
        minValue = Long.MIN_VALUE;
      }
      long maxValue = origin + maxDistance;
      if (maxValue < origin) {
        // overflow
        maxValue = Long.MAX_VALUE;
      }

      final byte[] minValueAsBytes = new byte[Long.BYTES];
      LongPoint.encodeDimension(minValue, minValueAsBytes, 0);
      final byte[] maxValueAsBytes = new byte[Long.BYTES];
      LongPoint.encodeDimension(maxValue, maxValueAsBytes, 0);

      DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);
      final int doc = docID();
      IntersectVisitor visitor =
          new IntersectVisitor() {

            DocIdSetBuilder.BulkAdder adder;

            @Override
            public void grow(int count) {
              adder = result.grow(count);
            }

            @Override
            public void visit(int docID) {
              if (docID <= doc) {
                // Already visited or skipped
                return;
              }
              adder.add(docID);
            }

            @Override
            public void visit(int docID, byte[] packedValue) {
              if (docID <= doc) {
                // Already visited or skipped
                return;
              }
              if (Arrays.compareUnsigned(packedValue, 0, Long.BYTES, minValueAsBytes, 0, Long.BYTES)
                  < 0) {
                // Doc's value is too low, in this dimension
                return;
              }
              if (Arrays.compareUnsigned(packedValue, 0, Long.BYTES, maxValueAsBytes, 0, Long.BYTES)
                  > 0) {
                // Doc's value is too high, in this dimension
                return;
              }

              // Doc is in-bounds
              adder.add(docID);
            }

            @Override
            public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {
              if (Arrays.compareUnsigned(
                          minPackedValue, 0, Long.BYTES, maxValueAsBytes, 0, Long.BYTES)
                      > 0
                  || Arrays.compareUnsigned(
                          maxPackedValue, 0, Long.BYTES, minValueAsBytes, 0, Long.BYTES)
                      < 0) {
                return Relation.CELL_OUTSIDE_QUERY;
              }

              if (Arrays.compareUnsigned(
                          minPackedValue, 0, Long.BYTES, minValueAsBytes, 0, Long.BYTES)
                      < 0
                  || Arrays.compareUnsigned(
                          maxPackedValue, 0, Long.BYTES, maxValueAsBytes, 0, Long.BYTES)
                      > 0) {
                return Relation.CELL_CROSSES_QUERY;
              }

              return Relation.CELL_INSIDE_QUERY;
            }
          };

      final long currentQueryCost = Math.min(leadCost, it.cost());
      final long threshold = currentQueryCost >>> 3;
      long estimatedNumberOfMatches =
          pointValues.estimatePointCount(visitor); // runs in O(log(numPoints))
      // TODO: what is the right factor compared to the current disi? Is 8 optimal?
      if (estimatedNumberOfMatches >= threshold) {
        // the new range is not selective enough to be worth materializing
        return;
      }
      pointValues.intersect(visitor);
      it = result.build().iterator();
    }

