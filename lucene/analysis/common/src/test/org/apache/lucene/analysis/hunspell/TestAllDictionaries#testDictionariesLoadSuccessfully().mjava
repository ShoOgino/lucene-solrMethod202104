  public void testDictionariesLoadSuccessfully() throws Exception {
    AtomicLong totalMemory = new AtomicLong();
    AtomicLong totalWords = new AtomicLong();
    int threads = Runtime.getRuntime().availableProcessors();
    ExecutorService executor =
        Executors.newFixedThreadPool(threads, new NamedThreadFactory("dictCheck-"));
    List<Path> failures = Collections.synchronizedList(new ArrayList<>());
    Function<Path, Void> process =
        (Path aff) -> {
          try {
            Dictionary dic = loadDictionary(aff);
            totalMemory.addAndGet(RamUsageTester.sizeOf(dic));
            totalWords.addAndGet(
                RamUsageTester.sizeOf(dic.words) + RamUsageTester.sizeOf(dic.wordHashes));
            System.out.println(aff + "\t" + memoryUsageSummary(dic));
          } catch (Throwable e) {
            failures.add(aff);
            System.err.println("While checking " + aff + ":");
            e.printStackTrace();
          }
          return null;
        };

    List<Callable<Void>> tasks =
        findAllAffixFiles()
            .map(aff -> (Callable<Void>) () -> process.apply(aff))
            .collect(Collectors.toList());
    try {
      for (Future<?> future : executor.invokeAll(tasks)) {
        future.get();
      }

      if (!failures.isEmpty()) {
        throw new AssertionError(
            "Certain dictionaries failed to parse:\n  - "
                + failures.stream()
                    .map(path -> path.toAbsolutePath().toString())
                    .collect(Collectors.joining("\n  - ")));
      }
    } finally {
      executor.shutdown();
      assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));
    }

    System.out.println("Total dictionaries loaded: " + tasks.size());
    System.out.println("Total memory: " + RamUsageEstimator.humanReadableUnits(totalMemory.get()));
    System.out.println(
        "Total memory for word storage: " + RamUsageEstimator.humanReadableUnits(totalWords.get()));
  }

