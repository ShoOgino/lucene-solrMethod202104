  // LUCENE-5919
  public void testExcInDecRef() throws Throwable {
    MockDirectoryWrapper dir = newMockDirectory();

    // disable slow things: we don't rely upon sleeps here.
    dir.setThrottling(MockDirectoryWrapper.Throttling.NEVER);
    dir.setUseSlowOpenClosers(false);

    final AtomicBoolean doFailExc = new AtomicBoolean();

    dir.failOn(
        new MockDirectoryWrapper.Failure() {
          @Override
          public void eval(MockDirectoryWrapper dir) throws IOException {
            if (doFailExc.get() && random().nextInt(4) == 1) {
              if (callStackContains(IndexFileDeleter.class, "decRef")) {
                throw new RuntimeException("fake fail");
              }
            }
          }
        });

    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));
    // iwc.setMergeScheduler(new SerialMergeScheduler());
    MergeScheduler ms = iwc.getMergeScheduler();
    if (ms instanceof ConcurrentMergeScheduler) {
      final ConcurrentMergeScheduler suppressFakeFail =
          new ConcurrentMergeScheduler() {
            @Override
            protected void handleMergeException(Throwable exc) {
              // suppress only FakeIOException:
              if (exc instanceof RuntimeException && exc.getMessage().equals("fake fail")) {
                // ok to ignore
              } else if ((exc instanceof AlreadyClosedException
                      || exc instanceof IllegalStateException)
                  && exc.getCause() != null
                  && "fake fail".equals(exc.getCause().getMessage())) {
                // also ok to ignore
              } else {
                super.handleMergeException(exc);
              }
            }
          };
      final ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) ms;
      suppressFakeFail.setMaxMergesAndThreads(cms.getMaxMergeCount(), cms.getMaxThreadCount());
      iwc.setMergeScheduler(suppressFakeFail);
    }

    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);

    // Since we hit exc during merging, a partial
    // forceMerge can easily return when there are still
    // too many segments in the index:
    w.setDoRandomForceMergeAssert(false);

    doFailExc.set(true);
    int ITERS = atLeast(1000);
    for (int iter = 0; iter < ITERS; iter++) {
      try {
        if (random().nextInt(10) == 5) {
          w.commit();
        } else if (random().nextInt(10) == 7) {
          w.getReader().close();
        } else {
          Document doc = new Document();
          doc.add(newTextField("field", "some text", Field.Store.NO));
          w.addDocument(doc);
        }
      } catch (Throwable t) {
        if (t.toString().contains("fake fail")
            || (t.getCause() != null && t.getCause().toString().contains("fake fail"))) {
          // ok
        } else {
          throw t;
        }
      }
    }

    doFailExc.set(false);
    w.close();
    dir.close();
  }

