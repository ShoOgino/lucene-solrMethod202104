  public void testRandomExceptionDuringRollback() throws Exception {
    // fail in random places on i/o
    final int numIters = RANDOM_MULTIPLIER * 75;
    for (int iter = 0; iter < numIters; iter++) {
      MockDirectoryWrapper dir = newMockDirectory();
      dir.failOn(new MockDirectoryWrapper.Failure() {
        
        @Override
        public void eval(MockDirectoryWrapper dir) throws IOException {
          if (random().nextInt(10) != 0) {
            return;
          }
          if (callStackContainsAnyOf("rollbackInternal")) {
            if (VERBOSE) {
              System.out.println("TEST: now fail; thread=" + Thread.currentThread().getName() + " exc:");
              new Throwable().printStackTrace(System.out);
            }
            throw new FakeIOException();
          }
        }
      });
      
      IndexWriterConfig iwc = new IndexWriterConfig(null);
      IndexWriter iw = new IndexWriter(dir, iwc);
      Document doc = new Document();
      for (int i = 0; i < 10; i++) {
        iw.addDocument(doc);
      }
      iw.commit();
      
      iw.addDocument(doc);
      
      // pool readers
      DirectoryReader r = DirectoryReader.open(iw);
      
      // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N
      if (random().nextBoolean()) {
        iw.prepareCommit();
      }
      
      try {
        iw.rollback();
      } catch (FakeIOException expected) {
        // ok, we randomly hit exc here
      }
      
      r.close();
      
      // even though we hit exception: we are closed, no locks or files held, index in good state
      assertTrue(iw.isClosed());
      dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();
      
      r = DirectoryReader.open(dir);
      assertEquals(10, r.maxDoc());
      r.close();
      
      // no leaks
      dir.close();
    }
  }

