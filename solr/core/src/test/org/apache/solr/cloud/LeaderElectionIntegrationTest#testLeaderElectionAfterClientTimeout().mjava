  @Test
  public void testLeaderElectionAfterClientTimeout() throws Exception {
    // TODO: work out the best timing here...
    System.setProperty("zkClientTimeout", Integer.toString(ZkTestServer.TICK_TIME * 2 + 100));
    // timeout the leader
    String leader = getLeader();
    int leaderPort = getLeaderPort(leader);
    ZkController zkController = containerMap.get(leaderPort).getZkController();

    zkController.getZkClient().getSolrZooKeeper().closeCnxn();
    long sessionId = zkClient.getSolrZooKeeper().getSessionId();
    zkServer.expire(sessionId);
    
    for (int i = 0; i < 60; i++) { // wait till leader is changed
      if (leaderPort != getLeaderPort(getLeader())) {
        break;
      }
      Thread.sleep(100);
    }
    
    // make sure we have waited long enough for the first leader to have come back
    Thread.sleep(ZkTestServer.TICK_TIME * 2 + 100);
    
    if (VERBOSE) System.out.println("kill everyone");
    // kill everyone but the first leader that should have reconnected by now
    for (Map.Entry<Integer,CoreContainer> entry : containerMap.entrySet()) {
      if (entry.getKey() != leaderPort) {
        entry.getValue().shutdown();
      }
    }

    for (int i = 0; i < 320; i++) { // wait till leader is changed
      try {
        if (leaderPort == getLeaderPort(getLeader())) {
          break;
        }
        Thread.sleep(100);
      } catch (Exception e) {
        continue;
      }
    }

    // the original leader should be leader again now - everyone else is down
    // TODO: I saw this fail once...expected:<7000> but was:<7004>
    assertEquals(leaderPort, getLeaderPort(getLeader()));
    //printLayout(zkServer.getZkAddress());
    //Thread.sleep(100000);
  }

