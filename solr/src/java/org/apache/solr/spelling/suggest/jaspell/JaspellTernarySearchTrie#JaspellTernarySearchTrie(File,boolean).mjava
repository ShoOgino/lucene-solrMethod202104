  /**
   * Constructs a Ternary Search Trie and loads data from a <code>File</code>
   * into the Trie. The file is a normal text document, where each line is of
   * the form "word TAB float".
   * 
   *@param file
   *          The <code>File</code> with the data to load into the Trie.
   *@param compression
   *          If true, the file is compressed with the GZIP algorithm, and if
   *          false, the file is a normal text document.
   *@exception IOException
   *              A problem occured while reading the data.
   */
  public JaspellTernarySearchTrie(File file, boolean compression)
          throws IOException {
    this();
    BufferedReader in;
    if (compression)
      in = new BufferedReader(new InputStreamReader(new GZIPInputStream(
              new FileInputStream(file))));
    else in = new BufferedReader(new InputStreamReader((new FileInputStream(
            file))));
    String word;
    int pos;
    Float occur, one = new Float(1);
    int numWords = 0;
    while ((word = in.readLine()) != null) {
      numWords++;
      pos = word.indexOf("\t");
      occur = one;
      if (pos != -1) {
        occur = Float.parseFloat(word.substring(pos + 1).trim());
        word = word.substring(0, pos);
      }
      String key = word.toLowerCase();
      if (rootNode == null) {
        rootNode = new TSTNode(key.charAt(0), null);
      }
      TSTNode node = null;
      if (key.length() > 0 && rootNode != null) {
        TSTNode currentNode = rootNode;
        int charIndex = 0;
        while (true) {
          if (currentNode == null) break;
          int charComp = compareCharsAlphabetically(key.charAt(charIndex),
                  currentNode.splitchar);
          if (charComp == 0) {
            charIndex++;
            if (charIndex == key.length()) {
              node = currentNode;
              break;
            }
            currentNode = currentNode.relatives[TSTNode.EQKID];
          } else if (charComp < 0) {
            currentNode = currentNode.relatives[TSTNode.LOKID];
          } else {
            currentNode = currentNode.relatives[TSTNode.HIKID];
          }
        }
        Float occur2 = null;
        if (node != null) occur2 = ((Float) (node.data));
        if (occur2 != null) {
          occur += occur2.floatValue();
        }
        currentNode = getOrCreateNode(word.trim().toLowerCase());
        currentNode.data = occur;
      }
    }
    in.close();
  }

