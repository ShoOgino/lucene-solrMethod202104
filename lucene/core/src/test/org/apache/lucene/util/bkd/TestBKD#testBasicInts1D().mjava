  public void testBasicInts1D() throws Exception {
    try (Directory dir = getDirectory(100)) {
      BKDWriter w = new BKDWriter(100, dir, "tmp", new BKDConfig(1, 1, 4, 2), 1.0f, 100);
      byte[] scratch = new byte[4];
      for (int docID = 0; docID < 100; docID++) {
        NumericUtils.intToSortableBytes(docID, scratch, 0);
        w.add(scratch, docID);
      }

      long indexFP;
      try (IndexOutput out = dir.createOutput("bkd", IOContext.DEFAULT)) {
        Runnable finalizer = w.finish(out, out, out);
        indexFP = out.getFilePointer();
        finalizer.run();
      }

      try (IndexInput in = dir.openInput("bkd", IOContext.DEFAULT)) {
        in.seek(indexFP);
        BKDReader r = new BKDReader(in, in, in);

        // Simple 1D range query:
        final int queryMin = 42;
        final int queryMax = 87;

        final BitSet hits = new BitSet();
        r.intersect(
            new IntersectVisitor() {
              @Override
              public void visit(int docID) {
                hits.set(docID);
                if (VERBOSE) {
                  System.out.println("visit docID=" + docID);
                }
              }

              @Override
              public void visit(int docID, byte[] packedValue) {
                int x = NumericUtils.sortableBytesToInt(packedValue, 0);
                if (VERBOSE) {
                  System.out.println("visit docID=" + docID + " x=" + x);
                }
                if (x >= queryMin && x <= queryMax) {
                  hits.set(docID);
                }
              }

              @Override
              public Relation compare(byte[] minPacked, byte[] maxPacked) {
                int min = NumericUtils.sortableBytesToInt(minPacked, 0);
                int max = NumericUtils.sortableBytesToInt(maxPacked, 0);
                assert max >= min;
                if (VERBOSE) {
                  System.out.println(
                      "compare: min="
                          + min
                          + " max="
                          + max
                          + " vs queryMin="
                          + queryMin
                          + " queryMax="
                          + queryMax);
                }

                if (max < queryMin || min > queryMax) {
                  return Relation.CELL_OUTSIDE_QUERY;
                } else if (min >= queryMin && max <= queryMax) {
                  return Relation.CELL_INSIDE_QUERY;
                } else {
                  return Relation.CELL_CROSSES_QUERY;
                }
              }
            });

        for (int docID = 0; docID < 100; docID++) {
          boolean expected = docID >= queryMin && docID <= queryMax;
          boolean actual = hits.get(docID);
          assertEquals("docID=" + docID, expected, actual);
        }
      }
    }
  }

