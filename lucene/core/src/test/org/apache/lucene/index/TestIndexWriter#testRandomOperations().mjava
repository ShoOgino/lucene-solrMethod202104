  public void testRandomOperations() throws Exception {
    IndexWriterConfig iwc = newIndexWriterConfig();
    iwc.setMergePolicy(new FilterMergePolicy(newMergePolicy()) {
      boolean keepFullyDeletedSegment = random().nextBoolean();

      @Override
      public boolean keepFullyDeletedSegment(IOSupplier<CodecReader> readerIOSupplier) {
        return keepFullyDeletedSegment;
      }
    });
    try (Directory dir = newDirectory();
         IndexWriter writer = new IndexWriter(dir, iwc);
         SearcherManager sm = new SearcherManager(writer, new SearcherFactory())) {
      Semaphore numOperations = new Semaphore(10 + random().nextInt(1000));
      boolean singleDoc = random().nextBoolean();
      Thread[] threads = new Thread[1 + random().nextInt(4)];
      CountDownLatch latch = new CountDownLatch(threads.length);
      for (int i = 0; i < threads.length; i++) {
        threads[i] = new Thread(() -> {
          latch.countDown();
          try {
            latch.await();
            while (numOperations.tryAcquire()) {
              String id = singleDoc ? "1" : Integer.toString(random().nextInt(10));
              Document doc = new Document();
              doc.add(new StringField("id", id, Field.Store.YES));
              if (random().nextInt(10) <= 2) {
                writer.updateDocument(new Term("id", id), doc);
              } else if (random().nextInt(10) <= 2) {
                writer.deleteDocuments(new Term("id", id));
              } else {
                writer.addDocument(doc);
              }
              if (random().nextInt(100) < 10) {
                sm.maybeRefreshBlocking();
              }
              if (random().nextInt(100) < 5) {
                writer.commit();
              }
              if (random().nextInt(100) < 1) {
                writer.forceMerge(1 + random().nextInt(10), random().nextBoolean());
              }
            }
          } catch (Exception e) {
            throw new AssertionError(e);
          }
        });
        threads[i].start();
      }
      for (Thread thread : threads) {
        thread.join();
      }
    }
  }

