  public void testDeleteHappensBeforeWhileFlush() throws IOException, InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);
    CountDownLatch inFlush = new CountDownLatch(1);
    try (Directory dir = new FilterDirectory(newDirectory()) {
      @Override
      public IndexOutput createOutput(String name, IOContext context) throws IOException {
        if (callStackContains(DefaultIndexingChain.class, "flush")) {
          try {
            inFlush.countDown();
            latch.await();
          } catch (InterruptedException e) {
            throw new AssertionError(e);
          }
        }
        return super.createOutput(name, context);
      }
    }; IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig())) {
      Document document = new Document();
      document.add(new StringField("id", "1", Field.Store.YES));
      writer.addDocument(document);
      Thread t = new Thread(() -> {
        try {
          inFlush.await();
          writer.docWriter.flushControl.setApplyAllDeletes();
          if (random().nextBoolean()) {
            writer.updateDocument(new Term("id", "1"), document);
          } else {
            writer.deleteDocuments(new Term("id", "1"));
          }

        } catch (Exception e) {
          throw new AssertionError(e);
        } finally {
          latch.countDown();
        }
      });
      t.start();
      try (IndexReader reader = writer.getReader()) {
        assertEquals(1, reader.numDocs());
      };
      t.join();
    }
  }

