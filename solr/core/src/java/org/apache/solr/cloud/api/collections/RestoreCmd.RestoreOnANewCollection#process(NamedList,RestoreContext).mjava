    public void process(@SuppressWarnings("rawtypes") NamedList results, RestoreContext rc) throws Exception {
      // Avoiding passing RestoreContext around
      uploadConfig(rc.backupProperties.getConfigName(),
              rc.restoreConfigName,
              rc.zkStateReader,
              rc.backupManager);

      log.info("Starting restore into collection={} with backup_name={} at location={}", rc.restoreCollectionName, rc.backupName,
              rc.location);
      createCoreLessCollection(rc.restoreCollectionName,
              rc.restoreConfigName,
              rc.backupCollectionState,
              rc.zkStateReader.getClusterState());
      // note: when createCollection() returns, the collection exists (no race)

      // Restore collection properties
      rc.backupManager.uploadCollectionProperties(rc.restoreCollectionName);

      DocCollection restoreCollection = rc.zkStateReader.getClusterState().getCollection(rc.restoreCollectionName);
      markAllShardsAsConstruction(restoreCollection);
      // TODO how do we leverage the RULE / SNITCH logic in createCollection?
      ClusterState clusterState = rc.zkStateReader.getClusterState();

      List<String> sliceNames = new ArrayList<>();
      restoreCollection.getSlices().forEach(x -> sliceNames.add(x.getName()));

      List<ReplicaPosition> replicaPositions = getReplicaPositions(restoreCollection, rc.nodeList, clusterState, sliceNames);

      createSingleReplicaPerShard(results, restoreCollection, rc.asyncId, clusterState, replicaPositions);
      Object failures = results.get("failure");
      if (failures != null && ((SimpleOrderedMap) failures).size() > 0) {
        log.error("Restore failed to create initial replicas.");
        CollectionHandlingUtils.cleanupCollection(rc.restoreCollectionName, new NamedList<>(), ccc);
        return;
      }

      //refresh the location copy of collection state
      restoreCollection = rc.zkStateReader.getClusterState().getCollection(rc.restoreCollectionName);
      requestReplicasToRestore(results, restoreCollection, clusterState, rc.backupProperties, rc.backupPath, rc.repo, rc.shardHandler, rc.asyncId);
      requestReplicasToApplyBufferUpdates(restoreCollection, rc.asyncId, rc.shardHandler);
      markAllShardsAsActive(restoreCollection);
      addReplicasToShards(results, clusterState, restoreCollection, replicaPositions, rc.asyncId);
      restoringAlias(rc.backupProperties);

      log.info("Completed restoring collection={} backupName={}", restoreCollection, rc.backupName);

    }

