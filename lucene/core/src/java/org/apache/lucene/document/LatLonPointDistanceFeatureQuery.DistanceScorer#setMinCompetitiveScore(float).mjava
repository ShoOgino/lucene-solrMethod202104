    @Override
    public void setMinCompetitiveScore(float minScore) throws IOException {
      if (minScore > boost) {
        it = DocIdSetIterator.empty();
        return;
      }

      setMinCompetitiveScoreCounter++;
      // We sample the calls to this method as it is expensive to recalculate the iterator.
      if (setMinCompetitiveScoreCounter > 256 && (setMinCompetitiveScoreCounter & 0x1f) != 0x1f) {
        return;
      }

      double previousMaxDistance = maxDistance;
      maxDistance = computeMaxDistance(minScore, maxDistance);
      if (maxDistance == previousMaxDistance) {
        // nothing to update
        return;
      }

      // Ideally we would be doing a distance query but that is too expensive so we approximate
      // with a box query which performs better.
      Rectangle box = Rectangle.fromPointDistance(originLat, originLon, maxDistance);
      final byte minLat[] = new byte[LatLonPoint.BYTES];
      final byte maxLat[] = new byte[LatLonPoint.BYTES];
      final byte minLon[] = new byte[LatLonPoint.BYTES];
      final byte maxLon[] = new byte[LatLonPoint.BYTES];
      final boolean crossDateLine = box.crossesDateline();

      NumericUtils.intToSortableBytes(GeoEncodingUtils.encodeLatitude(box.minLat), minLat, 0);
      NumericUtils.intToSortableBytes(GeoEncodingUtils.encodeLatitude(box.maxLat), maxLat, 0);
      NumericUtils.intToSortableBytes(GeoEncodingUtils.encodeLongitude(box.minLon), minLon, 0);
      NumericUtils.intToSortableBytes(GeoEncodingUtils.encodeLongitude(box.maxLon), maxLon, 0);

      DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);
      final int doc = docID();
      IntersectVisitor visitor =
          new IntersectVisitor() {

            DocIdSetBuilder.BulkAdder adder;

            @Override
            public void grow(int count) {
              adder = result.grow(count);
            }

            @Override
            public void visit(int docID) {
              if (docID <= doc) {
                // Already visited or skipped
                return;
              }
              adder.add(docID);
            }

            @Override
            public void visit(int docID, byte[] packedValue) {
              if (docID <= doc) {
                // Already visited or skipped
                return;
              }
              if (Arrays.compareUnsigned(
                          packedValue, 0, LatLonPoint.BYTES, maxLat, 0, LatLonPoint.BYTES)
                      > 0
                  || Arrays.compareUnsigned(
                          packedValue, 0, LatLonPoint.BYTES, minLat, 0, LatLonPoint.BYTES)
                      < 0) {
                // Latitude out of range
                return;
              }
              if (crossDateLine) {
                if (Arrays.compareUnsigned(
                            packedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            minLon,
                            0,
                            LatLonPoint.BYTES)
                        < 0
                    && Arrays.compareUnsigned(
                            packedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            maxLon,
                            0,
                            LatLonPoint.BYTES)
                        > 0) {
                  // Longitude out of range
                  return;
                }

              } else {
                if (Arrays.compareUnsigned(
                            packedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            maxLon,
                            0,
                            LatLonPoint.BYTES)
                        > 0
                    || Arrays.compareUnsigned(
                            packedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            minLon,
                            0,
                            LatLonPoint.BYTES)
                        < 0) {
                  // Longitude out of range
                  return;
                }
              }
              adder.add(docID);
            }

            @Override
            public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {

              if (Arrays.compareUnsigned(
                          minPackedValue, 0, LatLonPoint.BYTES, maxLat, 0, LatLonPoint.BYTES)
                      > 0
                  || Arrays.compareUnsigned(
                          maxPackedValue, 0, LatLonPoint.BYTES, minLat, 0, LatLonPoint.BYTES)
                      < 0) {
                return Relation.CELL_OUTSIDE_QUERY;
              }
              boolean crosses =
                  Arrays.compareUnsigned(
                              minPackedValue, 0, LatLonPoint.BYTES, minLat, 0, LatLonPoint.BYTES)
                          < 0
                      || Arrays.compareUnsigned(
                              maxPackedValue, 0, LatLonPoint.BYTES, maxLat, 0, LatLonPoint.BYTES)
                          > 0;

              if (crossDateLine) {
                if (Arrays.compareUnsigned(
                            minPackedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            maxLon,
                            0,
                            LatLonPoint.BYTES)
                        > 0
                    && Arrays.compareUnsigned(
                            maxPackedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            minLon,
                            0,
                            LatLonPoint.BYTES)
                        < 0) {
                  return Relation.CELL_OUTSIDE_QUERY;
                }
                crosses |=
                    Arrays.compareUnsigned(
                                minPackedValue,
                                LatLonPoint.BYTES,
                                2 * LatLonPoint.BYTES,
                                maxLon,
                                0,
                                LatLonPoint.BYTES)
                            < 0
                        || Arrays.compareUnsigned(
                                maxPackedValue,
                                LatLonPoint.BYTES,
                                2 * LatLonPoint.BYTES,
                                minLon,
                                0,
                                LatLonPoint.BYTES)
                            > 0;

              } else {
                if (Arrays.compareUnsigned(
                            minPackedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            maxLon,
                            0,
                            LatLonPoint.BYTES)
                        > 0
                    || Arrays.compareUnsigned(
                            maxPackedValue,
                            LatLonPoint.BYTES,
                            2 * LatLonPoint.BYTES,
                            minLon,
                            0,
                            LatLonPoint.BYTES)
                        < 0) {
                  return Relation.CELL_OUTSIDE_QUERY;
                }
                crosses |=
                    Arrays.compareUnsigned(
                                minPackedValue,
                                LatLonPoint.BYTES,
                                2 * LatLonPoint.BYTES,
                                minLon,
                                0,
                                LatLonPoint.BYTES)
                            < 0
                        || Arrays.compareUnsigned(
                                maxPackedValue,
                                LatLonPoint.BYTES,
                                2 * LatLonPoint.BYTES,
                                maxLon,
                                0,
                                LatLonPoint.BYTES)
                            > 0;
              }
              if (crosses) {
                return Relation.CELL_CROSSES_QUERY;
              } else {
                return Relation.CELL_INSIDE_QUERY;
              }
            }
          };

      final long currentQueryCost = Math.min(leadCost, it.cost());
      final long threshold = currentQueryCost >>> 3;
      long estimatedNumberOfMatches =
          pointValues.estimatePointCount(visitor); // runs in O(log(numPoints))
      // TODO: what is the right factor compared to the current disi? Is 8 optimal?
      if (estimatedNumberOfMatches >= threshold) {
        // the new range is not selective enough to be worth materializing
        return;
      }
      pointValues.intersect(visitor);
      it = result.build().iterator();
    }

