  /*
   * This test is trying to hard-delete a particular document while the segment is merged which is already soft-deleted
   * This requires special logic inside IndexWriter#carryOverHardDeletes since docMaps are not created for this document.
   */
  public void testDeleteDocWhileMergeThatIsSoftDeleted() throws IOException {
    Directory dir = newDirectory();
    String softDelete = "soft_delete";
    IndexWriterConfig config = newIndexWriterConfig().setSoftDeletesField(softDelete);
    AtomicBoolean delete = new AtomicBoolean(true);
    config.setReaderPooling(true);
    config.setMergePolicy(new LogDocMergePolicy());
    IndexWriter writer = new IndexWriter(dir, config);
    Document d = new Document();
    d.add(new StringField("id", "0", Field.Store.YES));
    writer.addDocument(d);
    d = new Document();
    d.add(new StringField("id", "1", Field.Store.YES));
    writer.addDocument(d);
    if (random().nextBoolean()) {
      // randomly run with a preexisting hard delete
      d = new Document();
      d.add(new StringField("id", "2", Field.Store.YES));
      writer.addDocument(d);
      writer.deleteDocuments(new Term("id", "2"));
    }

    writer.flush();
    DirectoryReader reader = writer.getReader();
    writer.softUpdateDocument(new Term("id", "0"), new Document(),
        new NumericDocValuesField(softDelete, 1));
    writer.flush();
    writer.getConfig().setMergedSegmentWarmer(sr -> {
      if (delete.compareAndSet(true, false)) {
        try {
          long seqNo = writer.tryDeleteDocument(reader, 0);
          assertTrue("seqId was -1", seqNo !=  -1);
        } catch (IOException e) {
          throw new AssertionError(e);
        }
      }
    });
    writer.forceMerge(1);
    assertEquals(2, writer.getDocStats().numDocs);
    assertEquals(2, writer.getDocStats().maxDoc);
    assertFalse(delete.get());
    IOUtils.close(reader, writer, dir);
  }

