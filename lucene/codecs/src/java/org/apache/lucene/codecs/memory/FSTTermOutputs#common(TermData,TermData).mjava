  @Override
  //
  // The return value will be the smaller one, when these two are 
  // 'comparable', i.e. 
  // 1. every value in t1 is not larger than in t2, or
  // 2. every value in t1 is not smaller than t2.
  //
  public TermData common(TermData t1, TermData t2) {
    //if (TEST) System.out.print("common("+t1+", "+t2+") = ");
    if (t1 == NO_OUTPUT || t2 == NO_OUTPUT) {
      //if (TEST) System.out.println("ret:"+NO_OUTPUT);
      return NO_OUTPUT;
    }
    assert t1.longs.length == t2.longs.length;

    long[] min = t1.longs, max = t2.longs;
    int pos = 0;
    TermData ret;

    while (pos < longsSize && min[pos] == max[pos]) {
      pos++;
    }
    if (pos < longsSize) {  // unequal long[]
      if (min[pos] > max[pos]) {
        min = t2.longs;
        max = t1.longs;
      }
      // check whether strictly smaller
      while (pos < longsSize && min[pos] <= max[pos]) {
        pos++;
      }
      if (pos < longsSize || allZero(min)) {  // not comparable or all-zero
        ret = NO_OUTPUT;
      } else {
        ret = new TermData(min, null, 0, -1);
      }
    } else {  // equal long[]
      if (statsEqual(t1, t2) && bytesEqual(t1, t2)) {
        ret = t1;
      } else if (allZero(min)) {
        ret = NO_OUTPUT;
      } else {
        ret = new TermData(min, null, 0, -1);
      }
    }
    //if (TEST) System.out.println("ret:"+ret);
    return ret;
  }

