    // main entry point for printing collections
    @SuppressWarnings("unchecked")
    void printPaginatedCollections() throws IOException {
      SortedMap<String, Object> collectionStates;
      try {
        // support paging of the collections graph view (in case there are many collections)
        // fetch the requested page of collections and then retrieve the state for each
        pagingSupport.fetchPage(page, zkClient);
        // keep track of how many collections match the filter
        boolean applyStatusFilter = (page.filterType == FilterType.status && page.filter != null);
        List<String> matchesStatusFilter = applyStatusFilter ? new ArrayList<>() : null;
        ClusterState cs = zkController.getZkStateReader().getClusterState();
        Set<String> liveNodes = applyStatusFilter ? cs.getLiveNodes() : null;

        collectionStates = new TreeMap<>(pagingSupport);
        for (String collection : page.selected) {
          DocCollection dc = cs.getCollectionOrNull(collection);
          if (dc != null) {
            // TODO: for collections with perReplicaState, a ser/deser to JSON was needed to get the state to render correctly for the UI?
            @SuppressWarnings("unchecked")
            Map<String, Object> collectionState = dc.isPerReplicaState() ? (Map<String, Object>)Utils.fromJSONString(Utils.toJSONString(dc)) : dc.getProperties();
            if (applyStatusFilter) {
              // verify this collection matches the filtered state
              if (page.matchesStatusFilter(collectionState, liveNodes)) {
                matchesStatusFilter.add(collection);
                collectionStates.put(collection, ClusterStatus.postProcessCollectionJSON(collectionState));
              }
            } else {
              collectionStates.put(collection, ClusterStatus.postProcessCollectionJSON(collectionState));
            }
          }
        }

        if (applyStatusFilter) {
          // update the paged navigation info after applying the status filter
          page.selectPage(matchesStatusFilter);

          // rebuild the Map of state data
          SortedMap<String, Object> map = new TreeMap<String, Object>(pagingSupport);
          for (String next : page.selected)
            map.put(next, collectionStates.get(next));
          collectionStates = map;
        }
      } catch (KeeperException | InterruptedException e) {
        writeError(500, e.toString());
        return;
      }

      CharArr chars = new CharArr();
      JSONWriter json = new JSONWriter(chars, 2);
      json.startObject();

      json.writeString("znode");
      json.writeNameSeparator();
      json.startObject();

      // For some reason, without this the Json is badly formed
      writeKeyValue(json, PATH, "Undefined", true);

      if (collectionStates != null) {
        CharArr collectionOut = new CharArr();
        new JSONWriter(collectionOut, 2).write(collectionStates);
        writeKeyValue(json, "data", collectionOut.toString(), false);
      }

      writeKeyValue(json, "paging", page.getPagingHeader(), false);

      json.endObject();
      json.endObject();
      out.write(chars.toString());
    }

