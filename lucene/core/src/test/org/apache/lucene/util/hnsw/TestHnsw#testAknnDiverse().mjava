  // Make sure we actually approximately find the closest k elements. Mostly this is about
  // ensuring that we have all the distance functions, comparators, priority queues and so on
  // oriented in the right directions
  public void testAknnDiverse() throws IOException {
    int nDoc = 100;
    CircularVectorValues vectors = new CircularVectorValues(nDoc);
    HnswGraphBuilder builder = new HnswGraphBuilder(vectors, 16, 100, random().nextInt());
    HnswGraph hnsw = builder.build(vectors);
    // run some searches
    NeighborQueue nn =
        HnswGraph.search(new float[] {1, 0}, 10, 5, vectors.randomAccess(), hnsw, random());
    int sum = 0;
    for (int node : nn.nodes()) {
      sum += node;
    }
    // We expect to get approximately 100% recall; the lowest docIds are closest to zero; sum(0,9) =
    // 45
    assertTrue("sum(result docs)=" + sum, sum < 75);
    for (int i = 0; i < nDoc; i++) {
      NeighborArray neighbors = hnsw.getNeighbors(i);
      int[] nodes = neighbors.node;
      for (int j = 0; j < neighbors.size(); j++) {
        // all neighbors should be valid node ids.
        assertTrue(nodes[j] < nDoc);
      }
    }
  }

