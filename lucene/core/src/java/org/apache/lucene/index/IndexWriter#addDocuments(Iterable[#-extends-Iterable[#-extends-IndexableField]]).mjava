  /**
   * Atomically adds a block of documents with sequentially assigned document IDs, such that an
   * external reader will see all or none of the documents.
   *
   * <p><b>WARNING</b>: the index does not currently record which documents were added as a block.
   * Today this is fine, because merging will preserve a block. The order of documents within a
   * segment will be preserved, even when child documents within a block are deleted. Most search
   * features (like result grouping and block joining) require you to mark documents; when these
   * documents are deleted these search features will not work as expected. Obviously adding
   * documents to an existing block will require you the reindex the entire block.
   *
   * <p>However it's possible that in the future Lucene may merge more aggressively re-order
   * documents (for example, perhaps to obtain better index compression), in which case you may need
   * to fully re-index your documents at that time.
   *
   * <p>See {@link #addDocument(Iterable)} for details on index and IndexWriter state after an
   * Exception, and flushing/merging temporary free space requirements.
   *
   * <p><b>NOTE</b>: tools that do offline splitting of an index (for example, IndexSplitter in
   * contrib) or re-sorting of documents (for example, IndexSorter in contrib) are not aware of
   * these atomically added documents and will likely break them up. Use such tools at your own
   * risk!
   *
   * @return The <a href="#sequence_number">sequence number</a> for this operation
   * @throws CorruptIndexException if the index is corrupt
   * @throws IOException if there is a low-level IO error
   * @lucene.experimental
   */
  public long addDocuments(Iterable<? extends Iterable<? extends IndexableField>> docs)
      throws IOException {
    return updateDocuments((DocumentsWriterDeleteQueue.Node<?>) null, docs);
  }

