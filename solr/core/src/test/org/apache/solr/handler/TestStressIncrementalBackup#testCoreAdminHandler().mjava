    public void testCoreAdminHandler() throws Exception {
        final int numBackupIters = 20; // don't use 'atLeast', we don't want to blow up on nightly

        final AtomicReference<Throwable> heavyCommitFailure = new AtomicReference<>();
        final AtomicBoolean keepGoing = new AtomicBoolean(true);

        // this thread will do nothing but add/commit new 'dummy' docs over and over again as fast as possible
        // to create a lot of index churn w/ segment merging
        final Thread heavyCommitting = new Thread() {
            public void run() {
                try {
                    int docIdCounter = 0;
                    while (keepGoing.get()) {
                        docIdCounter++;

                        final UpdateRequest req = new UpdateRequest().add(makeDoc("dummy_" + docIdCounter, "dummy"));
                        // always commit to force lots of new segments
                        req.setParam(UpdateParams.COMMIT,"true");
                        req.setParam(UpdateParams.OPEN_SEARCHER,"false");           // we don't care about searching

                        // frequently forceMerge to ensure segments are frequently deleted
                        if (0 == (docIdCounter % 13)) {                             // arbitrary
                            req.setParam(UpdateParams.OPTIMIZE, "true");
                            req.setParam(UpdateParams.MAX_OPTIMIZE_SEGMENTS, "5");    // arbitrary
                        }

                        log.info("Heavy Committing #{}: {}", docIdCounter, req);
                        final UpdateResponse rsp = req.process(coreClient);
                        assertEquals("Dummy Doc#" + docIdCounter + " add status: " + rsp.toString(), 0, rsp.getStatus());

                    }
                } catch (Throwable t) {
                    heavyCommitFailure.set(t);
                }
            }
        };

        heavyCommitting.start();
        try {
            // now have the "main" test thread try to take a serious of backups/snapshots
            // while adding other "real" docs

            // NOTE #1: start at i=1 for 'id' & doc counting purposes...
            // NOTE #2: abort quickly if the oher thread reports a heavyCommitFailure...
            for (int i = 1; (i <= numBackupIters && null == heavyCommitFailure.get()); i++) {

                // in each iteration '#i', the commit we create should have exactly 'i' documents in
                // it with the term 'type_s:real' (regardless of what the other thread does with dummy docs)

                // add & commit a doc #i
                final UpdateRequest req = new UpdateRequest().add(makeDoc("doc_" + i, "real"));
                req.setParam(UpdateParams.COMMIT,"true"); // make immediately available for backup
                req.setParam(UpdateParams.OPEN_SEARCHER,"false"); // we don't care about searching

                final UpdateResponse rsp = req.process(coreClient);
                assertEquals("Real Doc#" + i + " add status: " + rsp.toString(), 0, rsp.getStatus());

                makeBackup();
            }

        } finally {
            keepGoing.set(false);
            heavyCommitting.join();
        }
        assertNull(heavyCommitFailure.get());
    }

