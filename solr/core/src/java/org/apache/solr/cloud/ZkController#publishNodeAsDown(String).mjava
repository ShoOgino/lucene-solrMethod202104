  /**
   * Best effort to set DOWN state for all replicas on node.
   *
   * @param nodeName to operate on
   */
  public void publishNodeAsDown(String nodeName) {
    log.info("Publish node={} as DOWN", nodeName);
    if (distributedClusterStateUpdater.isDistributedStateUpdate()) {
      // Note that with the current implementation, when distributed cluster state updates are enabled, we mark the node
      // down synchronously from this thread, whereas the Overseer cluster state update frees this thread right away and
      // the Overseer will async mark the node down but updating all affected collections.
      // If this is an issue (i.e. takes too long), then the call below should be executed from another thread so that
      // the calling thread can immediately return.
      distributedClusterStateUpdater.executeNodeDownStateUpdate(nodeName, zkStateReader);
    } else {
      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, OverseerAction.DOWNNODE.toLower(),
          ZkStateReader.NODE_NAME_PROP, nodeName);
      try {
        overseer.getStateUpdateQueue().offer(Utils.toJSON(m));
      } catch (AlreadyClosedException e) {
        log.info("Not publishing node as DOWN because a resource required to do so is already closed.");
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.debug("Publish node as down was interrupted.");
      } catch (KeeperException e) {
        log.warn("Could not publish node as down: ", e);
      }
    }
  }

