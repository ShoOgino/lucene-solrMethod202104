  /**
   * At initialization (each doc), each repetition group is sorted by (query) offset. This provides
   * the start condition: no collisions.
   *
   * <p>Case 1: no multi-term repeats<br>
   * It is sufficient to advance each pp in the group by one less than its group index. So lesser pp
   * is not advanced, 2nd one advance once, 3rd one advanced twice, etc.
   *
   * <p>Case 2: multi-term repeats<br>
   *
   * @return false if PPs are exhausted.
   */
  private boolean advanceRepeatGroups() throws IOException {
    for (PhrasePositions[] rg : rptGroups) {
      if (hasMultiTermRpts) {
        // more involved, some may not collide
        int incr;
        for (int i = 0; i < rg.length; i += incr) {
          incr = 1;
          PhrasePositions pp = rg[i];
          int k;
          while ((k = collide(pp)) >= 0) {
            PhrasePositions pp2 = lesser(pp, rg[k]);
            if (!advancePP(pp2)) { // at initialization always advance pp with higher offset
              return false; // exhausted
            }
            if (pp2.rptInd < i) { // should not happen?
              incr = 0;
              break;
            }
          }
        }
      } else {
        // simpler, we know exactly how much to advance
        for (int j = 1; j < rg.length; j++) {
          for (int k = 0; k < j; k++) {
            if (!rg[j].nextPosition()) {
              return false; // PPs exhausted
            }
          }
        }
      }
    }
    return true; // PPs available
  }

