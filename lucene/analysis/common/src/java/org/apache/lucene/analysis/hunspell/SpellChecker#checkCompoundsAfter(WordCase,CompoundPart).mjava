  private boolean checkCompoundsAfter(WordCase originalCase, CompoundPart prev) {
    CharsRef word = prev.tail;
    int breakPos = prev.length;
    int remainingLength = word.length - breakPos;
    int breakOffset = word.offset + breakPos;
    Root<CharsRef> tailStem =
        findStem(word.chars, breakOffset, remainingLength, originalCase, COMPOUND_END);
    if (tailStem != null
        && !dictionary.hasFlag(tailStem.entryId, dictionary.forbiddenword)
        && !(dictionary.checkCompoundDup && equalsIgnoreCase(prev.stem, tailStem.word))
        && !hasForceUCaseProblem(word.chars, breakOffset, remainingLength, originalCase)
        && prev.mayCompound(tailStem, remainingLength, originalCase)) {
      return true;
    }

    CharsRef tail = new CharsRef(word.chars, breakOffset, remainingLength);
    return checkCompounds(tail, originalCase, prev);
  }

