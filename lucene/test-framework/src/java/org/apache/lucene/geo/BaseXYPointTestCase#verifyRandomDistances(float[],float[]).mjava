  protected void verifyRandomDistances(float[] xs, float[] ys) throws Exception {
    IndexWriterConfig iwc = newIndexWriterConfig();
    // Else seeds may not reproduce:
    iwc.setMergeScheduler(new SerialMergeScheduler());
    // Else we can get O(N^2) merging:
    int mbd = iwc.getMaxBufferedDocs();
    if (mbd != -1 && mbd < xs.length/100) {
      iwc.setMaxBufferedDocs(xs.length/100);
    }
    Directory dir;
    if (xs.length > 100000) {
      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));
    } else {
      dir = newDirectory();
    }

    Set<Integer> deleted = new HashSet<>();
    // RandomIndexWriter is too slow here:
    IndexWriter w = new IndexWriter(dir, iwc);
    indexPoints(xs, ys, deleted, w);
    final IndexReader r = DirectoryReader.open(w);
    w.close();

    IndexSearcher s = newSearcher(r);

    int iters = atLeast(25);

    Bits liveDocs = MultiBits.getLiveDocs(s.getIndexReader());
    int maxDoc = s.getIndexReader().maxDoc();

    for (int iter=0;iter<iters;iter++) {

      if (VERBOSE) {
        System.out.println("\nTEST: iter=" + iter + " s=" + s);
      }

      // Distance
      final float centerX = nextX();
      final float centerY = nextY();

      // So the query can cover at most 50% of the cartesian space:
      final float radius = random().nextFloat() * Float.MAX_VALUE / 2;

      if (VERBOSE) {
        final DecimalFormat df = new DecimalFormat("#,###.00", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
        System.out.println("  radius = " + df.format(radius));
      }

      Query query = newDistanceQuery(FIELD_NAME, centerX, centerY, radius);

      if (VERBOSE) {
        System.out.println("  query=" + query);
      }

      final FixedBitSet hits = searchIndex(s, query, maxDoc);

      boolean fail = false;
      NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, "id");
      for(int docID=0;docID<maxDoc;docID++) {
        assertEquals(docID, docIDToID.nextDoc());
        int id = (int) docIDToID.longValue();
        boolean expected;
        if (liveDocs != null && liveDocs.get(docID) == false) {
          // document is deleted
          expected = false;
        } else if (Float.isNaN(xs[id]) || Float.isNaN(ys[id])) {
          expected = false;
        } else {
          expected = cartesianDistance(centerX, centerY, xs[id], ys[id]) <= radius;
        }

        if (hits.get(docID) != expected) {
          Consumer<StringBuilder> explain = (b) -> {
            if (Double.isNaN(xs[id]) == false) {
              double distance = cartesianDistance(centerX, centerY, xs[id], ys[id]);
              b.append("  centerX=").append(centerX).append(" centerY=").append(centerY).append(" distance=")
                      .append(distance).append(" vs radius=").append(radius);
            }
          };
          buildError(docID, expected, id, xs, ys, query, liveDocs, explain);
          fail = true;
        }
      }
      if (fail) {
        fail("some hits were wrong");
      }
    }

    IOUtils.close(r, dir);
  }

