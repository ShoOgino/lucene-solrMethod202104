  public void testInequalityPayloadChecks() throws Exception {
    // searching for the term five with a payload of either "pos: 0" or a payload of "pos: 1"
    SpanQuery termFive = new SpanTermQuery(new Term("field", "five"));
    SpanQuery termFifty = new SpanTermQuery(new Term("field", "fifty"));
    BytesRef payloadZero = new BytesRef("pos: " + 0);
    BytesRef payloadOne = new BytesRef("pos: " + 1);
    BytesRef payloadTwo = new BytesRef("pos: " + 2);
    BytesRef payloadThree = new BytesRef("pos: " + 3);
    BytesRef payloadFour = new BytesRef("pos: " + 4);
    BytesRef payloadFive = new BytesRef("pos: " + 5);
    // Terms that equal five with a payload of "pos: 1"
    SpanQuery stringEQ1 =
        new SpanPayloadCheckQuery(
            termFive,
            Collections.singletonList(payloadOne),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.EQ);
    checkHits(stringEQ1, new int[] {25, 35, 45, 55, 65, 75, 85, 95});

    // These queries return the same thing
    SpanQuery stringLT =
        new SpanPayloadCheckQuery(
            termFive,
            Collections.singletonList(payloadOne),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.LT);
    SpanQuery stringLTE =
        new SpanPayloadCheckQuery(
            termFive,
            Collections.singletonList(payloadZero),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.LTE);
    // string less than and string less than or equal
    checkHits(
        stringLT,
        new int[] {
          5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516,
          517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534,
          535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552,
          553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570,
          571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588,
          589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599
        });
    checkHits(
        stringLTE,
        new int[] {
          5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516,
          517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534,
          535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552,
          553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570,
          571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588,
          589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599
        });
    // greater than and greater than or equal tests.
    SpanQuery stringGT =
        new SpanPayloadCheckQuery(
            termFive,
            Collections.singletonList(payloadFour),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.GT);
    SpanQuery stringGTE =
        new SpanPayloadCheckQuery(
            termFive,
            Collections.singletonList(payloadFive),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.GTE);
    checkHits(
        stringGT,
        new int[] {
          1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285,
          1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475,
          1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665,
          1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855,
          1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995
        });
    checkHits(
        stringGTE,
        new int[] {
          1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285,
          1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475,
          1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665,
          1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855,
          1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995
        });

    // now a not so happy path...
    SpanQuery stringEQ2many =
        new SpanPayloadCheckQuery(
            termFive,
            Arrays.asList(payloadOne, payloadZero),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.EQ);
    // fewer terms than payloads should not match anything, one wonders if this should be an error,
    // but it's been explicitly ignored previously, so changing it is a possible back compat issue.
    checkHits(stringEQ2many, new int[] {});

    // now some straight forward two term cases...
    SpanQuery stringEQ2 =
        new SpanPayloadCheckQuery(
            new SpanNearQuery(new SpanQuery[] {termFifty, termFive}, 0, true),
            Arrays.asList(payloadZero, payloadOne),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.EQ);
    checkHits(stringEQ2, new int[] {55});

    SpanQuery stringGT2 =
        new SpanPayloadCheckQuery(
            new SpanNearQuery(new SpanQuery[] {termFifty, termFive}, 0, true),
            Arrays.asList(payloadZero, payloadOne),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.GT);
    checkHits(
        stringGT2,
        new int[] { // spotless:off
                 155,  255,  355,  455,  555,  655,  755,  855,  955,
          1055, 1155, 1255, 1355, 1455, 1555, 1655, 1755, 1855, 1955
        }); // spotless:on
    SpanQuery stringGTE2 =
        new SpanPayloadCheckQuery(
            new SpanNearQuery(new SpanQuery[] {termFifty, termFive}, 0, true),
            Arrays.asList(payloadZero, payloadOne),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.GTE);
    checkHits(
        stringGTE2,
        new int[] { // spotless:off
            55,  155,  255,  355,  455,  555,  655,  755,  855,  955,
          1055, 1155, 1255, 1355, 1455, 1555, 1655, 1755, 1855, 1955
        });  // spotless:on

    SpanQuery stringLT2 =
        new SpanPayloadCheckQuery(
            new SpanNearQuery(new SpanQuery[] {termFifty, termFive}, 0, true),
            Arrays.asList(payloadTwo, payloadThree),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.LT);
    checkHits(stringLT2, new int[] {55});
    SpanQuery stringLTE2 =
        new SpanPayloadCheckQuery(
            new SpanNearQuery(new SpanQuery[] {termFifty, termFive}, 0, true),
            Arrays.asList(payloadTwo, payloadThree),
            SpanPayloadCheckQuery.PayloadType.STRING,
            MatchOperation.LTE);
    checkHits(stringLTE2, new int[] {55, 155, 255, 355, 455, 555, 655, 755, 855, 955, 1055});

    // note: I can imagine support for SpanOrQuery might be interesting but that's for some other
    // time, currently such support is  made intractable by the fact that reset() gets called and
    // sets "upto" back to zero between SpanOrQuery subclauses.
  }

