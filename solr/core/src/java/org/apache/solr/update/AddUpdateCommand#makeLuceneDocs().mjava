  /**
   * Computes the final flattened Lucene docs, possibly generating them on-demand (on iteration).
   * The SolrInputDocument itself may be modified, which will be reflected in the update log.
   * This should only be called once.
   * Any changes made to the returned Document(s) will not be reflected in the SolrInputDocument,
   * or future calls to this method.
   */
  Iterable<Document> makeLuceneDocs() {
    // perhaps this should move to UpdateHandler or DocumentBuilder?
    assert ! isInPlaceUpdate() : "We don't expect this to happen."; // but should "work"?
    if (!req.getSchema().isUsableForChildDocs()) {
      // note if the doc is nested despite this, we'll throw an exception elsewhere
      final boolean forInPlaceUpdate = false;
      final boolean ignoreNestedDocs = false; // throw an exception if found
      Document doc = DocumentBuilder.toDocument(solrDoc, req.getSchema(), forInPlaceUpdate, ignoreNestedDocs);
      return Collections.singleton(doc);
    }

    List<SolrInputDocument> all = flatten(solrDoc);

    final String rootId = getIndexedIdStr();
    final SolrInputField versionSif = solrDoc.get(CommonParams.VERSION_FIELD);

    for (SolrInputDocument sdoc : all) {
      addRootField(sdoc, rootId);
      if (versionSif != null) {
        addVersionField(sdoc, versionSif);
      }
      // TODO: if possible concurrent modification exception (if SolrInputDocument not cloned and is being forwarded to replicas)
      // then we could add this field to the generated lucene document instead.
    }

    return () -> all.stream().map(sdoc -> DocumentBuilder.toDocument(sdoc, req.getSchema())).iterator();
  }

