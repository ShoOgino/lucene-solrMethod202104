  /**
   * Runs a query with two MTQs and confirms the formatter can tell which query matched which hit.
   */
  public void testWhichMTQMatched() throws Exception {
    RandomIndexWriter iw = new RandomIndexWriter(random(), dir, indexAnalyzer);

    Field body = new Field("body", "", fieldType);
    Document doc = new Document();
    doc.add(body);

    body.setStringValue("Test a one sentence document.");
    iw.addDocument(doc);

    IndexReader ir = iw.getReader();
    iw.close();

    IndexSearcher searcher = newSearcher(ir);
    UnifiedHighlighter highlighter = randomUnifiedHighlighter(searcher, indexAnalyzer);
    // use a variety of common MTQ types
    BooleanQuery query =
        new BooleanQuery.Builder()
            .add(new PrefixQuery(new Term("body", "te")), BooleanClause.Occur.SHOULD)
            .add(new WildcardQuery(new Term("body", "*one*")), BooleanClause.Occur.SHOULD)
            .add(new FuzzyQuery(new Term("body", "zentence~")), BooleanClause.Occur.SHOULD)
            .build();
    TopDocs topDocs = searcher.search(query, 10, Sort.INDEXORDER);
    assertEquals(1, topDocs.totalHits.value);
    String snippets[] = highlighter.highlight("body", query, topDocs);
    assertEquals(1, snippets.length);

    // Default formatter just bolds each hit:
    assertEquals("<b>Test</b> a <b>one</b> <b>sentence</b> document.", snippets[0]);

    // Now use our own formatter, that also stuffs the
    // matching term's text into the result:
    highlighter =
        new UnifiedHighlighter(searcher, indexAnalyzer) {

          @Override
          protected PassageFormatter getFormatter(String field) {
            return new PassageFormatter() {

              @Override
              public Object format(Passage passages[], String content) {
                // Copied from DefaultPassageFormatter, but
                // tweaked to include the matched term:
                StringBuilder sb = new StringBuilder();
                int pos = 0;
                for (Passage passage : passages) {
                  // don't add ellipsis if its the first one, or if its connected.
                  if (passage.getStartOffset() > pos && pos > 0) {
                    sb.append("... ");
                  }
                  pos = passage.getStartOffset();
                  for (int i = 0; i < passage.getNumMatches(); i++) {
                    int start = passage.getMatchStarts()[i];
                    int end = passage.getMatchEnds()[i];
                    // its possible to have overlapping terms
                    if (start > pos) {
                      sb.append(content, pos, start);
                    }
                    if (end > pos) {
                      sb.append("<b>");
                      sb.append(content, Math.max(pos, start), end);
                      sb.append('(');
                      sb.append(passage.getMatchTerms()[i].utf8ToString());
                      sb.append(')');
                      sb.append("</b>");
                      pos = end;
                    }
                  }
                  // its possible a "term" from the analyzer could span a sentence boundary.
                  sb.append(content, pos, Math.max(pos, passage.getEndOffset()));
                  pos = passage.getEndOffset();
                }
                return sb.toString();
              }
            };
          }
        };

    assertEquals(1, topDocs.totalHits.value);
    snippets = highlighter.highlight("body", query, topDocs);
    assertEquals(1, snippets.length);

    assertEquals(
        "<b>Test(body:te*)</b> a <b>one(body:*one*)</b> <b>sentence(body:zentence~~2)</b> document.",
        snippets[0]);

    ir.close();
  }

