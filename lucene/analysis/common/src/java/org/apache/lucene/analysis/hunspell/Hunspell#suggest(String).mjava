  public List<String> suggest(String word) {
    checkCanceled.run();
    if (word.length() >= 100) return Collections.emptyList();

    if (dictionary.needsInputCleaning) {
      word = dictionary.cleanInput(word, new StringBuilder()).toString();
    }

    WordCase wordCase = WordCase.caseOf(word);
    if (dictionary.forceUCase != FLAG_UNSET && wordCase == WordCase.LOWER) {
      String title = dictionary.toTitleCase(word);
      if (spell(title)) {
        return Collections.singletonList(title);
      }
    }

    Hunspell suggestionSpeller =
        new Hunspell(dictionary, checkCanceled) {
          @Override
          boolean acceptsStem(int formID) {
            return !dictionary.hasFlag(formID, dictionary.noSuggest)
                && !dictionary.hasFlag(formID, dictionary.subStandard);
          }
        };
    ModifyingSuggester modifier = new ModifyingSuggester(suggestionSpeller);
    Set<String> suggestions = modifier.suggest(word, wordCase);

    if (!modifier.hasGoodSuggestions && dictionary.maxNGramSuggestions > 0) {
      suggestions.addAll(
          new GeneratingSuggester(suggestionSpeller)
              .suggest(dictionary.toLowerCase(word), wordCase, suggestions));
    }

    if (word.contains("-") && suggestions.stream().noneMatch(s -> s.contains("-"))) {
      suggestions.addAll(modifyChunksBetweenDashes(word));
    }

    Set<String> result = new LinkedHashSet<>();
    for (String candidate : suggestions) {
      result.add(adjustSuggestionCase(candidate, wordCase, word));
      if (wordCase == WordCase.UPPER && dictionary.checkSharpS && candidate.contains("ÃŸ")) {
        result.add(candidate);
      }
    }
    return result.stream().map(this::cleanOutput).collect(Collectors.toList());
  }

