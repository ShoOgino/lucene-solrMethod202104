  private NumericDocValues getNumeric(NumericEntry entry) throws IOException {
    if (entry.docsWithFieldOffset == -2) {
      // empty
      return DocValues.emptyNumeric();
    } else if (entry.docsWithFieldOffset == -1) {
      // dense
      if (entry.bitsPerValue == 0) {
        return new DenseNumericDocValues(maxDoc) {
          @Override
          public long longValue() throws IOException {
            return entry.minValue;
          }
        };
      } else {
        final RandomAccessInput slice =
            data.randomAccessSlice(entry.valuesOffset, entry.valuesLength);
        if (entry.blockShift >= 0) {
          // dense but split into blocks of different bits per value
          final int shift = entry.blockShift;
          final long mul = entry.gcd;
          final int mask = (1 << shift) - 1;
          return new DenseNumericDocValues(maxDoc) {
            int block = -1;
            long delta;
            long offset;
            long blockEndOffset;
            LongValues values;

            @Override
            public long longValue() throws IOException {
              final int block = doc >>> shift;
              if (this.block != block) {
                int bitsPerValue;
                do {
                  offset = blockEndOffset;
                  bitsPerValue = slice.readByte(offset++);
                  delta = slice.readLong(offset);
                  offset += Long.BYTES;
                  if (bitsPerValue == 0) {
                    blockEndOffset = offset;
                  } else {
                    final int length = slice.readInt(offset);
                    offset += Integer.BYTES;
                    blockEndOffset = offset + length;
                  }
                  this.block++;
                } while (this.block != block);
                values =
                    bitsPerValue == 0
                        ? LongValues.ZEROES
                        : DirectReader.getInstance(slice, bitsPerValue, offset);
              }
              return mul * values.get(doc & mask) + delta;
            }
          };
        } else {
          final LongValues values = DirectReader.getInstance(slice, entry.bitsPerValue);
          if (entry.table != null) {
            final long[] table = entry.table;
            return new DenseNumericDocValues(maxDoc) {
              @Override
              public long longValue() throws IOException {
                return table[(int) values.get(doc)];
              }
            };
          } else {
            final long mul = entry.gcd;
            final long delta = entry.minValue;
            return new DenseNumericDocValues(maxDoc) {
              @Override
              public long longValue() throws IOException {
                return mul * values.get(doc) + delta;
              }
            };
          }
        }
      }
    } else {
      // sparse
      final IndexedDISI disi =
          new IndexedDISI(
              data, entry.docsWithFieldOffset, entry.docsWithFieldLength, entry.numValues);
      if (entry.bitsPerValue == 0) {
        return new SparseNumericDocValues(disi) {
          @Override
          public long longValue() throws IOException {
            return entry.minValue;
          }
        };
      } else {
        final RandomAccessInput slice =
            data.randomAccessSlice(entry.valuesOffset, entry.valuesLength);
        if (entry.blockShift >= 0) {
          // sparse and split into blocks of different bits per value
          final int shift = entry.blockShift;
          final long mul = entry.gcd;
          final int mask = (1 << shift) - 1;
          return new SparseNumericDocValues(disi) {
            int block = -1;
            long delta;
            long offset;
            long blockEndOffset;
            LongValues values;

            @Override
            public long longValue() throws IOException {
              final int index = disi.index();
              final int block = index >>> shift;
              if (this.block != block) {
                int bitsPerValue;
                do {
                  offset = blockEndOffset;
                  bitsPerValue = slice.readByte(offset++);
                  delta = slice.readLong(offset);
                  offset += Long.BYTES;
                  if (bitsPerValue == 0) {
                    blockEndOffset = offset;
                  } else {
                    final int length = slice.readInt(offset);
                    offset += Integer.BYTES;
                    blockEndOffset = offset + length;
                  }
                  this.block++;
                } while (this.block != block);
                values =
                    bitsPerValue == 0
                        ? LongValues.ZEROES
                        : DirectReader.getInstance(slice, bitsPerValue, offset);
              }
              return mul * values.get(index & mask) + delta;
            }
          };
        } else {
          final LongValues values = DirectReader.getInstance(slice, entry.bitsPerValue);
          if (entry.table != null) {
            final long[] table = entry.table;
            return new SparseNumericDocValues(disi) {
              @Override
              public long longValue() throws IOException {
                return table[(int) values.get(disi.index())];
              }
            };
          } else {
            final long mul = entry.gcd;
            final long delta = entry.minValue;
            return new SparseNumericDocValues(disi) {
              @Override
              public long longValue() throws IOException {
                return mul * values.get(disi.index()) + delta;
              }
            };
          }
        }
      }
    }
  }

