  private static long handleOther(
      Accumulator accumulator,
      IdentityHashMap<Class<?>, ClassCache> classCache,
      ArrayList<Object> stack,
      Object ob,
      Class<?> obClazz) {
    /*
     * Consider an object. Push any references it has to the processing stack
     * and accumulate this object's shallow size.
     */
    try {
      if (Constants.JRE_IS_MINIMUM_JAVA9) {
        long alignedShallowInstanceSize = RamUsageEstimator.shallowSizeOf(ob);

        Predicate<Class<?>> isJavaModule =
            (clazz) -> {
              return clazz.getName().startsWith("java.");
            };

        // Java 9: Best guess for some known types, as we cannot precisely look into runtime
        // classes:
        final ToLongFunction<Object> func = SIMPLE_TYPES.get(obClazz);
        if (func
            != null) { // some simple type like String where the size is easy to get from public
          // properties
          return accumulator.accumulateObject(
              ob, alignedShallowInstanceSize + func.applyAsLong(ob), Collections.emptyMap(), stack);
        } else if (ob instanceof Enum) {
          return alignedShallowInstanceSize;
        } else if (ob instanceof ByteBuffer) {
          // Approximate ByteBuffers with their underlying storage (ignores field overhead).
          return byteArraySize(((ByteBuffer) ob).capacity());
        } else if (isJavaModule.test(obClazz) && ob instanceof Map) {
          final List<Object> values =
              ((Map<?, ?>) ob)
                  .entrySet().stream()
                      .flatMap(e -> Stream.of(e.getKey(), e.getValue()))
                      .collect(Collectors.toList());
          return accumulator.accumulateArray(
                  ob,
                  alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER,
                  values,
                  stack)
              + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;
        } else if (isJavaModule.test(obClazz) && ob instanceof Iterable) {
          final List<Object> values =
              StreamSupport.stream(((Iterable<?>) ob).spliterator(), false)
                  .collect(Collectors.toList());
          return accumulator.accumulateArray(
                  ob,
                  alignedShallowInstanceSize + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER,
                  values,
                  stack)
              + RamUsageEstimator.NUM_BYTES_ARRAY_HEADER;
        } else {
          // Fallback to reflective access.
        }
      }

      ClassCache cachedInfo = classCache.get(obClazz);
      if (cachedInfo == null) {
        classCache.put(obClazz, cachedInfo = createCacheEntry(obClazz));
      }

      final Map<Field, Object> fieldValues = new HashMap<>();
      for (Field f : cachedInfo.referenceFields) {
        fieldValues.put(f, f.get(ob));
      }
      return accumulator.accumulateObject(
          ob, cachedInfo.alignedShallowInstanceSize, fieldValues, stack);
    } catch (IllegalAccessException e) {
      // this should never happen as we enabled setAccessible().
      throw new RuntimeException("Reflective field access failed?", e);
    }
  }

