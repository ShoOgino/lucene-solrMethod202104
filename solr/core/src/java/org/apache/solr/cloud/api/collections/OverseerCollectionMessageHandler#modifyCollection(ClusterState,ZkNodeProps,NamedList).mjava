  void modifyCollection(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({"rawtypes"})NamedList results)
      throws Exception {

    final String collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);
    //the rest of the processing is based on writing cluster state properties
    //remove the property here to avoid any errors down the pipeline due to this property appearing
    String configName = (String) message.getProperties().remove(CollectionAdminParams.COLL_CONF);

    if(configName != null) {
      validateConfigOrThrowSolrException(configName);

      createConfNode(cloudManager.getDistribStateManager(), configName, collectionName);
      reloadCollection(null, new ZkNodeProps(NAME, collectionName), results);
    }

    if (distributedClusterStateUpdater.isDistributedStateUpdate()) {
      // Apply the state update right away. The wait will still be useful for the change to be visible in the local cluster state (watchers have fired).
      distributedClusterStateUpdater.doSingleStateUpdate(DistributedClusterStateUpdater.MutatingCommand.CollectionModifyCollection, message,
          cloudManager, zkStateReader);
    } else {
      overseer.offerStateUpdate(Utils.toJSON(message));
    }

    try {
      zkStateReader.waitForState(collectionName, 30, TimeUnit.SECONDS, c -> {
        if (c == null) return false;

        for (Map.Entry<String,Object> updateEntry : message.getProperties().entrySet()) {
          String updateKey = updateEntry.getKey();

          if (!updateKey.equals(ZkStateReader.COLLECTION_PROP)
                  && !updateKey.equals(Overseer.QUEUE_OPERATION)
                  && updateEntry.getValue() != null // handled below in a separate conditional
                  && !updateEntry.getValue().equals(c.get(updateKey))) {
            return false;
          }
          if (updateEntry.getValue() == null && c.containsKey(updateKey)) {
            return false;
          }
        }

        return true;
      });
    } catch (TimeoutException | InterruptedException e) {
      SolrZkClient.checkInterrupted(e);
      log.debug("modifyCollection(ClusterState={}, ZkNodeProps={}, NamedList={})", clusterState, message, results, e);
      throw new SolrException(ErrorCode.SERVER_ERROR, "Failed to modify collection", e);
    }

    // if switching to/from read-only mode reload the collection
    if (message.keySet().contains(ZkStateReader.READ_ONLY)) {
      reloadCollection(null, new ZkNodeProps(NAME, collectionName), results);
    }
  }

