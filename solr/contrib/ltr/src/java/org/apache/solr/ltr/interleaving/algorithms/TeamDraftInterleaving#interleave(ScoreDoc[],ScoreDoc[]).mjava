  /**
   * Team Draft Interleaving considers two ranking models: modelA and modelB.
   * For a given query, each model returns its ranked list of documents La = (a1,a2,...) and Lb = (b1, b2, ...).
   * The algorithm creates a unique ranked list I = (i1, i2, ...).
   * This list is created by interleaving elements from the two lists la and lb as described by Chapelle et al.[1].
   * Each element Ij is labelled TeamA if it is selected from La and TeamB if it is selected from Lb.
   * <p>
   * [1] O. Chapelle, T. Joachims, F. Radlinski, and Y. Yue.
   * Large-scale validation and analysis of interleaved search evaluation. ACM TOIS, 30(1):1â€“41, Feb. (2012)
   * <p>
   * Assumptions:
   * - rerankedA and rerankedB has the same length.
   * They contains the same search results, ranked differently by two ranking models
   * - each reranked list can not contain the same search result more than once.
   * - results are all from the same shard
   *
   * @param rerankedA a ranked list of search results produced by a ranking model A
   * @param rerankedB a ranked list of search results produced by a ranking model B
   * @return the interleaved ranking list
   */
  public InterleavingResult interleave(ScoreDoc[] rerankedA, ScoreDoc[] rerankedB) {
    LinkedList<ScoreDoc> interleavedResults = new LinkedList<>();
    HashSet<Integer> alreadyAdded = new HashSet<>();
    ScoreDoc[] interleavedResultArray = new ScoreDoc[rerankedA.length];
    ArrayList<Set<Integer>> interleavingPicks = new ArrayList<>(2);
    Set<Integer> teamA = new HashSet<>();
    Set<Integer> teamB = new HashSet<>();
    int topN = rerankedA.length;
    int indexA = 0, indexB = 0;

    while (interleavedResults.size() < topN && indexA < rerankedA.length && indexB < rerankedB.length) {
      if(teamA.size()<teamB.size() || (teamA.size()==teamB.size() && !RANDOM.nextBoolean())){
        indexA = updateIndex(alreadyAdded, indexA, rerankedA);
        interleavedResults.add(rerankedA[indexA]);
        alreadyAdded.add(rerankedA[indexA].doc);
        teamA.add(rerankedA[indexA].doc);
        indexA++;
      } else{
        indexB = updateIndex(alreadyAdded,indexB,rerankedB);
        interleavedResults.add(rerankedB[indexB]);
        alreadyAdded.add(rerankedB[indexB].doc);
        teamB.add(rerankedB[indexB].doc);
        indexB++;
      }
    }
    interleavingPicks.add(teamA);
    interleavingPicks.add(teamB);
    interleavedResultArray = interleavedResults.toArray(interleavedResultArray);

    return new InterleavingResult(interleavedResultArray,interleavingPicks);
  }

