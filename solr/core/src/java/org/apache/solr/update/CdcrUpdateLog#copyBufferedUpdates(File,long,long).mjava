  /**
   * <p>
   *   Read the entries from the given tlog file and replay them as buffered updates.
   *   The buffered tlog that we are trying to copy might contain duplicate operations with the
   *   current update log. During the tlog replication process, the replica might buffer update operations
   *   that will be present also in the tlog files downloaded from the leader. In order to remove these
   *   duplicates, it will skip any operations with a version inferior to the latest know version.
   */
  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {
    recoveryInfo = new RecoveryInfo();
    state = State.BUFFERING;

    ModifiableSolrParams params = new ModifiableSolrParams();
    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());
    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);

    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);
    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);
    try {
      int operationAndFlags = 0;
      for (; ; ) {
        Object o = tlogReader.next();
        if (o == null) break; // we reached the end of the tlog
        // should currently be a List<Oper,Ver,Doc/Id>
        @SuppressWarnings({"rawtypes"})
        List entry = (List) o;
        operationAndFlags = (Integer) entry.get(0);
        int oper = operationAndFlags & OPERATION_MASK;
        long version = (Long) entry.get(1);
        if (version <= latestVersion) {
          // probably a buffered update that is also present in a tlog file coming from the leader,
          // skip it.
          log.debug("Dropping buffered operation - version {} < {}", version, latestVersion);
          continue;
        }

        switch (oper) {
          case UpdateLog.ADD: {
            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);
            AddUpdateCommand cmd = new AddUpdateCommand(req);
            cmd.solrDoc = sdoc;
            cmd.setVersion(version);
            cmd.setFlags(UpdateCommand.BUFFERING);
            this.add(cmd);
            break;
          }
          case UpdateLog.DELETE: {
            byte[] idBytes = (byte[]) entry.get(2);
            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);
            cmd.setIndexedId(new BytesRef(idBytes));
            cmd.setVersion(version);
            cmd.setFlags(UpdateCommand.BUFFERING);
            this.delete(cmd);
            break;
          }

          case UpdateLog.DELETE_BY_QUERY: {
            String query = (String) entry.get(2);
            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);
            cmd.query = query;
            cmd.setVersion(version);
            cmd.setFlags(UpdateCommand.BUFFERING);
            this.deleteByQuery(cmd);
            break;
          }

          default:
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Invalid Operation! " + oper);
        }

      }
    }
    catch (Exception e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unable to copy buffered updates", e);
    }
    finally {
      try {
        tlogReader.close();
      }
      finally {
        this.doClose(src);
      }
    }
  }

