  /**
   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}
   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true
   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have
   * different semantics.
   * <p>
   * Sub-classes should override this method to provide their own range query implementation. They should strive to
   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.
   *
   * @param parser       the {@link org.apache.solr.search.QParser} calling the method
   * @param field        the schema field
   * @param part1        the lower boundary of the range, nulls are allowed.
   * @param part2        the upper boundary of the range, nulls are allowed
   * @param minInclusive whether the minimum of the range is inclusive or not
   * @param maxInclusive whether the maximum of the range is inclusive or not
   *  @return a Query instance to perform range search according to given parameters
   *
   */
  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {
    // TODO: change these all to use readableToIndexed/bytes instead (e.g. for unicode collation)
    if (field.hasDocValues() && !field.indexed()) {
      if (field.multiValued()) {
        return new ConstantScoreQuery(DocTermOrdsRangeFilter.newBytesRefRange(
            field.getName(),
            part1 == null ? null : new BytesRef(toInternal(part1)),
            part2 == null ? null : new BytesRef(toInternal(part2)),
            minInclusive, maxInclusive));
      } else {
        return new ConstantScoreQuery(DocValuesRangeFilter.newStringRange(
            field.getName(), 
            part1 == null ? null : toInternal(part1),
            part2 == null ? null : toInternal(part2),
            minInclusive, maxInclusive));
      }
    } else {
      MultiTermQuery rangeQuery = TermRangeQuery.newStringRange(
            field.getName(),
            part1 == null ? null : toInternal(part1),
            part2 == null ? null : toInternal(part2),
            minInclusive, maxInclusive);
      rangeQuery.setRewriteMethod(getRewriteMethod(parser, field));
      return rangeQuery;
    }
  }

