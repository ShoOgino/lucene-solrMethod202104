  public ZkWriteCommand setShardLeader(ClusterState clusterState, ZkNodeProps message) {
    String leaderUrl = ZkCoreNodeProps.getCoreUrl(message);
    String collectionName = message.getStr(ZkStateReader.COLLECTION_PROP);
    String sliceName = message.getStr(ZkStateReader.SHARD_ID_PROP);
    DocCollection coll = clusterState.getCollectionOrNull(collectionName);

    if (coll == null) {
      log.error("Could not mark shard leader for non existing collection: {}", collectionName);
      return ZkStateWriter.NO_OP;
    }

    Map<String, Slice> slices = coll.getSlicesMap();
    Slice slice = slices.get(sliceName);

    Replica oldLeader = slice.getLeader();
    Replica newLeader = null;
    final Map<String, Replica> newReplicas = new LinkedHashMap<>();
    for (Replica replica : slice.getReplicas()) {
      // TODO: this should only be calculated once and cached somewhere?
      String coreURL = ZkCoreNodeProps.getCoreUrl(replica.getBaseUrl(), replica.getStr(ZkStateReader.CORE_NAME_PROP));

      if (replica == oldLeader && !coreURL.equals(leaderUrl)) {
        replica = new ReplicaMutator(cloudManager).unsetLeader(replica);
      } else if (coreURL.equals(leaderUrl)) {
        newLeader = replica = new ReplicaMutator(cloudManager).setLeader(replica);
      }

      newReplicas.put(replica.getName(), replica);
    }

    Map<String, Object> newSliceProps = slice.shallowCopy();
    newSliceProps.put(Slice.REPLICAS, newReplicas);
    slice = new Slice(slice.getName(), newReplicas, slice.getProperties(), collectionName);
    if (coll.isPerReplicaState()) {
      PerReplicaStates prs = PerReplicaStates.fetch(coll.getZNode(), zkClient, coll.getPerReplicaStates());
      return new ZkWriteCommand(collectionName, CollectionMutator.updateSlice(collectionName, coll, slice),
          PerReplicaStatesOps.flipLeader(
              slice.getReplicaNames(),
              newLeader == null ? null : newLeader.getName(),
              prs), false);
    } else {
      return new ZkWriteCommand(collectionName, CollectionMutator.updateSlice(collectionName, coll, slice));
    }
  }

