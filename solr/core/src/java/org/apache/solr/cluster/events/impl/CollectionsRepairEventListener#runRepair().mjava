  private void runRepair() {
    if (nodeNameVsTimeRemoved.isEmpty()) {
      // nothing to do
      return;
    }
    if (log.isDebugEnabled()) {
      log.debug("-- runRepair for {} lost nodes", nodeNameVsTimeRemoved.size());
    }
    Set<String> reallyLostNodes = new HashSet<>();
    nodeNameVsTimeRemoved.forEach((lostNode, timeRemoved) -> {
      long now = solrCloudManager.getTimeSource().getTimeNs();
      long te = TimeUnit.SECONDS.convert(now - timeRemoved, TimeUnit.NANOSECONDS);
      if (te >= waitForSecond) {
        reallyLostNodes.add(lostNode);
      }
    });
    if (reallyLostNodes.isEmpty()) {
      if (log.isDebugEnabled()) {
        log.debug("--- skipping repair, {} nodes are still in waitFor period", nodeNameVsTimeRemoved.size());
      }
      return;
    } else {
      if (log.isDebugEnabled()) {
        log.debug("--- running repair for nodes that are still lost after waitFor: {}", reallyLostNodes);
      }
    }
    // collect all lost replicas
    // collection / positions
    Map<String, List<ReplicaPosition>> newPositions = new HashMap<>();
    try {
      ClusterState clusterState = solrCloudManager.getClusterStateProvider().getClusterState();
      clusterState.forEachCollection(coll -> {
        // shard / type / count
        Map<String, Map<Replica.Type, AtomicInteger>> lostReplicas = new HashMap<>();
        coll.forEachReplica((shard, replica) -> {
          if (reallyLostNodes.contains(replica.getNodeName())) {
            lostReplicas.computeIfAbsent(shard, s -> new HashMap<>())
                .computeIfAbsent(replica.type, t -> new AtomicInteger())
                .incrementAndGet();
          }
        });
        Assign.AssignStrategy assignStrategy = Assign.createAssignStrategy(placementPluginFactory.createPluginInstance(), clusterState, coll);
        lostReplicas.forEach((shard, types) -> {
          Assign.AssignRequestBuilder assignRequestBuilder = new Assign.AssignRequestBuilder()
              .forCollection(coll.getName())
              .forShard(Collections.singletonList(shard));
          types.forEach((type, count) -> {
            switch (type) {
              case NRT:
                assignRequestBuilder.assignNrtReplicas(count.get());
                break;
              case PULL:
                assignRequestBuilder.assignPullReplicas(count.get());
                break;
              case TLOG:
                assignRequestBuilder.assignTlogReplicas(count.get());
                break;
            }
          });
          Assign.AssignRequest assignRequest = assignRequestBuilder.build();
          try {
            List<ReplicaPosition> positions = assignStrategy.assign(solrCloudManager, assignRequest);
            newPositions.put(coll.getName(), positions);
          } catch (Exception e) {
            log.warn("Exception computing positions for {}/{}: {}", coll.getName(), shard, e);
          }
        });
      });
    } catch (IOException e) {
      log.warn("Exception getting cluster state", e);
      return;
    }

    // remove all nodes with expired waitFor from the tracking set
    nodeNameVsTimeRemoved.keySet().removeAll(reallyLostNodes);

    // send ADDREPLICA admin requests for each lost replica
    // XXX should we use 'async' for that, to avoid blocking here?
    List<CollectionAdminRequest.AddReplica> addReplicas = new ArrayList<>();
    newPositions.forEach((collection, positions) -> positions.forEach(position -> {
      CollectionAdminRequest.AddReplica addReplica = CollectionAdminRequest
          .addReplicaToShard(collection, position.shard, position.type);
      addReplica.setNode(position.node);
      addReplica.setAsyncId(ASYNC_ID_PREFIX + counter.incrementAndGet());
      addReplicas.add(addReplica);
    }));
    addReplicas.forEach(addReplica -> {
      try {
        solrClient.request(addReplica);
      } catch (Exception e) {
        log.warn("Exception calling ADDREPLICA {}: {}", addReplica.getParams().toQueryString(), e);
      }
    });
  }

