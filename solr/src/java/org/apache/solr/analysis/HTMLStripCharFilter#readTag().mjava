  private int readTag() throws IOException {
    // at this point '<' has already been read
    int ch = next();
    if (!isAlpha(ch)) {
      push(ch);
      return MISMATCH;
    }

    sb.setLength(0);
    sb.append((char)ch);
    while((numRead - lastMark) < safeReadAheadLimit) {

      ch = next();
      if (isIdChar(ch)) {
        sb.append((char)ch);
      } else if (ch=='/') {
        // Hmmm, a tag can close with "/>" as well as "/ >"
        // read end tag '/>' or '/ >', etc
        return nextSkipWS()=='>' ? MATCH : MISMATCH;
      } else {
        break;
      }
    }
    if (escapedTags!=null && escapedTags.contains(sb.toString())){
      //if this is a reservedTag, then keep it
      return MISMATCH;
    }
    // After the tag id, there needs to be either whitespace or
    // '>'
    if ( !(ch=='>' || isSpace(ch)) ) {
      return MISMATCH;
    }

    if (ch!='>') {
      // process attributes
      while ((numRead - lastMark) < safeReadAheadLimit) {
        ch=next();
        if (isSpace(ch)) {
          continue;
        } else if (isFirstIdChar(ch)) {
          push(ch);
          int ret = readAttr2();
          if (ret==MISMATCH) return ret;
        } else if (ch=='/') {
          // read end tag '/>' or '/ >', etc
          return nextSkipWS()=='>' ? MATCH : MISMATCH;
        } else if (ch=='>') {
          break;
        } else {
          return MISMATCH;
        }

      }
      if ((numRead - lastMark) >= safeReadAheadLimit){
        return MISMATCH;//exit out if we exceeded the buffer
      }
    }

    // We only get to this point after we have read the
    // entire tag.  Now let's see if it's a special tag.
    String name=sb.toString();
    if (name.equalsIgnoreCase("script") || name.equalsIgnoreCase("style")) {
     // The content of script and style elements is
     //  CDATA in HTML 4 but PCDATA in XHTML.

     /* From HTML4:
       Although the STYLE and SCRIPT elements use CDATA for their data model,
       for these elements, CDATA must be handled differently by user agents.
       Markup and entities must be treated as raw text and passed to the application
       as is. The first occurrence of the character sequence "</" (end-tag open
       delimiter) is treated as terminating the end of the element's content. In
       valid documents, this would be the end tag for the element.
      */

     // discard everything until endtag is hit (except
     // if it occurs in a comment.

     // reset the stream mark to here, since we know that we sucessfully matched
     // a tag, and if we can't find the end tag, this is where we will want
     // to roll back to.
     saveState();
     pushed.setLength(0);
     return findEndTag();
    }
    return MATCH;
  }

