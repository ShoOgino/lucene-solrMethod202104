  public void testSimple() throws Exception {
    
    { // convert our docs to update commands, along with some commits, in a shuffled order and process all of them...
      final List<String> updates = Stream.concat(Stream.of(commit()),
                                                 makeBlockDocs().stream().map(doc -> adoc(doc))).collect(Collectors.toList());
      Collections.shuffle(updates, random());
      for (String u : updates) {
        assertU(u);
      }
      assertU(commit());
    }
    
    for (String opt : Arrays.asList(// no block collapse logic used (sanity checks)
                                    "field=block_s1",            
                                    "field=block_i",             
                                    // block collapse used implicitly (ord)
                                    "field=_root_",
                                    "field=_root_ hint=top_fc",             // top_fc hint shouldn't matter
                                    // block collapse used explicitly (ord)
                                    "field=_root_ hint=block",
                                    "field=block_s1 hint=block",
                                    // block collapse used explicitly (int)
                                    "field=block_i  hint=block"  
                                    )) {
      
      { // score based group head selection (default)
      
        // these permutations should all give the same results, since the queries don't match any docs in 'null' groups
        // (because we don't have any in our index)...
        for (String nullPolicy : Arrays.asList("", // ignore is default
                                               " nullPolicy=ignore",
                                               " nullPolicy=expand")) { 
          for (String q : Arrays.asList("txt_t:XX",             // only child docs with XX match
                                        "txt_t:* txt_t:XX",     // all child docs match
                                        "*:* txt_t:XX")) {      // all docs match

            // single score based collapse...
            assertQ(req("q", q,
                        "fq", "{!collapse " + opt + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1]/str[@name='id'][.='p2s4']"
                    , "//result/doc[2]/str[@name='id'][.='p3s1']"
                    , "//result/doc[3]/str[@name='id'][.='p1s3']"
                    );

            // same query, but boosting a diff p1 sku to change group head (and result order)
            assertQ(req("q", q,
                        "qt", "/elevate",
                        "elevateIds", "p1s1",
                        "fq", "{!collapse " + opt + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1]/str[@name='id'][.='p1s1']"
                    , "//result/doc[2]/str[@name='id'][.='p2s4']"
                    , "//result/doc[3]/str[@name='id'][.='p3s1']"
                    );
            
            // same query, but boosting multiple skus from p1
            assertQ(req("q", q,
                        "qt", "/elevate",
                        "elevateIds", "p1s1,p1s2",
                        "fq", "{!collapse " + opt + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=4]"
                    , "//result/doc[1]/str[@name='id'][.='p1s1']"
                    , "//result/doc[2]/str[@name='id'][.='p1s2']"
                    , "//result/doc[3]/str[@name='id'][.='p2s4']"
                    , "//result/doc[4]/str[@name='id'][.='p3s1']"
                    );
          }

          { // use func query to assert expected scores
            assertQ(req("q", "{!func}sum(42, num_i)",
                        "fq", "{!collapse " + opt + nullPolicy + "}",
                        "fl","score,id",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1][str[@name='id'][.='p3s3'] and float[@name='score'][.=1276.0]]"
                    , "//result/doc[2][str[@name='id'][.='p1s3'] and float[@name='score'][.=819.0]]"
                    , "//result/doc[3][str[@name='id'][.='p2s3'] and float[@name='score'][.=141.0]]"
                    );
            // same query, but boosting a diff child to change group head (and result order)
            assertQ(req("q", "{!func}sum(42, num_i)",
                        "qt", "/elevate",
                        "elevateIds", "p1s1",
                        "fq", "{!collapse " + opt + nullPolicy + "}",
                        "fl","score,id",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1][str[@name='id'][.='p1s1'] and float[@name='score'][.=84.0]]"
                    , "//result/doc[2][str[@name='id'][.='p3s3'] and float[@name='score'][.=1276.0]]"
                    , "//result/doc[3][str[@name='id'][.='p2s3'] and float[@name='score'][.=141.0]]"
                    );
            // same query, but boosting multiple skus from p1
            assertQ(req("q", "{!func}sum(42, num_i)",
                        "qt", "/elevate",
                        "elevateIds", "p1s2,p1s1",
                        "fq", "{!collapse " + opt + nullPolicy + "}",
                        "fl","score,id",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=4]"
                    , "//result/doc[1][str[@name='id'][.='p1s2'] and float[@name='score'][.=52.0]]"
                    , "//result/doc[2][str[@name='id'][.='p1s1'] and float[@name='score'][.=84.0]]"
                    , "//result/doc[3][str[@name='id'][.='p3s3'] and float[@name='score'][.=1276.0]]"
                    , "//result/doc[4][str[@name='id'][.='p2s3'] and float[@name='score'][.=141.0]]"
                    );
          }
        }
        
      } // score 


      // sort and min/max  based group head selection
      for (String suffix : SELECTOR_FIELD_SUFFIXES) {

        // these permutations should all give the same results, since the queries don't match any docs in 'null' groups
        // (because we don't have any in our index)...
        for (String nullPolicy : Arrays.asList("", // ignore is default
                                               " nullPolicy=ignore",
                                               " nullPolicy=expand")) {
          
          // queries that are relevancy based...
          for (String selector : Arrays.asList(" sort='asc" + suffix + " asc'",
                                               " sort='sum(asc" + suffix + ",42) asc'",
                                               " max=desc" + suffix,
                                               " min=asc" + suffix,
                                               " min='sum(asc" + suffix + ", 42)'")) {
            
            if (selector.endsWith("_l") && opt.endsWith("_i")) {
              // NOTE: this limitation doesn't apply to block collapse on int,
              // so we only check 'opt.endsWith' (if ends with block hint we're ok)
              assertQEx("expected known limitation of using long for min/max selector when doing numeric collapse",
                        "min/max must be Int or Float",
                        req("q", "*:*",
                            "fq", "{!collapse " + opt + nullPolicy + selector + "}"),
                        SolrException.ErrorCode.BAD_REQUEST);
              continue;
            }

            assertQ(req("q","txt_t:XX",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1]/str[@name='id'][.='p2s4']"
                    , "//result/doc[2]/str[@name='id'][.='p3s4']"
                    , "//result/doc[3]/str[@name='id'][.='p1s4']"
                    );
            assertQ(req("q","txt_t:* txt_t:XX",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1]/str[@name='id'][.='p3s4']"
                    , "//result/doc[2]/str[@name='id'][.='p1s4']"
                    , "//result/doc[3]/str[@name='id'][.='p2s2']"
                    );
            // same query, but boosting skus to change group head (and result order)
            assertQ(req("q","txt_t:* txt_t:XX",
                        "qt", "/elevate",
                        "elevateIds", "p2s3,p1s1",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1]/str[@name='id'][.='p2s3']"
                    , "//result/doc[2]/str[@name='id'][.='p1s1']"
                    , "//result/doc[3]/str[@name='id'][.='p3s4']"
                    );
            // same query, but boosting multiple skus from p1
            assertQ(req("q","txt_t:* txt_t:XX",
                        "qt", "/elevate",
                        "elevateIds", "p2s3,p1s4,p1s3",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "sort", "score desc, num_i asc")
                    , "*[count(//doc)=4]"
                    , "//result/doc[1]/str[@name='id'][.='p2s3']"
                    , "//result/doc[2]/str[@name='id'][.='p1s4']"
                    , "//result/doc[3]/str[@name='id'][.='p1s3']"
                    , "//result/doc[4]/str[@name='id'][.='p3s4']"
                    );

            
          }
          
          // query use {!func} so we can assert expected scores
          for (String selector : Arrays.asList(" sort='asc" + suffix + " desc'",
                                               " sort='sum(asc" + suffix + ",42) desc'",
                                               " min=desc" + suffix,
                                               " max=asc" + suffix,
                                               " min='sum(desc" + suffix + ", 42)'",
                                               " max='sum(asc" + suffix + ", 42)'")) {
            
            if (selector.endsWith("_l") && opt.endsWith("_i")) {
              // NOTE: this limitation doesn't apply to block collapse on int,
              // so we only check 'opt.endsWith' (if ends with block hint we're ok)
              assertQEx("expected known limitation of using long for min/max selector when doing numeric collapse",
                        "min/max must be Int or Float",
                        req("q", "*:*",
                            "fq", "{!collapse " + opt + nullPolicy + selector + "}"),
                        SolrException.ErrorCode.BAD_REQUEST);
              continue;
            }
            
            assertQ(req("q", "{!func}sum(42, num_i)",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "fl","score,id",
                        "sort", "num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1][str[@name='id'][.='p2s3'] and float[@name='score'][.=141.0]]"
                    , "//result/doc[2][str[@name='id'][.='p1s3'] and float[@name='score'][.=819.0]]"
                    , "//result/doc[3][str[@name='id'][.='p3s3'] and float[@name='score'][.=1276.0]]"
                    );
            // same query, but boosting multiple skus from p1
            assertQ(req("q", "{!func}sum(42, num_i)",
                        "qt", "/elevate",
                        "elevateIds", "p1s2,p1s1",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "fl","score,id",
                        "sort", "num_i asc")
                    , "*[count(//doc)=4]"
                    , "//result/doc[1][str[@name='id'][.='p1s2'] and float[@name='score'][.=52.0]]"
                    , "//result/doc[2][str[@name='id'][.='p1s1'] and float[@name='score'][.=84.0]]"
                    , "//result/doc[3][str[@name='id'][.='p2s3'] and float[@name='score'][.=141.0]]"
                    , "//result/doc[4][str[@name='id'][.='p3s3'] and float[@name='score'][.=1276.0]]"
                    );

            
          }
          
          // queries are relevancy based, and score is used in collapse local param sort -- but not in top fl/sort
          // (ie: help prove we setup 'needScores' correctly for collapse, even though top level query doesn't care)
          for (String selector : Arrays.asList("", // implicit score ranking as sanity check
                                               " sort='score desc'",
                                               // unused tie breaker after score
                                               " sort='score desc, sum(num_i,42) desc'",
                                               // force score to be a tie breaker
                                               " sort='sum(1.5,2.5) asc, score desc'")) {
            assertQ(req("q", "*:* txt_t:XX",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "fl", "id",
                        "sort", "num_i asc")
                    , "*[count(//doc)=3]"
                    , "//result/doc[1][str[@name='id'][.='p2s4']]" // 13
                    , "//result/doc[2][str[@name='id'][.='p3s1']]" // 15
                    , "//result/doc[3][str[@name='id'][.='p1s3']]" // 777
                    );
            // same query, but boosting multiple skus from p3
            // NOTE: this causes each boosted doc to be returned, but top level sort is not score, so QEC doesn't hijak order
            assertQ(req("q", "*:* txt_t:XX",
                        "qt", "/elevate",
                        "elevateIds", "p3s3,p3s2",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "fl", "id",
                        "sort", "num_i asc")
                    , "*[count(//doc)=4]"
                    , "//result/doc[1][str[@name='id'][.='p2s4']]" // 13
                    , "//result/doc[2][str[@name='id'][.='p3s2']]" // 100 (boosted so treated as own group)
                    , "//result/doc[3][str[@name='id'][.='p1s3']]" // 777
                    , "//result/doc[4][str[@name='id'][.='p3s3']]" // 1234 (boosted so treated as own group)
                    );
            // same query, w/forceElevation to change top level order
            assertQ(req("q", "*:* txt_t:XX",
                        "qt", "/elevate",
                        "elevateIds", "p3s3,p3s2",
                        "forceElevation", "true",
                        "fq", "{!collapse " + opt + selector + nullPolicy + "}",
                        "fl", "id",
                        "sort", "num_i asc")
                    , "*[count(//doc)=4]"
                    , "//result/doc[1][str[@name='id'][.='p3s3']]" // 1234 (boosted so treated as own group)
                    , "//result/doc[2][str[@name='id'][.='p3s2']]" // 100 (boosted so treated as own group)
                    , "//result/doc[3][str[@name='id'][.='p2s4']]" // 13
                    , "//result/doc[4][str[@name='id'][.='p1s3']]" // 777
                    );

            
          }
        }
      }
    } // sort
  }

