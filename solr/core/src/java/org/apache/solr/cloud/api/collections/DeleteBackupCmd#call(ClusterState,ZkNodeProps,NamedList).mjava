    @Override
    public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({"rawtypes"}) NamedList results) throws Exception {
        String backupLocation = message.getStr(CoreAdminParams.BACKUP_LOCATION);
        String backupName = message.getStr(NAME);
        String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);
        int backupId = message.getInt(CoreAdminParams.BACKUP_ID, -1);
        int lastNumBackupPointsToKeep = message.getInt(CoreAdminParams.MAX_NUM_BACKUP_POINTS, -1);
        if (backupId == -1 && lastNumBackupPointsToKeep == -1) {
            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
                    String.format(Locale.ROOT, "%s or %s param must be provided", CoreAdminParams.BACKUP_ID, CoreAdminParams.MAX_NUM_BACKUP_POINTS));
        }
        CoreContainer cc = ocmh.overseer.getCoreContainer();
        try (BackupRepository repository = cc.newBackupRepository(repo)) {
            URI location = repository.createURI(backupLocation);
            final URI backupPath = BackupFilePaths.buildExistingBackupLocationURI(repository, location, backupName);
            if (repository.exists(repository.resolve(backupPath, BackupManager.TRADITIONAL_BACKUP_PROPS_FILE))) {
                throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "The backup name [" + backupName + "] at " +
                        "location [" + location + "] holds a non-incremental (legacy) backup, but " +
                        "backup-deletion is only supported on incremental backups");
            }

            if (backupId != -1){
                deleteBackupId(repository, backupPath, backupId, results);
            } else {
                keepNumberOfBackup(repository, backupPath, lastNumBackupPointsToKeep, results);
            }
        }
    }

