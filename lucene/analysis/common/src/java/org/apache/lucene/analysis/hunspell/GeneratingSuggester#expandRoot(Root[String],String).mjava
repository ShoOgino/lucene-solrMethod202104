  private List<String> expandRoot(Root<String> root, String misspelled) {
    List<String> crossProducts = new ArrayList<>();
    Set<String> result = new LinkedHashSet<>();

    if (!dictionary.hasFlag(root.entryId, dictionary.needaffix)) {
      result.add(root.word);
    }

    // suffixes
    processFST(
        dictionary.suffixes,
        (key, ids) -> {
          String suffix = new StringBuilder(toString(key)).reverse().toString();
          if (misspelled.length() <= suffix.length() || !misspelled.endsWith(suffix)) return;

          for (int i = 0; i < ids.length; i++) {
            int suffixId = ids.ints[ids.offset + i];
            if (!hasCompatibleFlags(root, suffixId) || !checkAffixCondition(suffixId, root.word)) {
              continue;
            }

            String withSuffix =
                root.word.substring(0, root.word.length() - affixStripLength(suffixId)) + suffix;
            result.add(withSuffix);
            if (dictionary.isCrossProduct(suffixId)) {
              crossProducts.add(withSuffix);
            }
          }
        });

    // cross-product prefixes
    processFST(
        dictionary.prefixes,
        (key, ids) -> {
          String prefix = toString(key);
          if (misspelled.length() <= prefix.length() || !misspelled.startsWith(prefix)) return;

          for (int i = 0; i < ids.length; i++) {
            int prefixId = ids.ints[ids.offset + i];
            if (!dictionary.hasFlag(root.entryId, dictionary.affixData(prefixId, AFFIX_FLAG))
                || !dictionary.isCrossProduct(prefixId)) {
              continue;
            }

            for (String suffixed : crossProducts) {
              if (checkAffixCondition(prefixId, suffixed)) {
                result.add(prefix + suffixed.substring(affixStripLength(prefixId)));
              }
            }
          }
        });

    // pure prefixes
    processFST(
        dictionary.prefixes,
        (key, ids) -> {
          String prefix = toString(key);
          if (misspelled.length() <= prefix.length() || !misspelled.startsWith(prefix)) return;

          for (int i = 0; i < ids.length; i++) {
            int prefixId = ids.ints[ids.offset + i];
            if (hasCompatibleFlags(root, prefixId) && checkAffixCondition(prefixId, root.word)) {
              result.add(prefix + root.word.substring(affixStripLength(prefixId)));
            }
          }
        });

    return result.stream().limit(MAX_WORDS).collect(Collectors.toList());
  }

