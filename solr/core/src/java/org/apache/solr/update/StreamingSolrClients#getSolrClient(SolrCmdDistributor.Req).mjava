  public synchronized SolrClient getSolrClient(final SolrCmdDistributor.Req req) {
    String url = getFullUrl(req.node.getUrl());
    ConcurrentUpdateSolrClient client = solrClients.get(url);
    if (client == null) {
      // NOTE: increasing to more than 1 threadCount for the client could cause updates to be reordered
      // on a greater scale since the current behavior is to only increase the number of connections/Runners when
      // the queue is more than half full.
      client = new ErrorReportingConcurrentUpdateSolrClient.Builder(url, req, errors)
          .withHttpClient(httpClient)
          .withQueueSize(100)
          .withThreadCount(runnerCount)
          .withExecutorService(updateExecutor)
          .alwaysStreamDeletes()
          .withSocketTimeout(socketTimeout)
          .withConnectionTimeout(connectionTimeout)
          .build();
      client.setPollQueueTime(Integer.MAX_VALUE); // minimize connections created
      client.setParser(new BinaryResponseParser());
      client.setRequestWriter(new BinaryRequestWriter());
      Set<String> queryParams = new HashSet<>(2);
      queryParams.add(DistributedUpdateProcessor.DISTRIB_FROM);
      queryParams.add(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM);
      client.setQueryParams(queryParams);
      solrClients.put(url, client);
    }

    return client;
  }

