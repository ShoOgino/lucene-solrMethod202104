  // should only be called by FieldInfos#addOrUpdate
  void update(
      boolean storeTermVector,
      boolean omitNorms,
      boolean storePayloads,
      IndexOptions indexOptions,
      Map<String, String> attributes,
      int dimensionCount,
      int indexDimensionCount,
      int dimensionNumBytes) {
    if (indexOptions == null) {
      throw new NullPointerException("IndexOptions must not be null (field: \"" + name + "\")");
    }
    // System.out.println("FI.update field=" + name + " indexed=" + indexed + " omitNorms=" +
    // omitNorms + " this.omitNorms=" + this.omitNorms);
    if (this.indexOptions != indexOptions) {
      if (this.indexOptions == IndexOptions.NONE) {
        this.indexOptions = indexOptions;
      } else if (indexOptions != IndexOptions.NONE) {
        throw new IllegalArgumentException(
            "cannot change field \""
                + name
                + "\" from index options="
                + this.indexOptions
                + " to inconsistent index options="
                + indexOptions);
      }
    }

    if (this.pointDimensionCount == 0 && dimensionCount != 0) {
      this.pointDimensionCount = dimensionCount;
      this.pointIndexDimensionCount = indexDimensionCount;
      this.pointNumBytes = dimensionNumBytes;
    } else if (dimensionCount != 0
        && (this.pointDimensionCount != dimensionCount
            || this.pointIndexDimensionCount != indexDimensionCount
            || this.pointNumBytes != dimensionNumBytes)) {
      throw new IllegalArgumentException(
          "cannot change field \""
              + name
              + "\" from points dimensionCount="
              + this.pointDimensionCount
              + ", indexDimensionCount="
              + this.pointIndexDimensionCount
              + ", numBytes="
              + this.pointNumBytes
              + " to inconsistent dimensionCount="
              + dimensionCount
              + ", indexDimensionCount="
              + indexDimensionCount
              + ", numBytes="
              + dimensionNumBytes);
    }

    // if updated field data is not for indexing, leave the updates out
    if (this.indexOptions != IndexOptions.NONE) {
      this.storeTermVector |= storeTermVector; // once vector, always vector
      this.storePayloads |= storePayloads;

      // Awkward: only drop norms if incoming update is indexed:
      if (indexOptions != IndexOptions.NONE && this.omitNorms != omitNorms) {
        this.omitNorms = true; // if one require omitNorms at least once, it remains off for life
      }
    }
    if (this.indexOptions == IndexOptions.NONE
        || this.indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) < 0) {
      // cannot store payloads if we don't store positions:
      this.storePayloads = false;
    }
    if (attributes != null) {
      this.attributes.putAll(attributes);
    }
    this.checkConsistency();
  }

