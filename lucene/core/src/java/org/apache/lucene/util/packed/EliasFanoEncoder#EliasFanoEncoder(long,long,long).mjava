  /**
   * Construct an Elias-Fano encoder.
   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode
   * a non decreasing sequence of non negative numbers.
   * @param numValues The number of values that is to be encoded.
   * @param upperBound  At least the highest value that will be encoded.
   *                For space efficiency this should not exceed the power of two that equals
   *                or is the first higher than the actual maximum.
   *                <br>When {@code numValues >= (upperBound/3)}
   *                a {@link FixedBitSet} will take less space.
   * @param indexInterval The number of high zero bits for which a single index entry is built.
   *                The index will have at most <code>2 * numValues / indexInterval</code> entries
   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,
   *                see {@link EliasFanoEncoder}.
   * @throws IllegalArgumentException when:
   *         <ul>
   *         <li><code>numValues</code> is negative, or
   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or
   *         <li>the low bits do not fit in a <code>long[]</code>:
   *             {@code (L * numValues / 64) > Integer.MAX_VALUE}, or
   *         <li>the high bits do not fit in a <code>long[]</code>:
   *             {@code (2 * numValues / 64) > Integer.MAX_VALUE}, or
   *         <li>{@code indexInterval < 2},
   *         <li>the index bits do not fit in a <code>long[]</code>:
   *             {@code (numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE}.
   *         </ul>
   */
  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {
    if (numValues < 0L) {
      throw new IllegalArgumentException("numValues should not be negative: " + numValues);
    }
    this.numValues = numValues;
    if ((numValues > 0L) && (upperBound < 0L)) {
      throw new IllegalArgumentException("upperBound should not be negative: " + upperBound + " when numValues > 0");
    }
    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound
    int nLowBits = 0;
    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))
      long lowBitsFac = this.upperBound / this.numValues;
      if (lowBitsFac > 0) {
        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs
      }
    }
    this.numLowBits = nLowBits;
    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);

    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);
    if (numLongsForLowBits > Integer.MAX_VALUE) {
      throw new IllegalArgumentException("numLongsForLowBits too large to index a long array: " + numLongsForLowBits);
    }
    this.lowerLongs = new long[(int) numLongsForLowBits];

    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;
    assert numHighBitsClear <= (2 * this.numValues);
    long numHighBitsSet = this.numValues;

    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);
    if (numLongsForHighBits > Integer.MAX_VALUE) {
      throw new IllegalArgumentException("numLongsForHighBits too large to index a long array: " + numLongsForHighBits);
    }
    this.upperLongs = new long[(int) numLongsForHighBits];
    if (indexInterval < 2) {
      throw new IllegalArgumentException("indexInterval should at least 2: " + indexInterval);
    }
    // For the index:
    long maxHighValue = upperBound >>> this.numLowBits;
    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry
    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;
    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero
    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0
                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry));
    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);
    if (numLongsForIndexBits > Integer.MAX_VALUE) {
      throw new IllegalArgumentException("numLongsForIndexBits too large to index a long array: " + numLongsForIndexBits);
    }
    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];
    this.currentEntryIndex = 0;
    this.indexInterval = indexInterval;
  }

