  /**
   * Generates a list of stems for the provided word
   *
   * @param word Word to generate the stems for
   * @param previous previous affix that was removed (so we dont remove same one twice)
   * @param prevFlag Flag from a previous stemming step that need to be cross-checked with any
   *     affixes in this recursive step
   * @param prefixFlag flag of the most inner removed prefix, so that when removing a suffix, it's
   *     also checked against the word
   * @param recursionDepth current recursiondepth
   * @param doPrefix true if we should remove prefixes
   * @param doSuffix true if we should remove suffixes
   * @param previousWasPrefix true if the previous removal was a prefix: if we are removing a
   *     suffix, and it has no continuation requirements, it's ok. but two prefixes
   *     (COMPLEXPREFIXES) or two suffixes must have continuation requirements to recurse.
   * @param circumfix true if the previous prefix removal was signed as a circumfix this means inner
   *     most suffix must also contain circumfix flag.
   * @param caseVariant true if we are searching for a case variant. if the word has KEEPCASE flag
   *     it cannot succeed.
   * @return List of stems, or empty list if no stems are found
   */
  private List<CharsRef> stem(
      char[] word,
      int length,
      int previous,
      int prevFlag,
      int prefixFlag,
      int recursionDepth,
      boolean doPrefix,
      boolean doSuffix,
      boolean previousWasPrefix,
      boolean circumfix,
      boolean caseVariant)
      throws IOException {

    // TODO: allow this stuff to be reused by tokenfilter
    List<CharsRef> stems = new ArrayList<>();

    if (doPrefix && dictionary.prefixes != null) {
      FST<IntsRef> fst = dictionary.prefixes;
      Outputs<IntsRef> outputs = fst.outputs;
      FST.BytesReader bytesReader = prefixReaders[recursionDepth];
      FST.Arc<IntsRef> arc = prefixArcs[recursionDepth];
      fst.getFirstArc(arc);
      IntsRef NO_OUTPUT = outputs.getNoOutput();
      IntsRef output = NO_OUTPUT;
      int limit = dictionary.fullStrip ? length + 1 : length;
      for (int i = 0; i < limit; i++) {
        if (i > 0) {
          int ch = word[i - 1];
          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {
            break;
          } else if (arc.output() != NO_OUTPUT) {
            output = fst.outputs.add(output, arc.output());
          }
        }
        if (!arc.isFinal()) {
          continue;
        }
        IntsRef prefixes = fst.outputs.add(output, arc.nextFinalOutput());

        for (int j = 0; j < prefixes.length; j++) {
          int prefix = prefixes.ints[prefixes.offset + j];
          if (prefix == previous) {
            continue;
          }
          int condition = dictionary.affixData(prefix, Dictionary.AFFIX_CONDITION);
          boolean crossProduct = (condition & 1) == 1;
          condition >>>= 1;
          int append = dictionary.affixData(prefix, Dictionary.AFFIX_APPEND);

          final boolean compatible;
          if (recursionDepth == 0) {
            if (dictionary.onlyincompound == -1) {
              compatible = true;
            } else {
              // check if affix is allowed in a non-compound word
              compatible = !dictionary.hasFlag(append, (char) dictionary.onlyincompound, scratch);
            }
          } else if (crossProduct) {
            // cross check incoming continuation class (flag of previous affix) against list.
            char[] appendFlags = dictionary.decodeFlags(append, scratch);
            assert prevFlag >= 0;
            boolean allowed =
                dictionary.onlyincompound == -1
                    || !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);
            compatible = allowed && Dictionary.hasFlag(appendFlags, (char) prevFlag);
          } else {
            compatible = false;
          }

          if (compatible) {
            int deAffixedLength = length - i;

            int stripOrd = dictionary.affixData(prefix, Dictionary.AFFIX_STRIP_ORD);
            int stripStart = dictionary.stripOffsets[stripOrd];
            int stripEnd = dictionary.stripOffsets[stripOrd + 1];
            int stripLength = stripEnd - stripStart;

            if (!checkCondition(
                condition,
                dictionary.stripData,
                stripStart,
                stripLength,
                word,
                i,
                deAffixedLength)) {
              continue;
            }

            char[] strippedWord = new char[stripLength + deAffixedLength];
            System.arraycopy(dictionary.stripData, stripStart, strippedWord, 0, stripLength);
            System.arraycopy(word, i, strippedWord, stripLength, deAffixedLength);

            List<CharsRef> stemList =
                applyAffix(
                    strippedWord,
                    strippedWord.length,
                    prefix,
                    -1,
                    recursionDepth,
                    true,
                    circumfix,
                    caseVariant);

            stems.addAll(stemList);
          }
        }
      }
    }

    if (doSuffix && dictionary.suffixes != null) {
      FST<IntsRef> fst = dictionary.suffixes;
      Outputs<IntsRef> outputs = fst.outputs;
      FST.BytesReader bytesReader = suffixReaders[recursionDepth];
      FST.Arc<IntsRef> arc = suffixArcs[recursionDepth];
      fst.getFirstArc(arc);
      IntsRef NO_OUTPUT = outputs.getNoOutput();
      IntsRef output = NO_OUTPUT;
      int limit = dictionary.fullStrip ? 0 : 1;
      for (int i = length; i >= limit; i--) {
        if (i < length) {
          int ch = word[i];
          if (fst.findTargetArc(ch, arc, arc, bytesReader) == null) {
            break;
          } else if (arc.output() != NO_OUTPUT) {
            output = fst.outputs.add(output, arc.output());
          }
        }
        if (!arc.isFinal()) {
          continue;
        }
        IntsRef suffixes = fst.outputs.add(output, arc.nextFinalOutput());

        for (int j = 0; j < suffixes.length; j++) {
          int suffix = suffixes.ints[suffixes.offset + j];
          if (suffix == previous) {
            continue;
          }
          int condition = dictionary.affixData(suffix, Dictionary.AFFIX_CONDITION);
          boolean crossProduct = (condition & 1) == 1;
          condition >>>= 1;
          int append = dictionary.affixData(suffix, Dictionary.AFFIX_APPEND);

          final boolean compatible;
          if (recursionDepth == 0) {
            if (dictionary.onlyincompound == -1) {
              compatible = true;
            } else {
              // check if affix is allowed in a non-compound word
              compatible = !dictionary.hasFlag(append, (char) dictionary.onlyincompound, scratch);
            }
          } else if (crossProduct) {
            // cross check incoming continuation class (flag of previous affix) against list.
            char[] appendFlags = dictionary.decodeFlags(append, scratch);
            assert prevFlag >= 0;
            boolean allowed =
                dictionary.onlyincompound == -1
                    || !Dictionary.hasFlag(appendFlags, (char) dictionary.onlyincompound);
            compatible =
                allowed
                    && ((appendFlags.length == 0 && previousWasPrefix)
                        || Dictionary.hasFlag(appendFlags, (char) prevFlag));
          } else {
            compatible = false;
          }

          if (compatible) {
            int appendLength = length - i;
            int deAffixedLength = length - appendLength;

            int stripOrd = dictionary.affixData(suffix, Dictionary.AFFIX_STRIP_ORD);
            int stripStart = dictionary.stripOffsets[stripOrd];
            int stripEnd = dictionary.stripOffsets[stripOrd + 1];
            int stripLength = stripEnd - stripStart;

            if (!checkCondition(
                condition,
                word,
                0,
                deAffixedLength,
                dictionary.stripData,
                stripStart,
                stripLength)) {
              continue;
            }

            char[] strippedWord = new char[stripLength + deAffixedLength];
            System.arraycopy(word, 0, strippedWord, 0, deAffixedLength);
            System.arraycopy(
                dictionary.stripData, stripStart, strippedWord, deAffixedLength, stripLength);

            List<CharsRef> stemList =
                applyAffix(
                    strippedWord,
                    strippedWord.length,
                    suffix,
                    prefixFlag,
                    recursionDepth,
                    false,
                    circumfix,
                    caseVariant);

            stems.addAll(stemList);
          }
        }
      }
    }

    return stems;
  }

