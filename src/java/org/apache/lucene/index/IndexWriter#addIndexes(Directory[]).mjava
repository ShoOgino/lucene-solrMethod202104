  /** Merges all segments from an array of indexes into this index.
   *
   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError
   * you should immediately close the writer.  See <a
   * href="#OOME">above</a> for details.</p>
   *
   * @deprecated Use {@link #addIndexesNoOptimize} instead,
   * then separately call {@link #optimize} afterwards if
   * you need to.
   *
   * @throws CorruptIndexException if the index is corrupt
   * @throws IOException if there is a low-level IO error
   */
  public void addIndexes(Directory[] dirs)
    throws CorruptIndexException, IOException {

    ensureOpen();
    
    noDupDirs(dirs);

    // Do not allow add docs or deletes while we are running:
    docWriter.pauseAllThreads();

    try {

      if (infoStream != null)
        message("flush at addIndexes");
      flush(true, false, true);

      boolean success = false;

      startTransaction(false);

      try {

        int docCount = 0;
        synchronized(this) {
          ensureOpen();
          for (int i = 0; i < dirs.length; i++) {
            SegmentInfos sis = new SegmentInfos();	  // read infos from dir
            sis.read(dirs[i]);
            for (int j = 0; j < sis.size(); j++) {
              final SegmentInfo info = sis.info(j);
              docCount += info.docCount;
              assert !segmentInfos.contains(info);
              segmentInfos.add(info);	  // add each info
            }
          }
        }

        // Notify DocumentsWriter that the flushed count just increased
        docWriter.updateFlushedDocCount(docCount);

        optimize();

        success = true;
      } finally {
        if (success) {
          commitTransaction();
        } else {
          rollbackTransaction();
        }
      }
    } catch (OutOfMemoryError oom) {
      hitOOM = true;
      throw oom;
    } finally {
      if (docWriter != null) {
        docWriter.resumeAllThreads();
      }
    }
  }

