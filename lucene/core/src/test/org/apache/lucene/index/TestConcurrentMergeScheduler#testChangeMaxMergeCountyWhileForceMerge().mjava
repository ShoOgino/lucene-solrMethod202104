  /*
   * This test tries to produce 2 merges running concurrently with 2 segments per merge. While these
   * merges run we kick off a forceMerge that puts a pending merge in the queue but waits for things to happen.
   * While we do this we reduce maxMergeCount to 1. If concurrency in CMS is not right the forceMerge will wait forever
   * since none of the currently running merges picks up the pending merge. This test fails every time.
   */
  public void testChangeMaxMergeCountyWhileForceMerge() throws IOException, InterruptedException {
    int numIters = TEST_NIGHTLY ? 100 : 10;
    for (int iters = 0; iters < numIters; iters++) {
      LogDocMergePolicy mp = new LogDocMergePolicy();
      mp.setMergeFactor(2);
      CountDownLatch forceMergeWaits = new CountDownLatch(1);
      CountDownLatch mergeThreadsStartAfterWait = new CountDownLatch(1);
      CountDownLatch mergeThreadsArrived = new CountDownLatch(2);
      InfoStream stream = new InfoStream() {
        @Override
        public void message(String component, String message) {
          if ("TP".equals(component) && "mergeMiddleStart".equals(message)) {
            mergeThreadsArrived.countDown();
            try {
              mergeThreadsStartAfterWait.await();
            } catch (InterruptedException e) {
              throw new AssertionError(e);
            }
          } else if ("TP".equals(component) && "forceMergeBeforeWait".equals(message)) {
            forceMergeWaits.countDown();
          }
        }

        @Override
        public boolean isEnabled(String component) {
          return "TP".equals(component);
        }

        @Override
        public void close() {
        }
      };
      try (Directory dir = newDirectory();
           IndexWriter writer = new IndexWriter(dir,
               new IndexWriterConfig().setMergeScheduler(new ConcurrentMergeScheduler())
                   .setMergePolicy(mp).setInfoStream(stream)) {
             @Override
             protected boolean isEnableTestPoints() {
               return true;
             }
           }) {
        Thread t = new Thread(() -> {
          try {
            writer.forceMerge(1);
          } catch (IOException e) {
            throw new AssertionError(e);
          }
        });
        ConcurrentMergeScheduler cms = (ConcurrentMergeScheduler) writer.getConfig().getMergeScheduler();
        cms.setMaxMergesAndThreads(2, 2);
        try {
          for (int i = 0; i < 4; i++) {
            Document document = new Document();
            document.add(new TextField("foo", "the quick brown fox jumps over the lazy dog", Field.Store.YES));
            document.add(new TextField("bar", RandomStrings.randomRealisticUnicodeOfLength(random(), 20), Field.Store.YES));
            writer.addDocument(document);
            writer.flush();
          }
          assertEquals(writer.cloneSegmentInfos().toString(), 4, writer.getSegmentCount());
          mergeThreadsArrived.await();
          t.start();
          forceMergeWaits.await();
          cms.setMaxMergesAndThreads(1, 1);
        } finally {
          mergeThreadsStartAfterWait.countDown();
        }

        while (t.isAlive()) {
          t.join(10);
          if (cms.mergeThreadCount() == 0 && writer.hasPendingMerges()) {
            fail("writer has pending merges but no CMS threads are running");
          }
        }
        assertEquals(1, writer.getSegmentCount());
      }
    }
  }

