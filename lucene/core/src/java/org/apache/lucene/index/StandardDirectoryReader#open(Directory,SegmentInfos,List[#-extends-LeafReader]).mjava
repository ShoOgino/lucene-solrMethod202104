  /** This constructor is only used for {@link #doOpenIfChanged(SegmentInfos)}, as well as NRT replication.
   *
   *  @lucene.internal */
  public static DirectoryReader open(Directory directory, SegmentInfos infos, List<? extends LeafReader> oldReaders) throws IOException {

    // we put the old SegmentReaders in a map, that allows us
    // to lookup a reader using its segment name
    final Map<String,Integer> segmentReaders = (oldReaders == null ? Collections.emptyMap() : new HashMap<>(oldReaders.size()));

    if (oldReaders != null) {
      // create a Map SegmentName->SegmentReader
      for (int i = 0, c = oldReaders.size(); i < c; i++) {
        final SegmentReader sr = (SegmentReader) oldReaders.get(i);
        segmentReaders.put(sr.getSegmentName(), Integer.valueOf(i));
      }
    }
    
    SegmentReader[] newReaders = new SegmentReader[infos.size()];
    for (int i = infos.size() - 1; i>=0; i--) {
      SegmentCommitInfo commitInfo = infos.info(i);

      // find SegmentReader for this segment
      Integer oldReaderIndex = segmentReaders.get(commitInfo.info.name);
      SegmentReader oldReader;
      if (oldReaderIndex == null) {
        // this is a new segment, no old SegmentReader can be reused
        oldReader = null;
      } else {
        // there is an old reader for this segment - we'll try to reopen it
        oldReader = (SegmentReader) oldReaders.get(oldReaderIndex.intValue());
      }

      // Make a best effort to detect when the app illegally "rm -rf" their
      // index while a reader was open, and then called openIfChanged:
      if (oldReader != null && Arrays.equals(commitInfo.info.getId(), oldReader.getSegmentInfo().info.getId()) == false) {
        throw new IllegalStateException("same segment " + commitInfo.info.name + " has invalid doc count change; likely you are re-opening a reader after illegally removing index files yourself and building a new index in their place.  Use IndexWriter.deleteAll or open a new IndexWriter using OpenMode.CREATE instead");
      }

      boolean success = false;
      try {
        SegmentReader newReader;
        if (oldReader == null || commitInfo.info.getUseCompoundFile() != oldReader.getSegmentInfo().info.getUseCompoundFile()) {
          // this is a new reader; in case we hit an exception we can decRef it safely
          newReader = new SegmentReader(commitInfo, infos.getIndexCreatedVersionMajor(), false, IOContext.READ);
          newReaders[i] = newReader;
        } else {
          if (oldReader.isNRT) {
            // We must load liveDocs/DV updates from disk:
            Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()
                .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;
            newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,
                commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);
          } else {
            if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()
                && oldReader.getSegmentInfo().getFieldInfosGen() == commitInfo.getFieldInfosGen()) {
              // No change; this reader will be shared between
              // the old and the new one, so we must incRef
              // it:
              oldReader.incRef();
              newReaders[i] = oldReader;
            } else {
              // Steal the ref returned by SegmentReader ctor:
              assert commitInfo.info.dir == oldReader.getSegmentInfo().info.dir;

              if (oldReader.getSegmentInfo().getDelGen() == commitInfo.getDelGen()) {
                // only DV updates
                newReaders[i] = new SegmentReader(commitInfo, oldReader, oldReader.getLiveDocs(),
                    oldReader.getHardLiveDocs(), oldReader.numDocs(), false); // this is not an NRT reader!
              } else {
                // both DV and liveDocs have changed
                Bits liveDocs = commitInfo.hasDeletions() ? commitInfo.info.getCodec().liveDocsFormat()
                    .readLiveDocs(commitInfo.info.dir, commitInfo, IOContext.READONCE) : null;
                newReaders[i] = new SegmentReader(commitInfo, oldReader, liveDocs, liveDocs,
                    commitInfo.info.maxDoc() - commitInfo.getDelCount(), false);
              }
            }
          }
        }
        success = true;
      } finally {
        if (!success) {
          decRefWhileHandlingException(newReaders);
        }
      }
    }    
    return new StandardDirectoryReader(directory, newReaders, null, infos, false, false);
  }

