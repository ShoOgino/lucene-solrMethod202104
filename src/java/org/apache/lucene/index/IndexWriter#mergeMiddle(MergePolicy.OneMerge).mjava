  /** Does the actual (time-consuming) work of the merge,
   *  but without holding synchronized lock on IndexWriter
   *  instance */
  final private int mergeMiddle(MergePolicy.OneMerge merge) 
    throws CorruptIndexException, IOException {
    
    merge.checkAborted(directory);

    final String mergedName = merge.info.name;
    
    SegmentMerger merger = null;

    int mergedDocCount = 0;

    SegmentInfos sourceSegments = merge.segments;
    SegmentInfos sourceSegmentsClone = merge.segmentsClone;
    final int numSegments = sourceSegments.size();

    if (infoStream != null)
      message("merging " + merge.segString(directory));

    merger = new SegmentMerger(this, mergedName, merge);
    
    // This is try/finally to make sure merger's readers are
    // closed:
    try {
      int totDocCount = 0;

      for (int i = 0; i < numSegments; i++) {
        SegmentInfo si = sourceSegmentsClone.info(i);
        IndexReader reader = SegmentReader.get(true, si, MERGE_READ_BUFFER_SIZE, merge.mergeDocStores); // no need to set deleter (yet)
        merger.add(reader);
        totDocCount += reader.numDocs();
      }
      if (infoStream != null) {
        message("merge: total "+totDocCount+" docs");
      }

      merge.checkAborted(directory);

      // This is where all the work happens:
      mergedDocCount = merge.info.docCount = merger.merge(merge.mergeDocStores);

      assert mergedDocCount == totDocCount;

    } finally {
      // close readers before we attempt to delete
      // now-obsolete segments
      if (merger != null) {
        merger.closeReaders();
      }
    }

    if (!commitMerge(merge, merger, mergedDocCount))
      // commitMerge will return false if this merge was aborted
      return 0;

    if (merge.useCompoundFile) {

      // Maybe force a sync here to allow reclaiming of the
      // disk space used by the segments we just merged:
      if (autoCommit && doCommitBeforeMergeCFS(merge)) {
        final long size;
        synchronized(this) {
          size = merge.info.sizeInBytes();
        }
        commit(size);
      }
      
      boolean success = false;
      final String compoundFileName = mergedName + "." + IndexFileNames.COMPOUND_FILE_EXTENSION;

      try {
        merger.createCompoundFile(compoundFileName);
        success = true;
      } catch (IOException ioe) {
        synchronized(this) {
          if (merge.isAborted()) {
            // This can happen if rollback or close(false)
            // is called -- fall through to logic below to
            // remove the partially created CFS:
            success = true;
          } else
            handleMergeException(ioe, merge);
        }
      } catch (Throwable t) {
        handleMergeException(t, merge);
      } finally {
        if (!success) {
          if (infoStream != null)
            message("hit exception creating compound file during merge");
          synchronized(this) {
            deleter.deleteFile(compoundFileName);
          }
        }
      }

      if (merge.isAborted()) {
        if (infoStream != null)
          message("abort merge after building CFS");
        deleter.deleteFile(compoundFileName);
        return 0;
      }

      synchronized(this) {
        if (segmentInfos.indexOf(merge.info) == -1 || merge.isAborted()) {
          // Our segment (committed in non-compound
          // format) got merged away while we were
          // building the compound format.
          deleter.deleteFile(compoundFileName);
        } else {
          merge.info.setUseCompoundFile(true);
          checkpoint();
        }
      }
    }

    // Force a sync after commiting the merge.  Once this
    // sync completes then all index files referenced by the
    // current segmentInfos are on stable storage so if the
    // OS/machine crashes, or power cord is yanked, the
    // index will be intact.  Note that this is just one
    // (somewhat arbitrary) policy; we could try other
    // policies like only sync if it's been > X minutes or
    // more than Y bytes have been written, etc.
    if (autoCommit) {
      final long size;
      synchronized(this) {
        size = merge.info.sizeInBytes();
      }
      commit(size);
    }

    return mergedDocCount;
  }

