  @Override
  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {

    return new QParser(qstr, localParams, params, req) {
      @Override
      public Query parse() throws SyntaxError {
        String field = localParams.get(QueryParsing.F);
        String value = localParams.get(QueryParsing.V);
        String p = localParams.get("payloads");
        // payloads and op parameter are probably mutually exclusive. we could consider making a different query
        // not a span payload check query, but something that just operates on payloads without the span?
        String strOp = localParams.get("op");
        MatchOperation op = MatchOperation.EQ;
        if (strOp != null) {
          op = MatchOperation.valueOf(strOp.toUpperCase(Locale.ROOT));
        }

        if (field == null) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "'f' not specified");
        }

        if (value == null) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "query string missing");
        }

        if (p == null) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "'payloads' not specified");
        }

        FieldType ft = req.getCore().getLatestSchema().getFieldType(field);
        Analyzer analyzer = ft.getQueryAnalyzer();
        SpanQuery query = null;
        try {
          query = PayloadUtils.createSpanQuery(field, value, analyzer);
        } catch (IOException e) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);
        }

        if (query == null) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "SpanQuery is null");
        }

        PayloadEncoder encoder = null;
        String e = PayloadUtils.getPayloadEncoder(ft);
        PayloadType payloadType = null;
        if ("float".equals(e)) {    // TODO: centralize this string->PayloadEncoder logic (see DelimitedPayloadTokenFilterFactory)
          encoder = new FloatEncoder();
          payloadType = PayloadType.FLOAT;
        } else if ("integer".equals(e)) {
          encoder = new IntegerEncoder();
          payloadType = PayloadType.INT;
        } else if ("identity".equals(e)) {
          encoder = new IdentityEncoder();
          payloadType = PayloadType.STRING;
        }

        if (encoder == null) {
          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "invalid encoder: " + e + " for field: " + field);
        }

        List<BytesRef> payloads = new ArrayList<>();
        String[] rawPayloads = p.split(" ");  // since payloads (most likely) came in whitespace delimited, just split
        for (String rawPayload : rawPayloads) {
          if (rawPayload.length() > 0)
            payloads.add(encoder.encode(rawPayload.toCharArray()));
        }
        return new SpanPayloadCheckQuery(query, payloads, payloadType, op);
      }
    };


  }

