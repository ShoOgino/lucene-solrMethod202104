  private boolean checkCompounds(
      CharsRef word, WordCase originalCase, int depth, Predicate<CharsRef> checkPatterns) {
    if (depth > dictionary.compoundMax - 2) return false;

    int limit = word.length - dictionary.compoundMin + 1;
    for (int breakPos = dictionary.compoundMin; breakPos < limit; breakPos++) {
      WordContext context = depth == 0 ? COMPOUND_BEGIN : COMPOUND_MIDDLE;
      int breakOffset = word.offset + breakPos;
      if (mayBreakIntoCompounds(word.chars, word.offset, word.length, breakOffset)) {
        CharsRef stem = findStem(word.chars, word.offset, breakPos, originalCase, context);
        if (stem == null
            && dictionary.simplifiedTriple
            && word.chars[breakOffset - 1] == word.chars[breakOffset]) {
          stem = findStem(word.chars, word.offset, breakPos + 1, originalCase, context);
        }
        if (stem != null && checkPatterns.test(stem)) {
          Predicate<CharsRef> nextCheck = checkNextPatterns(word, breakPos, stem);
          if (checkCompoundsAfter(word, breakPos, originalCase, depth, stem, nextCheck)) {
            return true;
          }
        }
      }

      if (checkCompoundPatternReplacements(word, breakPos, originalCase, depth)) {
        return true;
      }
    }

    return false;
  }

