  @Override
  @SuppressWarnings({"unchecked"})
  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({"rawtypes"}) NamedList results) throws Exception {

    String extCollectionName = message.getStr(COLLECTION_PROP);
    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);
    String collectionName;
    if (followAliases) {
      collectionName = ccc.getSolrCloudManager().getClusterStateProvider().resolveSimpleAlias(extCollectionName);
    } else {
      collectionName = extCollectionName;
    }
    String backupName = message.getStr(NAME);
    String repo = message.getStr(CoreAdminParams.BACKUP_REPOSITORY);
    boolean incremental = message.getBool(CoreAdminParams.BACKUP_INCREMENTAL, true);
    String configName = ccc.getZkStateReader().readConfigName(collectionName);

    BackupProperties backupProperties = BackupProperties.create(backupName, collectionName,
            extCollectionName, configName);

    CoreContainer cc = ccc.getCoreContainer();
    try (BackupRepository repository = cc.newBackupRepository(repo)) {

      // Backup location
      URI location = repository.createURI(message.getStr(CoreAdminParams.BACKUP_LOCATION));
      final URI backupUri = createAndValidateBackupPath(repository, incremental, location, backupName, collectionName);

      BackupManager backupMgr = (incremental) ?
              BackupManager.forIncrementalBackup(repository, ccc.getZkStateReader(), backupUri) :
              BackupManager.forBackup(repository, ccc.getZkStateReader(), backupUri);

      String strategy = message.getStr(CollectionAdminParams.INDEX_BACKUP_STRATEGY, CollectionAdminParams.COPY_FILES_STRATEGY);
      switch (strategy) {
        case CollectionAdminParams.COPY_FILES_STRATEGY: {
          if (incremental) {
            try {
              incrementalCopyIndexFiles(backupUri, collectionName, message, results, backupProperties, backupMgr);
            } catch (SolrException e) {
              log.error("Error happened during incremental backup for collection:{}", collectionName, e);
              CollectionHandlingUtils.cleanBackup(repository, backupUri, backupMgr.getBackupId(), ccc);
              throw e;
            }
          } else {
            copyIndexFiles(backupUri, collectionName, message, results);
          }
          break;
        }
        case CollectionAdminParams.NO_INDEX_BACKUP_STRATEGY: {
          break;
        }
      }

      log.info("Starting to backup ZK data for backupName={}", backupName);

      //Download the configs
      backupMgr.downloadConfigDir(configName);

      //Save the collection's state. Can be part of the monolithic clusterstate.json or a individual state.json
      //Since we don't want to distinguish we extract the state and back it up as a separate json
      DocCollection collectionState = ccc.getZkStateReader().getClusterState().getCollection(collectionName);
      backupMgr.writeCollectionState(collectionName, collectionState);
      backupMgr.downloadCollectionProperties(collectionName);

      //TODO: Add MD5 of the configset. If during restore the same name configset exists then we can compare checksums to see if they are the same.
      //if they are not the same then we can throw an error or have an 'overwriteConfig' flag
      //TODO save numDocs for the shardLeader. We can use it to sanity check the restore.

      backupMgr.writeBackupProperties(backupProperties);

      log.info("Completed backing up ZK data for backupName={}", backupName);

      int maxNumBackup = message.getInt(CoreAdminParams.MAX_NUM_BACKUP_POINTS, -1);
      if (incremental && maxNumBackup != -1) {
        CollectionHandlingUtils.deleteBackup(repository, backupUri, maxNumBackup, results, ccc);
      }
    }
  }

