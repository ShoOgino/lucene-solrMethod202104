    /**
     * Maps a Query from {@link MatchesIterator#getQuery()} to {@link OffsetsEnum#getTerm()}. See
     * {@link Passage#getMatchTerms()}.
     */
    private BytesRef queryToTerm(Query query) {
      // compute an approximate BytesRef term of a Query.  We cache this since we're likely to see
      // the same query again.
      // Our approach is to visit each matching term in order, concatenating them with an adjoining
      // space.
      //  If we don't have any (perhaps due to an MTQ like a wildcard) then we fall back on the
      // toString() of the query.
      return queryToTermMap.computeIfAbsent(
          query,
          (Query q) -> {
            BytesRefBuilder bytesRefBuilder = new BytesRefBuilder();
            q.visit(
                new QueryVisitor() {
                  @Override
                  public void consumeTerms(Query query, Term... terms) {
                    for (Term term : terms) {
                      if (bytesRefBuilder.length() > 0) {
                        bytesRefBuilder.append((byte) ' ');
                      }
                      bytesRefBuilder.append(term.bytes());
                    }
                  }
                });
            if (bytesRefBuilder.length() > 0) {
              return bytesRefBuilder.get();
            }
            // fallback:  (likely a MultiTermQuery)
            return new BytesRef(q.toString());
          });
    }

