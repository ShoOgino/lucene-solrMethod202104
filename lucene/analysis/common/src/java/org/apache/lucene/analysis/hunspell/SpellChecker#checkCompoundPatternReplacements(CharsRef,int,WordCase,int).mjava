  private boolean checkCompoundPatternReplacements(
      CharsRef word, int pos, WordCase originalCase, int depth) {
    for (CheckCompoundPattern pattern : dictionary.checkCompoundPatterns) {
      CharsRef expanded = pattern.expandReplacement(word, pos);
      if (expanded != null) {
        WordContext context = depth == 0 ? COMPOUND_BEGIN : COMPOUND_MIDDLE;
        int breakPos = pos + pattern.endLength();
        List<CharsRef> stems =
            stemmer.doStem(expanded.chars, expanded.offset, breakPos, originalCase, context);
        if (!stems.isEmpty()) {
          Predicate<List<CharsRef>> nextCheck =
              next -> pattern.prohibitsCompounding(expanded, breakPos, stems, next);
          if (checkCompoundsAfter(expanded, breakPos, originalCase, depth, stems, nextCheck)) {
            return true;
          }
        }
      }
    }
    return false;
  }

