  @Override
  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost)
      throws IOException {

    return new ConstantScoreWeight(this, boost) {
      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        // Compute approx & exact
        final IntersectsDifferentiatingQuery.IntersectsDifferentiatingVisitor result =
            intersectsDiffQuery.compute(context);
        if (result.approxDocIdSet == null) {
          return null;
        }
        final DocIdSetIterator approxDISI = result.approxDocIdSet.iterator();
        if (approxDISI == null) {
          return null;
        }
        final DocIdSetIterator exactIterator;
        if (result.exactDocIdSet != null) {
          // If both sets are the same, there's nothing to verify; we needn't return a
          // TwoPhaseIterator
          if (result.approxDocIdSet == result.exactDocIdSet) {
            return new ConstantScoreScorer(this, score(), scoreMode, approxDISI);
          }
          exactIterator = result.exactDocIdSet.iterator();
          assert exactIterator != null;
        } else {
          exactIterator = null;
        }

        final TwoPhaseIterator twoPhaseIterator =
            new TwoPhaseIterator(approxDISI) {

              final TwoPhaseIterator predFuncValues =
                  predicateValueSource.iterator(context, approxDISI);

              @Override
              public boolean matches() throws IOException {
                final int doc = approxDISI.docID();
                if (exactIterator != null) {
                  if (exactIterator.docID() < doc) {
                    exactIterator.advance(doc);
                  }
                  if (exactIterator.docID() == doc) {
                    return true;
                  }
                }
                return predFuncValues.matches();
              }

              @Override
              public float matchCost() {
                return 100; // TODO: use cost of exactIterator.advance() and predFuncValues.cost()
              }
            };

        return new ConstantScoreScorer(this, score(), scoreMode, twoPhaseIterator);
      }

      @Override
      public boolean isCacheable(LeafReaderContext ctx) {
        return predicateValueSource.isCacheable(ctx);
      }
    };
  }

