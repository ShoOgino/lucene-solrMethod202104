  private List<Weighted<Root<String>>> findSimilarDictionaryEntries(
      String word, WordCase originalCase) {
    Comparator<Weighted<Root<String>>> natural = Comparator.naturalOrder();
    PriorityQueue<Weighted<Root<String>>> roots = new PriorityQueue<>(natural.reversed());

    IntsRefFSTEnum<IntsRef> fstEnum = new IntsRefFSTEnum<>(dictionary.words);
    InputOutput<IntsRef> mapping;
    while ((mapping = nextKey(fstEnum, word.length() + 4)) != null) {
      speller.checkCanceled.run();

      IntsRef key = mapping.input;
      if (Math.abs(key.length - word.length()) > MAX_ROOT_LENGTH_DIFF) {
        assert key.length < word.length(); // nextKey takes care of longer keys
        continue;
      }

      String root = toString(key);
      List<Root<String>> entries = filterSuitableEntries(root, mapping.output);
      if (entries.isEmpty()) continue;

      if (originalCase == WordCase.LOWER
          && WordCase.caseOf(root) == WordCase.TITLE
          && !dictionary.hasLanguage("de")) {
        continue;
      }

      String lower = dictionary.toLowerCase(root);
      int sc =
          ngram(3, word, lower, EnumSet.of(NGramOptions.LONGER_WORSE)) + commonPrefix(word, root);

      if (roots.size() == MAX_ROOTS && sc < roots.peek().score) {
        continue;
      }

      entries.forEach(e -> roots.add(new Weighted<>(e, sc)));
      while (roots.size() > MAX_ROOTS) {
        roots.poll();
      }
    }
    return roots.stream().sorted().collect(Collectors.toList());
  }

