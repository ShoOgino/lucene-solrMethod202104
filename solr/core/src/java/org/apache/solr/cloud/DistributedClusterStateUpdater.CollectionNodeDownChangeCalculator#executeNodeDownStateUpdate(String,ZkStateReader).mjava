    /**
     * Entry point to mark all replicas of all collections present on a single node as being DOWN (because the node is down)
     */
    public static void executeNodeDownStateUpdate(String nodeName, ZkStateReader zkStateReader) {
      // This code does a version of what NodeMutator.downNode() is doing. We can't assume we have a cache of the collections,
      // so we're going to read all of them from ZK, fetch the state.json for each and if it has any replicas on the
      // failed node, do an update (conditional of course) of the state.json

      // For Per Replica States collections there is still a need to read state.json, but the update of state.json is replaced
      // by a few znode deletions and creations. Might be faster or slower overall, depending on the number of impacted
      // replicas of such a collection and the total size of that collection's state.json.

      // Note code here also has to duplicate some of the work done in ZkStateReader because ZkStateReader couples reading of
      // the cluster state and maintaining a cached copy of the cluster state. Something likely to be refactored later (once
      // Overseer is totally removed and Zookeeper access patterns become clearer).

      log.debug("DownNode state change invoked for node: {}", nodeName);

      try {
        final List<String> collectionNames = zkStateReader.getZkClient().getChildren(COLLECTIONS_ZKNODE, null, true);

        // Collections are totally independent of each other. Multiple threads could share the load here (need a ZK connection for each though).
        for (String collectionName : collectionNames) {
          CollectionNodeDownChangeCalculator collectionUpdater = new CollectionNodeDownChangeCalculator(collectionName, nodeName);
          ZkUpdateApplicator.applyUpdate(zkStateReader, collectionUpdater);
        }
      } catch (Exception e) {
        if (e instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
        // Overseer behavior is to log an error and carry on when a message fails. See Overseer.ClusterStateUpdater.processQueueItem()
        log.error("Could not successfully process DOWNNODE, giving up", e);
      }
    }

