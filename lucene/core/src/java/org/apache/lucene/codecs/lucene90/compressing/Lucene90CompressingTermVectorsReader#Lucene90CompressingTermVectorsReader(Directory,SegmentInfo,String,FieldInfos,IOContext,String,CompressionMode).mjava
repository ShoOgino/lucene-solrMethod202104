  /** Sole constructor. */
  public Lucene90CompressingTermVectorsReader(
      Directory d,
      SegmentInfo si,
      String segmentSuffix,
      FieldInfos fn,
      IOContext context,
      String formatName,
      CompressionMode compressionMode)
      throws IOException {
    this.compressionMode = compressionMode;
    final String segment = si.name;
    boolean success = false;
    fieldInfos = fn;
    numDocs = si.maxDoc();

    ChecksumIndexInput metaIn = null;
    try {
      // Open the data file
      final String vectorsStreamFN =
          IndexFileNames.segmentFileName(segment, segmentSuffix, VECTORS_EXTENSION);
      vectorsStream = d.openInput(vectorsStreamFN, context);
      version =
          CodecUtil.checkIndexHeader(
              vectorsStream, formatName, VERSION_START, VERSION_CURRENT, si.getId(), segmentSuffix);
      assert CodecUtil.indexHeaderLength(formatName, segmentSuffix)
          == vectorsStream.getFilePointer();

      final String metaStreamFN =
          IndexFileNames.segmentFileName(segment, segmentSuffix, VECTORS_META_EXTENSION);
      metaIn = d.openChecksumInput(metaStreamFN, IOContext.READONCE);
      CodecUtil.checkIndexHeader(
          metaIn,
          VECTORS_INDEX_CODEC_NAME + "Meta",
          META_VERSION_START,
          version,
          si.getId(),
          segmentSuffix);

      packedIntsVersion = metaIn.readVInt();
      chunkSize = metaIn.readVInt();

      // NOTE: data file is too costly to verify checksum against all the bytes on open,
      // but for now we at least verify proper structure of the checksum footer: which looks
      // for FOOTER_MAGIC + algorithmID. This is cheap and can detect some forms of corruption
      // such as file truncation.
      CodecUtil.retrieveChecksum(vectorsStream);

      FieldsIndexReader fieldsIndexReader =
          new FieldsIndexReader(
              d,
              si.name,
              segmentSuffix,
              VECTORS_INDEX_EXTENSION,
              VECTORS_INDEX_CODEC_NAME,
              si.getId(),
              metaIn);

      this.indexReader = fieldsIndexReader;
      this.maxPointer = fieldsIndexReader.getMaxPointer();

      numDirtyChunks = metaIn.readVLong();
      numDirtyDocs = metaIn.readVLong();

      decompressor = compressionMode.newDecompressor();
      this.reader =
          new BlockPackedReaderIterator(vectorsStream, packedIntsVersion, PACKED_BLOCK_SIZE, 0);

      if (metaIn != null) {
        CodecUtil.checkFooter(metaIn, null);
        metaIn.close();
      }

      success = true;
    } catch (Throwable t) {
      if (metaIn != null) {
        CodecUtil.checkFooter(metaIn, t);
        throw new AssertionError("unreachable");
      } else {
        throw t;
      }
    } finally {
      if (!success) {
        IOUtils.closeWhileHandlingException(this, metaIn);
      }
    }
  }

