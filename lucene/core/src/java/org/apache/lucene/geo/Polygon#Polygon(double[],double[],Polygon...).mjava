  /** Creates a new Polygon from the supplied latitude/longitude array, and optionally any holes. */
  public Polygon(double[] polyLats, double[] polyLons, Polygon... holes) {
    if (polyLats == null) {
      throw new IllegalArgumentException("polyLats must not be null");
    }
    if (polyLons == null) {
      throw new IllegalArgumentException("polyLons must not be null");
    }
    if (holes == null) {
      throw new IllegalArgumentException("holes must not be null");
    }
    if (polyLats.length != polyLons.length) {
      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
    }
    if (polyLats.length != polyLons.length) {
      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
    }
    if (polyLats.length < 4) {
      throw new IllegalArgumentException("at least 4 polygon points required");
    }
    if (polyLats[0] != polyLats[polyLats.length - 1]) {
      throw new IllegalArgumentException(
          "first and last points of the polygon must be the same (it must close itself): polyLats[0]="
              + polyLats[0]
              + " polyLats["
              + (polyLats.length - 1)
              + "]="
              + polyLats[polyLats.length - 1]);
    }
    if (polyLons[0] != polyLons[polyLons.length - 1]) {
      throw new IllegalArgumentException(
          "first and last points of the polygon must be the same (it must close itself): polyLons[0]="
              + polyLons[0]
              + " polyLons["
              + (polyLons.length - 1)
              + "]="
              + polyLons[polyLons.length - 1]);
    }
    for (int i = 0; i < polyLats.length; i++) {
      GeoUtils.checkLatitude(polyLats[i]);
      GeoUtils.checkLongitude(polyLons[i]);
    }
    for (int i = 0; i < holes.length; i++) {
      Polygon inner = holes[i];
      if (inner.holes.length > 0) {
        throw new IllegalArgumentException("holes may not contain holes: polygons may not nest.");
      }
    }
    this.polyLats = polyLats.clone();
    this.polyLons = polyLons.clone();
    this.holes = holes.clone();

    // compute bounding box
    double minLat = polyLats[0];
    double maxLat = polyLats[0];
    double minLon = polyLons[0];
    double maxLon = polyLons[0];

    double windingSum = 0d;
    final int numPts = polyLats.length - 1;
    for (int i = 1, j = 0; i < numPts; j = i++) {
      minLat = Math.min(polyLats[i], minLat);
      maxLat = Math.max(polyLats[i], maxLat);
      minLon = Math.min(polyLons[i], minLon);
      maxLon = Math.max(polyLons[i], maxLon);
      // compute signed area
      windingSum +=
          (polyLons[j] - polyLons[numPts]) * (polyLats[i] - polyLats[numPts])
              - (polyLats[j] - polyLats[numPts]) * (polyLons[i] - polyLons[numPts]);
    }
    this.minLat = minLat;
    this.maxLat = maxLat;
    this.minLon = minLon;
    this.maxLon = maxLon;
    this.windingOrder = (windingSum < 0) ? GeoUtils.WindingOrder.CCW : GeoUtils.WindingOrder.CW;
  }

