  /**
   * @return true if we have reached max attempts or should stop recovering for some other reason
   */
  private boolean waitBetweenRecoveries(String coreName) {
    // lets pause for a moment and we need to try again...
    // TODO: we don't want to retry for some problems?
    // Or do a fall off retry...
    try {
      if (isClosed()) {
        log.info("Recovery for core {} has been closed", coreName);
        return true;
      }

      log.error("Recovery failed - trying again... ({})", retries);

      retries++;
      if (retries >= maxRetries) {
        SolrException.log(log, "Recovery failed - max retries exceeded (" + retries + ").");
        try {
          recoveryFailed(zkController, this.coreDescriptor);
        } catch (Exception e) {
          SolrException.log(log, "Could not publish that recovery failed", e);
        }
        return true;
      }
    } catch (Exception e) {
      SolrException.log(log, "An error has occurred during recovery", e);
    }

    try {
      // Wait an exponential interval between retries, start at 4 seconds and work up to a minute.
      // Meanwhile we will check in 2s sub-intervals to see if we've been closed
      // Maximum loop count is 30 because we never want to wait longer than a minute (2s * 30 = 1m)
      int loopCount = retries < 5 ? (int) Math.pow(2, retries) : 30;
      if (log.isInfoEnabled()) {
        log.info("Wait [{}] seconds before trying to recover again (attempt={})",
                TimeUnit.MILLISECONDS.toSeconds(loopCount * startingRecoveryDelayMilliSeconds), retries);
      }
      for (int i = 0; i < loopCount; i++) {
        if (isClosed()) {
          log.info("Recovery for core {} has been closed", coreName);
          break; // check if someone closed us
        }
        Thread.sleep(startingRecoveryDelayMilliSeconds);
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      log.warn("Recovery was interrupted.", e);
      close = true;
    }
    return false;
  }

