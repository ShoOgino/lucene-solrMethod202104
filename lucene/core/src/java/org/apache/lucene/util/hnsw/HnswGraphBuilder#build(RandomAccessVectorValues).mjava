  /**
   * Reads all the vectors from two copies of a random access VectorValues. Providing two copies enables efficient retrieval
   * without extra data copying, while avoiding collision of the returned values.
   * @param vectors the vectors for which to build a nearest neighbors graph. Must be an independet accessor for the vectors
   */
  public HnswGraph build(RandomAccessVectorValues vectors) throws IOException {
    if (vectors == vectorValues) {
      throw new IllegalArgumentException("Vectors to build must be independent of the source of vectors provided to HnswGraphBuilder()");
    }
    long start = System.nanoTime(), t = start;
    // start at node 1! node 0 is added implicitly, in the constructor
    for (int node = 1; node < vectors.size(); node++) {
      addGraphNode(vectors.vectorValue(node));
      if (node % 10000 == 0) {
        if (infoStream.isEnabled(HNSW_COMPONENT)) {
          long now = System.nanoTime();
          infoStream.message(HNSW_COMPONENT,
              String.format(Locale.ROOT, "built %d in %d/%d ms", node, ((now - t) / 1_000_000), ((now - start) / 1_000_000)));
          t = now;
        }
      }
    }
    return hnsw;
  }

