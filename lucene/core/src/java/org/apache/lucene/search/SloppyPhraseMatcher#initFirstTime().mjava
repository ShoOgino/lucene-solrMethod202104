  /**
   * initialize with checking for repeats. Heavy work, but done only for the first candidate doc.
   *
   * <p>If there are repetitions, check if multi-term postings (MTP) are involved.
   *
   * <p>Without MTP, once PPs are placed in the first candidate doc, repeats (and groups) are
   * visible.<br>
   * With MTP, a more complex check is needed, up-front, as there may be "hidden collisions".<br>
   * For example P1 has {A,B}, P1 has {B,C}, and the first doc is: "A C B". At start, P1 would point
   * to "A", p2 to "C", and it will not be identified that P1 and P2 are repetitions of each other.
   *
   * <p>The more complex initialization has two parts:<br>
   * (1) identification of repetition groups.<br>
   * (2) advancing repeat groups at the start of the doc.<br>
   * For (1), a possible solution is to just create a single repetition group, made of all repeating
   * pps. But this would slow down the check for collisions, as all pps would need to be checked.
   * Instead, we compute "connected regions" on the bipartite graph of postings and terms.
   */
  private boolean initFirstTime() throws IOException {
    // System.err.println("initFirstTime: doc: "+min.doc);
    checkedRpts = true;
    placeFirstPositions();

    LinkedHashMap<Term, Integer> rptTerms = repeatingTerms();
    hasRpts = !rptTerms.isEmpty();

    if (hasRpts) {
      rptStack = new PhrasePositions[numPostings]; // needed with repetitions
      ArrayList<ArrayList<PhrasePositions>> rgs = gatherRptGroups(rptTerms);
      sortRptGroups(rgs);
      if (!advanceRepeatGroups()) {
        return false; // PPs exhausted
      }
    }

    fillQueue();
    return true; // PPs available
  }

