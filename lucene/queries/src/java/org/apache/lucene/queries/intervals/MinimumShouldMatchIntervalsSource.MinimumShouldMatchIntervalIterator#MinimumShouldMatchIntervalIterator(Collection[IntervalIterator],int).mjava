    MinimumShouldMatchIntervalIterator(Collection<IntervalIterator> subs, int minShouldMatch) {
      this.disiQueue = new DisiPriorityQueue(subs.size());
      float mc = 0;
      for (IntervalIterator it : subs) {
        this.disiQueue.add(new DisiWrapper(it));
        mc += it.matchCost();
      }
      this.approximation = new DisjunctionDISIApproximation(disiQueue);
      this.matchCost = mc;
      this.minShouldMatch = minShouldMatch;

      this.proximityQueue =
          new PriorityQueue<IntervalIterator>(minShouldMatch) {
            @Override
            protected boolean lessThan(IntervalIterator a, IntervalIterator b) {
              return a.start() < b.start() || (a.start() == b.start() && a.end() >= b.end());
            }
          };
      this.backgroundQueue =
          new PriorityQueue<IntervalIterator>(subs.size()) {
            @Override
            protected boolean lessThan(IntervalIterator a, IntervalIterator b) {
              return a.end() < b.end() || (a.end() == b.end() && a.start() >= b.start());
            }
          };
    }

